/*! Scribble JS, a project by Bryce Summers.
 *  Single File concatenated by Grunt Concatenate on 03-01-2017
 */
/*! Bryce Data Structures, a project by Bryce Summers.
 *  Single File concatenated by Grunt Concatenate on 03-01-2017
 */
/*
 * Defines namespaces.
 * Adapted by Bryce Summers on 1 - 2 - 2017.
 */

// Bryce Data Structures.
BDS = {};
// Generated by CoffeeScript 1.11.1

/*
Standard Array methods.
 */

(function() {
  BDS.Arrays = {};

  BDS.Arrays.swap = function(array, i1, i2) {
    var temp;
    temp = array[i1];
    array[i1] = array[i2];
    array[i2] = temp;
  };

}).call(this);

// Generated by CoffeeScript 1.11.1
(function() {
  BDS.S_Curve = (function() {
    function S_Curve() {
      this._spline = new THREE.CatmullRomCurve3();
      this._point_discretization = [];
    }

    S_Curve.prototype.addPoint = function(p) {
      return this._spline.points.push(p);
    };

    S_Curve.prototype.numPoints = function(p) {
      return this._spline.points.length;
    };

    S_Curve.prototype.getPointAtIndex = function(i) {
      return this._spline.points[i];
    };

    S_Curve.prototype.getLastPoint = function() {
      return this.getPointAtIndex(this.numPoints() - 1);
    };

    S_Curve.prototype.removeLastPoint = function() {
      return this._spline.points.pop();
    };

    S_Curve.prototype.position = function(t) {
      return this._spline.getPoint(t);
    };

    S_Curve.prototype.tangent = function(t) {
      return this._spline.getTangent(t);
    };

    S_Curve.prototype.offset = function(t, amount) {
      var tan, x, y;
      tan = this.tangent(t);
      tan.setLength(amount);
      x = tan.x;
      y = tan.y;
      tan.x = y;
      tan.y = -x;
      return this.position(t).add(tan);
    };

    S_Curve.prototype.getDiscretization = function(max_length) {
      return this._discretization;
    };

    S_Curve.prototype.updateDiscretization = function(max_length) {
      var S, high, low, output, p0, p_high, p_low;
      output = [];
      p0 = this._spline.getPoint(0);
      output.push(p0);
      S = [];
      S.push(1.0);
      low = 0;
      p_low = this._spline.getPoint(low);
      while (S.length !== 0) {
        high = S.pop();
        p_high = this._spline.getPoint(high);
        while (p_low.distanceTo(p_high) > max_length) {
          S.push(high);
          high = (low + high) / 2.0;
          p_high = this._spline.getPoint(high);
        }
        output.push(p_high);
        low = high;
        p_low = p_high;
        continue;
      }
      return this._discretization = output;
    };

    S_Curve.prototype.getOffsets = function(max_length, amount, times_output) {
      var S, high, low, o0, output, p_high, p_low;
      o0 = this.offset(0, amount);
      output = [];
      output.push(o0);
      if (times_output) {
        times_output.push(0);
      }
      S = [];
      S.push(1.0);
      low = 0;
      p_low = this.offset(low, amount);
      while (S.length !== 0) {
        high = S.pop();
        p_high = this.offset(high, amount);
        while (p_low.distanceTo(p_high) > max_length) {
          S.push(high);
          high = (low + high) / 2.0;
          p_high = this.offset(high, amount);
        }
        output.push(p_high);
        if (times_output) {
          times_output.push(high);
        }
        low = high;
        p_low = p_high;
        continue;
      }
      return output;
    };

    return S_Curve;

  })();

}).call(this);

// Generated by CoffeeScript 1.11.1
(function() {
  BDS.S_AABVH = (function() {
    function S_AABVH(obj, xyz) {
      var i, j, left_partition, ref, ref1, right_partition, triangle_list;
      this._leafs = [];
      this._leaf_node = false;
      if (obj instanceof THREE.Object3D) {
        triangle_list = this._extract_triangle_list(obj);
      } else {
        triangle_list = obj;
      }
      this._ensure_bounding_boxes(triangle_list);
      this._AABB = this._compute_AABB(triangle_list);
      if (triangle_list.length < 100) {
        this._leaf_node = true;
        for (i = j = 0, ref = triangle_list.length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
          this._leafs.push(triangle_list[i]);
        }
        return;
      }
      if (xyz.dim === 2) {
        this._AABB.min.z = -1;
        this._AABB.max.z = +1;
      }
      triangle_list = this._sort_triangle_list(triangle_list, xyz);
      ref1 = this._partition_by_SA(triangle_list), left_partition = ref1[0], right_partition = ref1[1];
      xyz.val = this._nextXYZ(xyz);
      this._left = new TSAG.S_AABVH(left_partition, xyz);
      this._right = new TSAG.S_AABVH(right_partition, xyz);
    }

    S_AABVH.prototype.query_point = function(x, y) {
      var ray;
      ray = new THREE.Ray(new THREE.Vector3(x, y, 10), new THREE.Vector3(0, 0, 1));
      return this.query_ray(ray);
    };

    S_AABVH.prototype.query_ray = function(ray) {
      var a, b, c, i, intersection, j, output, ref, triangle;
      if (ray.intersectsBox(this._AABB) === null) {
        return null;
      }
      if (this._leaf_node) {
        for (i = j = 0, ref = this._leafs.length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
          triangle = this._leafs[i];
          a = triangle.a;
          b = triangle.b;
          c = triangle.c;
          intersection = ray.intersectTriangle(a, b, c, false);
          if (intersection !== null) {
            return triangle;
          }
        }
      } else {
        output = this._left.query_ray(ray);
        if (output !== null) {
          return output;
        }
        output = this._right.query_ray(ray);
        if (output !== null) {
          return output;
        }
      }
      return null;
    };

    S_AABVH.prototype.toVisual = function(material) {
      var geom, geometries, j, len1, line, output;
      geometries = [];
      this.get_AABB_geometries(geometries);
      output = new THREE.Object3D();
      for (j = 0, len1 = geometries.length; j < len1; j++) {
        geom = geometries[j];
        line = new THREE.Line(geom, material);
        output.add(line);
      }
      return output;
    };

    S_AABVH.prototype.get_AABB_geometries = function(output) {
      var geometry, max, max_x, max_y, min, min_x, min_y;
      min = this._AABB.min;
      max = this._AABB.max;
      min_x = min.x;
      min_y = min.y;
      max_x = max.x;
      max_y = max.y;
      geometry = new THREE.Geometry();
      geometry.vertices.push(new THREE.Vector3(min_x, min_y, 0), new THREE.Vector3(max_x, min_y, 0), new THREE.Vector3(max_x, max_y, 0), new THREE.Vector3(min_x, max_y, 0), new THREE.Vector3(min_x, min_y, 0));
      output.push(geometry);
      if (!this._leaf_node) {
        this._left.get_AABB_geometries(output);
        this._right.get_AABB_geometries(output);
      }
    };


    /*
     - Private Construction Methods. -----------------------
     */

    S_AABVH.prototype._extract_triangle_list = function(obj) {
      var a, b, c, face, faces, geometry, j, k, len1, len2, localToWorld, mesh, mesh_list, triangle, triangle_list, vertices;
      mesh_list = this._extract_mesh_list(obj);
      triangle_list = [];
      for (j = 0, len1 = mesh_list.length; j < len1; j++) {
        mesh = mesh_list[j];
        geometry = mesh.geometry;
        vertices = geometry.vertices;
        faces = geometry.faces;
        localToWorld = mesh.matrixWorld;
        for (k = 0, len2 = faces.length; k < len2; k++) {
          face = faces[k];
          a = vertices[face.a].clone();
          b = vertices[face.b].clone();
          c = vertices[face.c].clone();
          a.applyMatrix4(localToWorld);
          b.applyMatrix4(localToWorld);
          c.applyMatrix4(localToWorld);
          triangle = new THREE.Triangle(a, b, c);
          triangle.mesh = mesh;
          triangle_list.push(triangle);
        }
      }
      return triangle_list;
    };

    S_AABVH.prototype._extract_mesh_list = function(obj) {
      var add_output, output;
      output = [];
      add_output = function(o) {
        if (o.geometry) {
          return output.push(o);
        }
      };
      obj.traverse(add_output);
      return output;
    };

    S_AABVH.prototype._sort_triangle_list = function(triangle_list, xyz) {
      var centroid_index_list, i, j, len, output, ref, sort_function, triangle_index;
      centroid_index_list = this._centroid_index_list(triangle_list);
      sort_function = function(a, b) {
        switch (xyz.val) {
          case 'x':
            return a.centroid.x - b.centroid.x;
          case 'y':
            return a.centroid.y - b.centroid.y;
          case 'z':
            return a.centroid.z - b.centroid.z;
        }
        debugger;
        return console.log("xyz is malformed.");
      };
      centroid_index_list.sort(sort_function);
      output = [];
      len = triangle_list.length;
      for (i = j = 0, ref = len; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
        triangle_index = centroid_index_list[i].index;
        output.push(triangle_list[triangle_index]);
      }
      return output;
    };

    S_AABVH.prototype._nextXYZ = function(xyz) {
      if (xyz.dim === 2) {
        switch (xyz.val) {
          case 'x':
            return 'y';
          case 'y':
            return 'x';
          case 'z':
            console.log("xyz is malformed.");
        }
        debugger;
        console.log("xyz is malformed.");
      } else if (xyz.dim === 3) {
        switch (xyz) {
          case 'x':
            return 'y';
          case 'y':
            return 'z';
          case 'z':
            return 'x';
        }
      }
      debugger;
      return console.log("Case not handled.");
    };

    S_AABVH.prototype._centroid_index_list = function(triangle_list) {
      var centroid_index_node, i, j, len, output, ref;
      output = [];
      len = triangle_list.length;
      for (i = j = 0, ref = len; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
        centroid_index_node = {};
        centroid_index_node.index = i;
        centroid_index_node.centroid = this._computeCentroid(triangle_list[i]);
        output.push(centroid_index_node);
      }
      return output;
    };

    S_AABVH.prototype._computeCentroid = function(triangle) {
      var centroid;
      centroid = new THREE.Vector3(0, 0, 0);
      centroid.add(triangle.a);
      centroid.add(triangle.b);
      centroid.add(triangle.c);
      centroid.divideScalar(3);
      return centroid;
    };

    S_AABVH.prototype._partition_by_SA = function(triangle_list) {
      var i, i0, j, k, l, left, left_AABB, m, min_index, min_sah, ref, ref1, ref2, ref3, ref4, right, right_AABB, sah, sah_left, sah_right;
      min_sah = Number.MAX_VALUE;
      min_index = -1;
      left = [triangle_list[0]];
      right = [];
      i0 = triangle_list.length - 1;
      for (i = j = ref = i0; ref <= 1 ? j <= 1 : j >= 1; i = ref <= 1 ? ++j : --j) {
        right.push(triangle_list[i]);
      }
      for (i = k = 1, ref1 = i0; 1 <= ref1 ? k <= ref1 : k >= ref1; i = 1 <= ref1 ? ++k : --k) {
        left_AABB = this._compute_AABB(left);
        sah_left = this._compute_SA(left_AABB);
        right_AABB = this._compute_AABB(right);
        sah_right = this._compute_SA(right_AABB);
        sah = Math.max(sah_left, sah_right);
        if (sah < min_sah) {
          min_sah = sah;
          min_index = i;
        }
        left.push(right.pop());
      }
      left = [];
      right = [];
      for (i = l = 0, ref2 = min_index; 0 <= ref2 ? l < ref2 : l > ref2; i = 0 <= ref2 ? ++l : --l) {
        left.push(triangle_list[i]);
      }
      for (i = m = ref3 = min_index, ref4 = i0; ref3 <= ref4 ? m <= ref4 : m >= ref4; i = ref3 <= ref4 ? ++m : --m) {
        right.push(triangle_list[i]);
      }
      return [left, right];
    };

    S_AABVH.prototype._ensure_bounding_boxes = function(triangle_list) {
      var i, j, len, ref, results, triangle;
      len = triangle_list.length;
      results = [];
      for (i = j = 0, ref = len; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
        triangle = triangle_list[i];
        if (!triangle) {
          debugger;
        }
        if (!triangle.boundingBox) {
          results.push(this._computeBoundingBox(triangle));
        } else {
          results.push(void 0);
        }
      }
      return results;
    };

    S_AABVH.prototype._computeBoundingBox = function(triangle) {
      var AABB;
      AABB = new THREE.Box3();
      AABB.expandByPoint(triangle.a);
      AABB.expandByPoint(triangle.b);
      AABB.expandByPoint(triangle.c);
      return triangle.boundingBox = AABB;
    };

    S_AABVH.prototype._compute_AABB = function(triangle_list) {
      var AABB, i, j, output, ref, triangle;
      output = new THREE.Box3();
      for (i = j = 0, ref = triangle_list.length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
        triangle = triangle_list[i];
        AABB = triangle.boundingBox;
        output.union(AABB);
      }
      return output;
    };

    S_AABVH.prototype._compute_SA = function(AABB) {
      var dx, dy, dz, max, min, sxy, sxz, syz;
      min = AABB.min;
      max = AABB.max;
      dx = max.x - min.x;
      dy = max.y - min.y;
      dz = max.z - min.z;
      sxy = dx * dy;
      sxz = dx * dz;
      syz = dy * dz;
      return sxy + sxz + syz;
    };

    return S_AABVH;

  })();

}).call(this);

// Generated by CoffeeScript 1.11.1

/*
Heap
Implements a priority Queue using an Array Heap.
Written by Bryce Summers on 11 - 2 - 2017.

 * 
 * Note : This is a MIN heap.
 * 
 * Heap property :  For every element in the tree,
 *                  it is less than or equal to its left and right children in the tree as defined by the elements at the indexes associated by
 *                  the relationships index_left(index) and index_right(index).
 *  
 * Root node is always at index 0.
 * 
 * Left biased, when equal keys are present, the one on the left will be chosen.
 * 
 * Allows for duplicate keys.
 * 
 * Binary tree invariants :
 * The heap is represented by a binary tree that is encoded by index relationships within an unbounded array.
 * We maintain the UBA with a minimality of nodes, so the UBA will only contain N elements, when size = n.
 * 
 * The heap is as balanced as possible. This causes their to be a preference for left children over right children.
 * 
 * FIXME : I will need to work to preserve key stability, so that all keys will eventually be deleted, even if all keys entered are equal.
 */

(function() {
  BDS.Heap = (function() {
    Heap._D = 3;

    function Heap(data_in, comparator) {
      this._LE = comparator;
      if (!data_in) {
        this._data = [];
      } else {
        this._data = data_in.slice(0);
        this._heapify();
      }
    }

    Heap.prototype.size = function() {
      return this._data.length;
    };

    Heap.prototype.isEmpty = function() {
      return this._data.length === 0;
    };

    Heap.prototype.add = function(elem) {
      var len;
      len = this._data.length;
      this._data.push(elem);
      return this._sift_up(len);
    };

    Heap.prototype.append = function(elems) {
      var e, j, len1, results;
      results = [];
      for (j = 0, len1 = elems.length; j < len1; j++) {
        e = elems[j];
        results.push(this.add(e));
      }
      return results;
    };

    Heap.prototype.peek = function() {
      return this._data[0];
    };

    Heap.prototype.dequeue = function() {
      var last, output;
      if (this._data.length === 1) {
        return this._data.pop();
      }
      output = this._data[0];
      last = this._data.pop();
      this._data[0] = last;
      this.sift_down(0);
      return output;
    };

    Heap.prototype.toArray = function() {
      return this._data.slice(0);
    };

    Heap.prototype.getElem = function(index) {
      return this._data[index];
    };


    /*
    // Heapifies all of the nodes of the Tree with a root at the given index.
    // Builds the heap invariant downwards to all sub trees.
    // O(n), checks each node in the tree once.
    // Transforms a random array into an array that meets the heap invariants.
     */

    Heap.prototype._heapify = function() {
      var i, j, ref;
      for (i = j = ref = this._data.length - 1; ref <= 0 ? j <= 0 : j >= 0; i = ref <= 0 ? ++j : --j) {
        this.sift_down(i);
      }
    };


    /*
    // Given an index, swaps the node down the tree while maintaining the min
    // heap invariant until the node is in an invariant correct place.
    // O(log(n)). Non recursive, so has O(1) function calls.
    // SIFT down.
     */

    Heap.prototype.sift_down = function(index) {
      var child, child_index, elem, i, min_elem, min_elem_index, size;
      size = this._data.length;
      child_index = this._index_child(index, 1);
      elem = this._data[index];
      while (child_index < size) {
        min_elem_index = -1;
        min_elem = elem;
        i = child_index;
        while (i < child_index + BDS.Heap._D && i < size) {
          child = this._data[i];
          if (this._LE(child, min_elem)) {
            min_elem = child;
            min_elem_index = i;
          }
          i++;
        }
        if (min_elem === elem) {
          return;
        }
        this._min_first(index, min_elem_index);
        index = min_elem_index;
        child_index = this._index_child(index, 1);
      }
    };

    Heap.prototype._sift_up = function(index) {
      var parent_index, results;
      parent_index = this._index_parent(index);
      results = [];
      while (index > 0 && this._min_first(parent_index, index)) {
        index = parent_index;
        results.push(parent_index = this._index_parent(index));
      }
      return results;
    };

    Heap.prototype._index_parent = function(index) {
      return Math.floor((index - 1) / BDS.Heap._D);
    };

    Heap.prototype._index_child = function(index, child_index) {
      return BDS.Heap._D * index + child_index;
    };

    Heap.prototype._min_first = function(index1, index2) {
      var elem1, elem2;
      elem1 = this._data[index1];
      elem2 = this._data[index2];
      if (!this._LE(elem1, elem2)) {
        BDS.Arrays.swap(this._data, index1, index2);
        return true;
      }
      return false;
    };

    Heap.prototype.toString = function() {
      var elem, j, len1, output, ref;
      output = "";
      output += "\nMinHeap[";
      ref = this._data;
      for (j = 0, len1 = ref.length; j < len1; j++) {
        elem = ref[j];
        output += elem;
        output += ",\n";
      }
      output += "]";
      return output;
    };

    Heap.prototype.clone = function() {
      return new BDS.Heap(this._data, this._LE);
    };

    Heap.prototype.toSortedArray = function() {
      var heap, i, j, len, output, ref;
      len = this._data.length;
      output = [];
      heap = this.clone();
      for (i = j = 0, ref = len; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
        output.push(heap.dequeue());
      }
      return output;
    };

    Heap.prototype.clear = function() {
      return this._data = [];
    };

    return Heap;

  })();

}).call(this);

/*
 * Defines namespaces.
 * Adapted by Bryce Summers on 12 - 30 - 2016.
 */

// Bryce Data Structures.
SCRIB = {};
// Generated by CoffeeScript 1.11.1

/*
Halfedge Graph / Mesh class.
Written by Bryce Summers on 1 - 2 - 2017.
 */


/*
*
* Usage:
*
* The Application programmer / New Media Artist specifies the following:
* 1. The data format they have availible for graph construction (e.g. vectors of openframeworks points.)
* 2. The Algorithms they need.
* 3. The data format that they wish to receive the results in.
*
* They will do so by specifying which class definitions they want.
*
* The algorithm designer / computational geometer specifies the following:
* 1. Definitions for the associated data.
* 2. The interface for constructing Graphs from application data
* 3. The interface for running algorithms on the Graphs.
* 4. The interface for allowing the application programmer to retrieve the results.
*
* If done elegantly, the New Media Artist should never need to touch the halfedge mesh, go on pointer journeys, and
* they should be able to treat the internal implementation as a black box.
 */

(function() {
  SCRIB.Graph_Data = (function() {
    function Graph_Data() {}

    return Graph_Data;

  })();

  SCRIB.Vertex_Data = (function() {
    function Vertex_Data() {}

    return Vertex_Data;

  })();

  SCRIB.Face_Data = (function() {
    function Face_Data() {}

    return Face_Data;

  })();

  SCRIB.Halfedge_Data = (function() {
    function Halfedge_Data() {}

    return Halfedge_Data;

  })();

  SCRIB.Edge_Data = (function() {
    function Edge_Data() {}

    return Edge_Data;

  })();


  /*
  // FIXME: Clean up this prose.
  
  // -- Structural definition of classes.
  // Every class is specified by its connectivity information and a pointer to associated user data.
  
  // All elements may be marked and unmarked by algorithms and users to specific sets of elements that meet various criteria.
  
  // The Graph class represents an entire graph embedding defined by points in space.
  // For the purposes of the facefinder, the output graph will be planar.
  // connected via edges that intersect only at vertices.
  // The FaceFinder class may be used to derive a Graph from a set of potentially intersecting input polylines.
   */

  SCRIB.Graph = (function() {

    /*
    // Graph classes are where all of the actual data will be stored, so it contains vectors of valued data,
    // rather than pointers.
    // All ID's contained within these vectors will reference tha index of the object within these vectors.
    
    // Ideally, vertices, edges, and halfedges will be ordered logically according to the order they were input into the facefinder,
    // but I will need to do some more thinking on how to formally specify these things.
     */
    function Graph() {
      this.faces = new BDS.LinkedList();
      this.vertices = new BDS.LinkedList();
      this.edges = new BDS.LinkedList();
      this.halfedge = new BDS.LinkedList();
      this.data = new SCRIB.Graph_Data();
    }

    Graph.prototype.newFace = function() {};

    Graph.prototype.newVertex = function() {};

    Graph.prototype.newEdge = function() {};

    Graph.prototype.newHalfedge = function() {};

    Graph.prototype.newFace = function() {
      var ID, output;
      int(ID = faces.size());
      Face * (output = new Face());
      faces.push_back(output);
      output(function() {
        return ID = ID;
      });
      return output;
    };

    Graph.prototype.newVertex = function() {
      var ID, output;
      int(ID = vertices.size());
      Vertex * (output = new Vertex());
      vertices.push_back(output);
      output(function() {
        return ID = ID;
      });
      return output;
    };

    Graph.prototype.newEdge = function() {
      var ID, output;
      int(ID = edges.size());
      Edge * (output = new Edge());
      edges.push_back(output);
      output(function() {
        return ID = ID;
      });
      return output;
    };

    Graph.prototype.newHalfedge = function() {
      var ID, output;
      int(ID = halfedges.size());
      Halfedge * (output = new Halfedge());
      halfedges.push_back(output);
      output(function() {
        return ID = ID;
      });
      return output;
    };

    return Graph;

  })();


  /*
  
      // Accessing functions. We keep this interface, because then we only have to guranteed that the this.get(element.ID) = element.
      // We could even change the internal structure to a non contiguous lookup and the interface would be preserved.
  
      Face * getFace(int ID)
      {
          return faces[ID];
      }
  
      Vertex * getVertex(int ID)
      {
          return vertices[ID];
      }
  
      Edge * getEdge(int ID)
      {
          return edges[ID];
      }
  
      Halfedge * getHalfedge(int ID)
      {
          return halfedges[ID];
      }
  
      size_t numFaces()
      {
          return faces.size();
      }
  
      size_t numVertices()
      {
          return vertices.size();
      }
  
      size_t numEdges()
      {
          return edges.size();
      }
  
      // Should theoretically be numEdges * 2.
      size_t numHalfedges()
      {
          return halfedges.size();
      }
  
      // -- Iteration functions.
  
      Face_Iter facesBegin() { return faces.begin(); }
      Face_Iter facesEnd() { return faces.end(); }
  
      Vertex_Iter verticesBegin() { return vertices.begin(); }
      Vertex_Iter verticesEnd() { return vertices.end(); }
  
      Edge_Iter edgesBegin() { return edges.begin(); }
      Edge_Iter edgesEnd() { return edges.end(); }
  
      Halfedge_Iter halfedgesBegin() { return halfedges.begin(); }
      Halfedge_Iter halfedgesEnd()   { return halfedges.end();   }
  
  };
  
  class Face
  {
  public:
  
      // Representative from the interior loop of halfedges defining the boundary of the face.
      Halfedge * halfedge;
  
      Face_Data * data;
      int ID;
  };
  
  class Vertex
  {
  public:
  
      // A representative halfedge that is traveling away from this Vertex.
      // this -> halfedge -> vertex = this.
      Halfedge * halfedge;
  
      Vertex_Data * data;
      int ID;
  };
  
  // Non directed edges, very useful for getting consecutive ID's within input polylines.
  class Edge
  {
  public:
  
      Halfedge * halfedge;
  
      Edge_Data * data;
      int ID;
  };
  
  
  class Halfedge
  {
  public:
  
      Halfedge * twin;
      Halfedge * next;
      Halfedge * prev;
  
      Face * face;
      Edge * edge;
      Vertex * vertex;
  
      Halfedge_Data * data;
      int ID;
  };
   */

}).call(this);

// Generated by CoffeeScript 1.11.1

/*

Intersector

Written by Bryce Summers on 1 - 2 - 2017.

Adapted from: https://github.com/Bryce-Summers/ofxScribbleSegmenter

Canonical scrib::Line objects are represented by LineTuple objects in a bst.
Events along the sweep line are managed by a priority queue.

This implementation should properly handle lines originating from the same end points.

Note : Sets regard types as being equal when their cooresponding ordering operator returns true reflexively.
BDS structure use <= comparator predicate functions.
 */

(function() {
  SCRIB.Intersector = (function() {
    function Intersector() {}


    /*
    Calls the Line::intersect method on all intersecting lines.
    Does not treat lines that intersect at common points as intersecting.
     * takes arrays of Scrib.Line objects.
    SCRIB.Line[] -> () [intersection sideeffects]
     */

    Intersector.prototype.intersect = function(lines) {
      var event, event_queue, i, j, len, ref, results, tupleSet;
      event_queue = new SCRIB.EventPQ(lines);
      tupleSet = new SCRIB.LineTupleSet();
      len = event_queue.size();
      results = [];
      for (i = j = 0, ref = len; j < ref; i = j += 1) {
        event = event_queue.delMin();
        switch (event.type) {
          case SCRIB.Event.ENTER:
            tupleSet.addTuple(event.tuple2, i);
            continue;
          case SCRIB.Event.EXIT:
            tupleSet.removeTuple(event.tuple2);
            continue;
          default:
            results.push(void 0);
        }
      }
      return results;
    };


    /*
    Slower, but more robust version of intersect.
    Naive N^2 Intersection Algorithm.
     */

    Intersector.prototype.intersect_brute_force = function(lines) {
      var a, b, j, numLines, ref, results;
      numLines = lines.length;
      results = [];
      for (a = j = 0, ref = numLines; 0 <= ref ? j < ref : j > ref; a = 0 <= ref ? ++j : --j) {
        results.push((function() {
          var k, ref1, ref2, results1;
          results1 = [];
          for (b = k = ref1 = a + 1, ref2 = numLines; ref1 <= ref2 ? k < ref2 : k > ref2; b = ref1 <= ref2 ? ++k : --k) {
            results1.push(lines[a].intersect(lines[b]));
          }
          return results1;
        })());
      }
      return results;
    };

    return Intersector;

  })();


  /*
  Event Priority Queue methods.
   */

  SCRIB.EventPQ = (function() {
    function EventPQ(lines) {
      var enter, events, exit, i, j, len, line, p1, p2, ref;
      events = [];
      len = lines.length;
      for (i = j = 0, ref = len; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
        line = lines[i];
        enter = new SCRIB.Event();
        exit = new SCRIB.Event();
        p1 = line.p1;
        p2 = line.p2;
        if (p1.x < p2.x || (p1.x === p2.x && p1.y < p2.y)) {
          this._populateEvent(enter, exit, p1, p2, line, i);
        } else {
          this._populateEvent(enter, exit, p2, p1, line, i);
        }
        events.push(enter);
        events.push(exit);
      }
      this.PQ = new BDS.Heap(events, SCRIB.Event_Comparator);
    }

    EventPQ.prototype._populateEvent = function(enter, exit, p1, p2, line, id) {
      var line_tuple, line_tuple2;
      enter.type = SCRIB.Event.ENTER;
      exit.type = SCRIB.Event.EXIT;
      enter.x = p1.x;
      enter.y = p1.y;
      exit.x = p2.x;
      exit.y = p2.y;
      line_tuple = new SCRIB.LineTuple();
      line_tuple.x = p1.x;
      line_tuple.y = p1.y;
      line_tuple.line = line;
      line_tuple.id = id;
      line_tuple2 = new SCRIB.LineTuple();
      line_tuple2.x = p2.x;
      line_tuple2.y = p2.y;
      line_tuple2.line = line;
      line_tuple2.id = id;
      enter.tuple1 = line_tuple;
      enter.tuple2 = line_tuple2;
      exit.tuple1 = line_tuple;
      return exit.tuple2 = line_tuple2;
    };

    EventPQ.prototype.delMin = function() {
      return this.PQ.dequeue();
    };

    EventPQ.prototype.isEmpty = function() {
      return this.PQ.isEmpty();
    };

    EventPQ.prototype.size = function() {
      return this.PQ.size();
    };

    return EventPQ;

  })();

  SCRIB.Event_Comparator = function(e1, e2) {
    if (e1.tuple1 === e2.tuple1 && e1.type === e2.type) {
      return true;
    }
    if (e1.tuple1 === e2.tuple1) {
      return e1.type === SCRIB.Event.ENTER;
    }
    if (e1.x < e2.x) {
      return true;
    }
    if (e2.x < e1.x) {
      return false;
    }
    if (e1.y < e2.y) {
      return true;
    }
    if (e2.y > e1.y) {
      return false;
    }
    if ((e1.type === SCRIB.Event.EXIT) && (e2.type === SCRIB.Event.ENTER)) {
      return true;
    }
    if ((e1.type === SCRIB.Event.ENTER) && (e2.type === SCRIB.Event.EXIT)) {
      return false;
    }
    if (e1.tuple1.id <= e2.tuple1.id) {
      return true;
    }
    return false;
  };

  SCRIB.LineTuple_Comparator = function(e1, e2) {
    if (e1 === e2) {
      return true;
    }
    if (e1.x < e2.x) {
      return true;
    }
    if (e1.x > e2.x) {
      return false;
    }
    if (e1.y < e2.y) {
      return true;
    }
    if (e1.y > e2.y) {
      return false;
    }
    return e1.id <= e2.id;
  };


  /*
  Line Tuples are stored in a binary search tree to
  represent the lines currently crossing the sweep line.
   */

  SCRIB.LineTuple = (function() {
    function LineTuple() {
      this.line = null;
      this.x = null;
      this.y = null;
      this.id = null;
    }

    return LineTuple;

  })();

  SCRIB.LineTupleSet = (function() {
    function LineTupleSet() {
      this.heap = new BDS.Heap([], SCRIB.LineTuple_Comparator);
    }

    LineTupleSet.prototype.addTuple = function(line_tuple, id) {
      var i, input_line, j, len, line_crossing_sweep, ref, tuple;
      line_tuple.id = id;
      input_line = line_tuple.line;
      len = this.heap.size();
      for (i = j = 0, ref = len; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
        tuple = this.heap.getElem(i);
        line_crossing_sweep = tuple.line;
        input_line.intersect(line_crossing_sweep);
      }
      return this.heap.add(line_tuple);
    };

    LineTupleSet.prototype.removeTuple = function(line_tuple) {
      var tuple;
      tuple = this.heap.dequeue();
      if (tuple !== line_tuple) {
        throw new Error("ERROR: line_tuple exit ordering is messed up!");
      }
      return tuple;
    };

    return LineTupleSet;

  })();

  SCRIB.Event = (function() {
    Event.ENTER = 0;

    Event.EXIT = 1;

    function Event() {
      this.tuple1 = null;
      this.tuple2 = null;
      this.type = null;
      this.x = null;
      this.y = null;
    }

    return Event;

  })();

}).call(this);

// Generated by CoffeeScript 1.11.1

/*
Line with associated intersection data.
Written by Bryce Summers on 1 - 2 - 2017.
 */

(function() {
  SCRIB.Line = (function() {
    function Line(start_point_index, end_point_index, point_array) {
      this.p1_index = start_point_index;
      this.p2_index = end_point_index;
      this.points = point_array;
      this.p1 = this.points[this.p1_index];
      this.p2 = this.points[this.p2_index];
      this.offset = this.p2.sub(this.p1);
      this.split_points_per = [];
      this.split_points_indices = [];
    }


    /*
    intersects the given other_line with this line.
    Adds a split point if they do intersect.
    Any created split points are added to the referenced global collection of points.
     * Line -> bool
     */

    Line.prototype.intersect = function(other) {
      if (this.p1_index === other.p1_index || this.p1_index === other.p2_index || this.p2_index === other.p1_index || this.p2_index === other.p2_index) {
        return false;
      }
      if (!this.detect_intersection(other)) {
        return false;
      }
      this._report_intersection(other);
      return true;
    };


    /*
    Returns a signed floating point number indicating which direction the given point is relative to this line.
     * Point -> float.
     */

    Line.prototype.line_side_test = function(c) {
      return (this.p2.x - this.p1.x) * (c.y - this.p1.y) - (this.p2.y - this.p1.y) * (c.x - this.p1.x);
    };


    /*
    Appends all of the split set of lines in order to the output vector.
    Adds itself if it does not contain any split lines.
    Line pts are oriented along the polyline, such that p1 comes before p2 in the polyline + intersection point ordering.
    Line[] -> void
     */

    Line.prototype.getSplitLines = function(lines_out) {
      var i, j, last_indice, len, next_indice, ref;
      len = this.split_points_per.length;
      if (len === 0) {
        lines_out.push(this);
        return;
      }
      this._sort_split_points();
      this.split_points_indices.push(this.p2_index);
      last_indice = this.split_points_indices[0];
      lines_out.push(new SCRIB.Line(this.p1_index, last_indice, this.points));
      for (i = j = 1, ref = len; 1 <= ref ? j < ref : j > ref; i = 1 <= ref ? ++j : --j) {
        next_indice = this.split_points_indices[i];
        lines_out.push(new SCRIB.Line(last_indice, next_indice, this.points));
        last_indice = next_indice;
      }
      lines_out.push(new SCRIB.Line(last_indice, this.p2_index, this.points));
    };


    /*
    This function should only be called after a call to intersect has returned true.
    Returns the last intersection point.
    this is only guranteed to be valid immediatly after the true return from the intersect function.
    void -> Point.
     */

    Line.prototype.getLatestIntersectionPoint = function() {
      return this.points[this.points.length - 1];
    };


    /*
    Internally sorts the split points from the start to the end of this line.
     */

    Line.prototype._sort_split_points = function() {
      var i, i1, i2, j, k, len, ref, ref1, temp_f, temp_i;
      len = this.split_points_per.length;
      for (i = j = 1, ref = len; 1 <= ref ? j < ref : j > ref; i = 1 <= ref ? ++j : --j) {
        for (i2 = k = ref1 = i - 1; ref1 <= 0 ? k <= 0 : k >= 0; i2 = ref1 <= 0 ? ++k : --k) {
          i1 = i2 + 1;
          if (this.split_points_per[i2] <= this.split_points_per[i1]) {
            break;
          }
          temp_f = this.split_points_per[i2];
          this.split_points_per[i2] = this.split_points_per[i1];
          this.split_points_per[i1] = temp_f;
          temp_i = this.split_points_indices[i2];
          this.split_points_indices[i2] = this.split_points_indices[i1];
          this.split_points_indices[i1] = temp_i;
        }
      }
    };


    /*
    Returns true iff this line segment intersects with the other line segment.
    Doesn't do any degeneracy checking.
    Line -> bool.
     */

    Line.prototype.detect_intersection = function(other) {
      var a1, a2, b1, b2;
      a1 = this.line_side_test(other.p1);
      a2 = this.line_side_test(other.p2);
      b1 = other.line_side_test(this.p1);
      b2 = other.line_side_test(this.p2);

      /*
      The product of two point based line side tests will be negative iff
      the points are not on strictly opposite sides of the line.
      If the product is 0, then at least one of the points is on the line not containing the points.
       */
      return a1 * a2 <= 0 && b1 * b2 <= 0;
    };


    /*
    Line -> void.
     */

    Line.prototype._report_intersection = function(other) {

      /*
      u = ((bs.y - as.y) * bd.x - (bs.x - as.x) * bd.y) / (bd.x * ad.y - bd.y * ad.x)
      v = ((bs.y - as.y) * ad.x - (bs.x - as.x) * ad.y) / (bd.x * ad.y - bd.y * ad.x)
      Factoring out the common terms, this comes to:
      
      dx = bs.x - as.x
      dy = bs.y - as.y
      det = bd.x * ad.y - bd.y * ad.x
      u = (dy * bd.x - dx * bd.y) / det
      v = (dy * ad.x - dx * ad.y) / det
       */
      var ad, as, bd, bs, det, dx, dy, index, intersection_point, u, v;
      as = this.p1;
      bs = other.p1;
      ad = this.offset;
      bd = other.offset;
      dx = bs.x - as.x;
      dy = bs.y - as.y;
      det = bd.x * ad.y - bd.y * ad.x;
      u = (dy * bd.x - dx * bd.y) / det;
      v = (dy * ad.x - dx * ad.y) / det;
      this.split_points_per.push(u);
      other.split_points_per.push(v);
      intersection_point = as.add(ad.multScalar(u));
      index = this.points.length;
      this.points.push(intersection_point);
      this.split_points_indices.push(index);
      return other.split_points_indices.push(index);
    };

    Line.prototype.clearIntersections = function() {
      this.split_points_per = [];
      return this.split_points_indices = [];
    };

    return Line;

  })();

}).call(this);

// Generated by CoffeeScript 1.11.1

/*
Point.

Written by Bryce Summers on 1 - 2 - 2017.

Implements Arithmetic.

add, sub, multScalar
 */

(function() {
  SCRIB.Point = (function() {
    function Point(x, y, z) {
      this.x = x;
      this.y = y;
      this.z = z;
      if (!this.z) {
        this.z = 0.0;
      }
    }

    Point.prototype.clone = function() {
      return new SCRIB.Point(this.x, this.y, this.z);
    };

    Point.prototype.add = function(pt) {
      var out;
      out = this.clone();
      out.x += pt.x;
      out.y += pt.y;
      out.z += pt.z;
      return out;
    };

    Point.prototype.sub = function(pt) {
      var out;
      out = this.clone();
      out.x -= pt.x;
      out.y -= pt.y;
      out.z -= pt.z;
      return out;
    };

    Point.prototype.multScalar = function(s) {
      var out;
      out = this.clone();
      out.x *= s;
      out.y *= s;
      out.z *= s;
      return out;
    };

    Point.prototype.toString = function() {
      var output;
      output = "Point(" + this.x + ", " + this.y;
      if (this.z) {
        output += ", " + this.z;
      }
      output += ")";
      return output;
    };

    Point.prototype.magnitude = function() {
      return this.norm();
    };

    Point.prototype.norm = function() {
      return Math.sqrt(this.norm2());
    };

    Point.prototype.norm2 = function() {
      return this.x * this.x + this.y * this.y + this.z * this.z;
    };

    return Point;

  })();

}).call(this);
