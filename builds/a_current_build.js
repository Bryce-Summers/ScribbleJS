/*! Scribble JS, a project by Bryce Summers.
 *  Single File concatenated by Grunt Concatenate on 09-01-2017
 */
/*! Bryce Data Structures, a project by Bryce Summers.
 *  Single File concatenated by Grunt Concatenate on 09-01-2017
 */
/*
 * Defines namespaces.
 * Adapted by Bryce Summers on 1 - 2 - 2017.
 */

// Bryce Data Structures.
BDS = {};
// Generated by CoffeeScript 1.11.1

/*
Standard Array methods.
 */

(function() {
  BDS.Arrays = {};

  BDS.Arrays.swap = function(array, i1, i2) {
    var temp;
    temp = array[i1];
    array[i1] = array[i2];
    array[i2] = temp;
  };

  BDS.Arrays.binarySearch = function(array, elem_target, comparator) {
    var elem_current, max, mid, min;
    min = 0;
    max = array.length - 1;
    mid = Math.floor(max / 2);
    while (min <= max) {
      elem_current = array[mid];
      if (comparator(elem_current, elem_target)) {
        min = mid + 1;
      } else {
        max = mid - 1;
      }
      mid = Math.floor((min + max) / 2);
    }
    return min - 1;
  };

}).call(this);

// Generated by CoffeeScript 1.11.1

/*

Intersector

Written by Bryce Summers on 1 - 2 - 2017.

features: Efficient Line Segment Intersection.
 */

(function() {
  BDS.Intersector = (function() {
    function Intersector() {}


    /*
    Calls the Line.intersect method on all intersecting lines.
    Does not treat lines that intersect at common points as intersecting.
     * takes arrays of BDS.Line objects.
    BDS.Line[] -> () [intersection sideeffects]
     */

    Intersector.prototype.intersectLineSegments = function(lines) {
      var event, event_queue, i, j, len, line, ref, sweepSet;
      event_queue = new BDS.Intersector.EventPQ(lines);
      sweepSet = new BDS.Intersector.LineSweepSet();
      len = event_queue.size();
      for (i = j = 0, ref = len; j < ref; i = j += 1) {
        event = event_queue.delMin();
        switch (event.type) {
          case BDS.Intersector.Event.ENTER:
            line = event.line;
            sweepSet.intersect_with_line(line);
            sweepSet.add(event.twin);
            continue;
          case BDS.Intersector.Event.EXIT:
            sweepSet.remove(event);
            continue;
        }
      }
    };


    /*
    Returns true iff there is at least one valid intersection detected in the input set of polylines.
    Does not treat lines that intersect at common points as intersecting.
    
    non_intersection_indices demarcate ranges of indices that should not be intersected against each other.
    Assumes that the indices are in rted order.
     */

    Intersector.prototype.detect_intersection_line_segments_partitioned = function(lines, partition_indices) {
      var event, event_queue, i, j, len, line, ref, sweepSet;
      event_queue = new BDS.Intersector.EventPQ(lines);
      sweepSet = new BDS.Intersector.LineSweepSet();
      len = event_queue.size();
      for (i = j = 0, ref = len; j < ref; i = j += 1) {
        event = event_queue.delMin();
        switch (event.type) {
          case BDS.Intersector.Event.ENTER:
            line = event.line;
            if (sweepSet.detect_intersection_with_line_partitioned(line, partition_indices)) {
              return true;
            }
            sweepSet.add(event.twin);
            continue;
          case BDS.Intersector.Event.EXIT:
            sweepSet.remove(event);
            continue;
        }
      }
      return false;
    };


    /*
    Slower, but more robust version of intersect.
    Naive N^2 Intersection Algorithm.
     */

    Intersector.prototype.intersect_brute_force = function(lines) {
      var a, b, j, numLines, ref, results;
      numLines = lines.length;
      results = [];
      for (a = j = 0, ref = numLines; 0 <= ref ? j < ref : j > ref; a = 0 <= ref ? ++j : --j) {
        results.push((function() {
          var k, ref1, ref2, results1;
          results1 = [];
          for (b = k = ref1 = a + 1, ref2 = numLines; ref1 <= ref2 ? k < ref2 : k > ref2; b = ref1 <= ref2 ? ++k : --k) {
            results1.push(lines[a].intersect(lines[b]));
          }
          return results1;
        })());
      }
      return results;
    };

    return Intersector;

  })();


  /*
  Event Priority Queue methods.
   */

  BDS.Intersector.EventPQ = (function() {
    function EventPQ(lines) {
      var enter, events, exit, i, j, len, line, p1, p2, ref;
      events = [];
      len = lines.length;
      for (i = j = 0, ref = len; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
        line = lines[i];
        enter = new BDS.Intersector.Event();
        exit = new BDS.Intersector.Event();
        p1 = line.p1;
        p2 = line.p2;
        if (p1.x < p2.x || (p1.x === p2.x && p1.y < p2.y)) {
          this._populateEvent(enter, exit, p1, p2, line, i);
        } else {
          this._populateEvent(enter, exit, p2, p1, line, i);
        }
        events.push(enter);
        events.push(exit);
      }
      this.PQ = new BDS.Heap(events, BDS.Intersector.Event_Comparator);
    }

    EventPQ.prototype._populateEvent = function(enter, exit, p1, p2, line, id) {
      enter.type = BDS.Intersector.Event.ENTER;
      exit.type = BDS.Intersector.Event.EXIT;
      enter.x = p1.x;
      enter.y = p1.y;
      exit.x = p2.x;
      exit.y = p2.y;
      enter.line = line;
      exit.line = line;
      enter.id = id;
      exit.id = id;
      enter.twin = exit;
      return exit.twin = enter;
    };

    EventPQ.prototype.delMin = function() {
      return this.PQ.dequeue();
    };

    EventPQ.prototype.isEmpty = function() {
      return this.PQ.isEmpty();
    };

    EventPQ.prototype.size = function() {
      return this.PQ.size();
    };

    return EventPQ;

  })();

  BDS.Intersector.Event_Comparator = function(e1, e2) {
    if (e1.line === e2.line && e1.type === e2.type) {
      return true;
    }
    if (e1.line === e2.line) {
      return e1.type === BDS.Intersector.Event.ENTER;
    }
    if (e1.x < e2.x) {
      return true;
    }
    if (e1.x > e2.x) {
      return false;
    }
    if (e1.y < e2.y) {
      return true;
    }
    if (e1.y > e2.y) {
      return false;
    }
    if ((e1.type === BDS.Intersector.Event.EXIT) && (e2.type === BDS.Intersector.Event.ENTER)) {
      return true;
    }
    if ((e1.type === BDS.Intersector.Event.ENTER) && (e2.type === BDS.Intersector.Event.EXIT)) {
      return false;
    }
    if (e1.id <= e2.id) {
      return true;
    }
    return false;
  };

  BDS.Intersector.LineSweepSet = (function() {
    function LineSweepSet() {
      this.heap = new BDS.Heap([], BDS.Intersector.Event_Comparator);
    }

    LineSweepSet.prototype.add = function(event) {
      return this.heap.add(event);
    };

    LineSweepSet.prototype.remove = function(event_to_be_removed) {
      var err, my_event;
      my_event = this.heap.dequeue();
      if (my_event !== event_to_be_removed) {
        err = new Error("ERROR: line_tuple exit ordering is messed up!");
        console.log(err.stack);
        debugger;
        throw new err;
      }
      return my_event;
    };

    LineSweepSet.prototype.intersect_with_line = function(input_line) {
      var event, i, j, len, line_crossing_sweep, ref, results;
      len = this.heap.size();
      results = [];
      for (i = j = 0, ref = len; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
        event = this.heap.getElem(i);
        line_crossing_sweep = event.line;
        results.push(input_line.intersect(line_crossing_sweep));
      }
      return results;
    };

    LineSweepSet.prototype.detect_intersection_with_line_partitioned = function(input_line) {
      var event, i, j, len, line_crossing_sweep, ref;
      len = this.heap.size();
      for (i = j = 0, ref = len; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
        event = this.heap.getElem(i);
        line_crossing_sweep = event.line;
        if (line_crossing_sweep.points === input_line.points) {
          continue;
        }
        if (input_line.detect_intersection(line_crossing_sweep)) {
          return true;
        }
      }
      return false;
    };

    LineSweepSet.prototype.detect_intersection_with_line = function(input_line) {
      var event, i, j, len, line_crossing_sweep, ref;
      len = this.heap.size();
      for (i = j = 0, ref = len; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
        event = this.heap.getElem(i);
        line_crossing_sweep = event.line;
        if (input_line.detect_intersection(line_crossing_sweep)) {
          return true;
        }
      }
      return false;
    };

    return LineSweepSet;

  })();

  BDS.Intersector.Event = (function() {
    Event.ENTER = 0;

    Event.EXIT = 1;

    function Event() {
      this.type = null;
      this.x = null;
      this.y = null;
      this.id = null;
      this.twin = null;
    }

    return Event;

  })();

}).call(this);

// Generated by CoffeeScript 1.11.1

/*
Line with associated intersection data.
Written by Bryce Summers on 1 - 2 - 2017.

This class is designed for intersection techniques and line segment splitting,
rather than for simply representing a line segment.
Please use Polylines for the geometric representation and drawing of lines.
 */

(function() {
  BDS.Line = (function() {
    function Line(start_point_index, end_point_index, point_array) {
      this.p1_index = start_point_index;
      this.p2_index = end_point_index;
      this.points = point_array;
      this.p1 = this.points[this.p1_index];
      this.p2 = this.points[this.p2_index];
      this.offset = this.p2.sub(this.p1);
      this.split_points_per = [];
      this.split_points_indices = [];
    }


    /*
    intersects the given other_line with this line.
    Adds a split point if they do intersect.
    Any created split points are added to the referenced global collection of points.
     * Line -> bool
     */

    Line.prototype.intersect = function(other) {
      if (this.p1_index === other.p1_index || this.p1_index === other.p2_index || this.p2_index === other.p1_index || this.p2_index === other.p2_index) {
        return false;
      }
      if (!this.detect_intersection(other)) {
        return false;
      }
      this._report_intersection(other);
      return true;
    };


    /*
    Returns a signed floating point number indicating which direction the given point is relative to this line.
     * Point -> float.
     */

    Line.prototype.line_side_test = function(c) {
      return (this.p2.x - this.p1.x) * (c.y - this.p1.y) - (this.p2.y - this.p1.y) * (c.x - this.p1.x);
    };


    /*
    Appends all of the split set of lines in order to the output vector.
    Adds itself if it does not contain any split lines.
    Line pts are oriented along the polyline, such that p1 comes before p2 in the polyline + intersection point ordering.
    Line[] -> void
     */

    Line.prototype.getSplitLines = function(lines_out) {
      var i, j, last_indice, len, next_indice, ref;
      len = this.split_points_per.length;
      if (len === 0) {
        lines_out.push(this);
        return;
      }
      this._sort_split_points();
      this.split_points_indices.push(this.p2_index);
      last_indice = this.split_points_indices[0];
      lines_out.push(new BDS.Line(this.p1_index, last_indice, this.points));
      for (i = j = 1, ref = len; 1 <= ref ? j < ref : j > ref; i = 1 <= ref ? ++j : --j) {
        next_indice = this.split_points_indices[i];
        lines_out.push(new BDS.Line(last_indice, next_indice, this.points));
        last_indice = next_indice;
      }
      lines_out.push(new BDS.Line(last_indice, this.p2_index, this.points));
    };


    /*
    This function should only be called after a call to intersect has returned true.
    Returns the last intersection point.
    this is only guranteed to be valid immediatly after the true return from the intersect function.
    void -> Point.
     */

    Line.prototype.getLatestIntersectionPoint = function() {
      return this.points[this.points.length - 1];
    };


    /*
    Internally sorts the split points from the start to the end of this line.
     */

    Line.prototype._sort_split_points = function() {
      var i, i1, i2, j, k, len, ref, ref1, temp_f, temp_i;
      len = this.split_points_per.length;
      for (i = j = 1, ref = len; 1 <= ref ? j < ref : j > ref; i = 1 <= ref ? ++j : --j) {
        for (i2 = k = ref1 = i - 1; ref1 <= 0 ? k <= 0 : k >= 0; i2 = ref1 <= 0 ? ++k : --k) {
          i1 = i2 + 1;
          if (this.split_points_per[i2] <= this.split_points_per[i1]) {
            break;
          }
          temp_f = this.split_points_per[i2];
          this.split_points_per[i2] = this.split_points_per[i1];
          this.split_points_per[i1] = temp_f;
          temp_i = this.split_points_indices[i2];
          this.split_points_indices[i2] = this.split_points_indices[i1];
          this.split_points_indices[i1] = temp_i;
        }
      }
    };


    /*
    Returns true iff this line segment intersects with the other line segment.
    Doesn't do any degeneracy checking.
    Line -> bool.
     */

    Line.prototype.detect_intersection = function(other) {
      var a1, a2, a_opposites, b1, b2, b_opposites;
      a1 = this.line_side_test(other.p1);
      a2 = this.line_side_test(other.p2);
      b1 = other.line_side_test(this.p1);
      b2 = other.line_side_test(this.p2);

      /*
      The product of two point based line side tests will be negative iff
      the points are not on strictly opposite sides of the line.
      If the product is 0, then at least one of the points is on the line not containing the points.
       */

      /*
      epsilon = .001
      a_on = (Math.abs(a1) < epsilon or Math.abs(a2) < epsilon)
      b_on = (Math.abs(b1) < epsilon or Math.abs(b2) < epsilon)
       */
      a_opposites = a1 * a2 <= 0;
      b_opposites = b1 * b2 <= 0;
      if (a_opposites && b_opposites) {
        return true;
      }

      /*
                     (a_opposites and b_on) or
                     (a_on and b_opposites)
       */
    };


    /*
    Line -> void.
     */

    Line.prototype._report_intersection = function(other) {

      /*
      u = ((bs.y - as.y) * bd.x - (bs.x - as.x) * bd.y) / (bd.x * ad.y - bd.y * ad.x)
      v = ((bs.y - as.y) * ad.x - (bs.x - as.x) * ad.y) / (bd.x * ad.y - bd.y * ad.x)
      Factoring out the common terms, this comes to:
      
      dx = bs.x - as.x
      dy = bs.y - as.y
      det = bd.x * ad.y - bd.y * ad.x
      u = (dy * bd.x - dx * bd.y) / det
      v = (dy * ad.x - dx * ad.y) / det
       */
      var ad, as, bd, bs, det, dx, dy, index, intersection_point, u, v;
      as = this.p1;
      bs = other.p1;
      ad = this.offset;
      bd = other.offset;
      dx = bs.x - as.x;
      dy = bs.y - as.y;
      det = bd.x * ad.y - bd.y * ad.x;
      u = (dy * bd.x - dx * bd.y) / det;
      v = (dy * ad.x - dx * ad.y) / det;
      this.split_points_per.push(u);
      other.split_points_per.push(v);
      intersection_point = as.add(ad.multScalar(u));
      index = this.points.length;
      this.points.push(intersection_point);
      this.split_points_indices.push(index);
      return other.split_points_indices.push(index);
    };

    Line.prototype.clearIntersections = function() {
      this.split_points_per = [];
      return this.split_points_indices = [];
    };

    Line.prototype.getNormal = function(pt) {
      var dir, normal, temp;
      normal = this.offset.normalize();
      temp = normal.x;
      normal.x = -normal.y;
      normal.y = temp;
      dir = pt.sub(this.p1);
      if (normal.dot(dir) < 0) {
        return normal.multScalar(-1);
      }
      return normal;
    };

    return Line;

  })();

}).call(this);

// Generated by CoffeeScript 1.11.1

/*
Box.

Written by Bryce Summers on 1 - 5 - 2017
 */

(function() {
  BDS.Box = (function() {
    function Box(min, max, _isFilled) {
      this.min = min;
      this.max = max;
      this._isFilled = _isFilled;
      if (!this.min) {
        this.min = new BDS.Point(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);
      }
      if (!this.max) {
        this.max = new BDS.Point(Number.MIN_VALUE, Number.MIN_VALUE, Number.MIN_VALUE);
      }
      if (!this._isFilled) {
        this._isFilled = true;
      }
    }

    Box.prototype.clone = function() {
      return new BDS.Box(this.min.clone(), this.max.clone());
    };

    Box.prototype.isFilled = function() {
      return this._isFilled;
    };

    Box.prototype.expandByPoint = function(p) {
      this.min = this.min.min(p);
      return this.max = this.max.max(p);
    };

    Box.prototype.union = function(box) {
      var out;
      out = this.clone();
      out.min = this.min.min(box.min);
      out.max = this.max.max(box.max);
      return out;
    };

    Box.prototype.intersect = function(box) {
      var out;
      out = this.clone();
      out.min = this.min.max(box.min);
      out.max = this.max.min(box.max);
      return out;
    };

    Box.prototype.containsPoint = function(pt) {
      return pt.greaterThanOrEqual(this.min) && pt.lessThanOrEqual(this.max);
    };

    Box.prototype.getRandomPointInBox = function() {
      var range, x, y, z;
      range = this.max.sub(this.min);
      x = this.min.x + Math.random() * range.x;
      y = this.min.y + Math.random() * range.y;
      z = this.min.z + Math.random() * range.z;
      return new BDS.Point(x, y, z);
    };

    Box.prototype.area = function() {
      var area, diff;
      diff = this.max.sub(this.min);
      area = Math.abs(diff.x * diff.y);
      if (diff.x < 0 || diff.y < 0) {
        area = -area;
      }
      return area;
    };

    Box.prototype.intersects_box = function(box) {
      var intersection;
      intersection = this.intersect(box);
      return intersection.area() > 0;
    };

    Box.prototype.toPolyline = function() {
      var p0, p1, p2, p3, points, polyline;
      p0 = this.min.clone();
      p1 = this.min.clone();
      p1.x = this.max.x;
      p2 = this.max.clone();
      p3 = this.min.clone();
      p3.y = this.max.y;
      points = [p0, p1, p2, p3];
      polyline = new BDS.Polyline(true, points, this._isFilled);
      return polyline;
    };

    return Box;

  })();

}).call(this);

// Generated by CoffeeScript 1.11.1

/*

Circle Class
Written by Bryce Summers on 1 - 6 - 2017.
 */

(function() {
  BDS.Circle = (function() {
    function Circle(_center, _radius, filled) {
      this._center = _center;
      this._radius = _radius;
      this.filled = filled;
      if (this.filled === void 0) {
        this.filled = false;
      }

      /*
      @_boundingbox, stored the bounding box.
       */
    }

    Circle.prototype.isFilled = function() {
      return this.filled;
    };

    Circle.prototype.setPosition = function(x, y) {
      this._center.x = x;
      return this._center.y = y;
    };

    Circle.prototype.getPosition = function() {
      return this._center.clone();
    };

    Circle.prototype.getRadius = function() {
      return this._radius;
    };

    Circle.prototype.minnimum_time_of_intersection_with_ray = function(ray) {
      var det, det_sqr, l, loc, o, o_sub_c, o_sub_c_sqr, time1, time2;
      o = ray.getPoint();
      l = ray.getDirection();
      o_sub_c = o.sub(this._center);
      o_sub_c_sqr = o_sub_c.dot(o_sub_c);
      if (this.filled && Math.sqrt(o_sub_c_sqr) < this._radius) {
        return 0;
      }
      loc = o_sub_c.dot(l);
      det_sqr = loc * loc - o_sub_c_sqr + this._radius * this._radius;
      if (det_sqr < 0) {
        return null;
      }
      det = Math.sqrt(det_sqr);
      time1 = -loc + det;
      time2 = -loc - det;
      if (time2 > 0) {
        return time2;
      }
      if (time1 > 0) {
        return time1;
      }
      return null;
    };

    Circle.prototype.detect_intersection_with_polyline = function(polyline) {
      var i, intersection_time, len, pt, ray, rays;
      if (polyline.size < 1) {
        return false;
      }
      if (this.filled) {
        pt = polyline.getPoint(0);
        if (this.containsPoint(pt)) {
          return true;
        }
      }
      if (polyline.isFilled()) {
        if (polyline.containsPoint(this._center)) {
          return true;
        }
      }
      rays = polyline.toRays();
      for (i = 0, len = rays.length; i < len; i++) {
        ray = rays[i];
        intersection_time = this.minnimum_time_of_intersection_with_ray(ray);
        if (intersection_time !== null && intersection_time < ray.getTimeScale()) {
          return true;
        }
        continue;
      }
      return false;
    };

    Circle.prototype.containsPoint = function(pt) {
      var diff, dist;
      diff = pt.sub(this._center);
      dist = diff.norm();
      return dist < this._radius;
    };

    Circle.prototype.generateBoundingBox = function() {
      var max, min;
      this._boundingbox = new BDS.Box();
      min = this._center.clone();
      min.x -= this._radius;
      min.y -= this._radius;
      max = this._center.clone();
      max.x += this._radius;
      max.y += this._radius;
      this._boundingbox.expandByPoint(min);
      this._boundingbox.expandByPoint(max);
      return this._boundingbox;
    };

    Circle.prototype.getBoundingBox = function() {
      return this._boundingbox;
    };

    return Circle;

  })();

}).call(this);

// Generated by CoffeeScript 1.11.1
(function() {
  BDS.S_Curve = (function() {
    function S_Curve() {
      this._spline = new THREE.CatmullRomCurve3();
      this._point_discretization = [];
    }

    S_Curve.prototype.addPoint = function(p) {
      return this._spline.points.push(p);
    };

    S_Curve.prototype.numPoints = function(p) {
      return this._spline.points.length;
    };

    S_Curve.prototype.getPointAtIndex = function(i) {
      return this._spline.points[i];
    };

    S_Curve.prototype.getLastPoint = function() {
      return this.getPointAtIndex(this.numPoints() - 1);
    };

    S_Curve.prototype.removeLastPoint = function() {
      return this._spline.points.pop();
    };

    S_Curve.prototype.position = function(t) {
      return this._spline.getPoint(t);
    };

    S_Curve.prototype.tangent = function(t) {
      return this._spline.getTangent(t);
    };

    S_Curve.prototype.offset = function(t, amount) {
      var tan, x, y;
      tan = this.tangent(t);
      tan.setLength(amount);
      x = tan.x;
      y = tan.y;
      tan.x = y;
      tan.y = -x;
      return this.position(t).add(tan);
    };

    S_Curve.prototype.getDiscretization = function(max_length) {
      return this._discretization;
    };

    S_Curve.prototype.updateDiscretization = function(max_length) {
      var S, high, low, output, p0, p_high, p_low;
      output = [];
      p0 = this._spline.getPoint(0);
      output.push(p0);
      S = [];
      S.push(1.0);
      low = 0;
      p_low = this._spline.getPoint(low);
      while (S.length !== 0) {
        high = S.pop();
        p_high = this._spline.getPoint(high);
        while (p_low.distanceTo(p_high) > max_length) {
          S.push(high);
          high = (low + high) / 2.0;
          p_high = this._spline.getPoint(high);
        }
        output.push(p_high);
        low = high;
        p_low = p_high;
        continue;
      }
      return this._discretization = output;
    };

    S_Curve.prototype.getOffsets = function(max_length, amount, times_output) {
      var S, high, low, o0, output, p_high, p_low;
      o0 = this.offset(0, amount);
      output = [];
      output.push(o0);
      if (times_output) {
        times_output.push(0);
      }
      S = [];
      S.push(1.0);
      low = 0;
      p_low = this.offset(low, amount);
      while (S.length !== 0) {
        high = S.pop();
        p_high = this.offset(high, amount);
        while (p_low.distanceTo(p_high) > max_length) {
          S.push(high);
          high = (low + high) / 2.0;
          p_high = this.offset(high, amount);
        }
        output.push(p_high);
        if (times_output) {
          times_output.push(high);
        }
        low = high;
        p_low = p_high;
        continue;
      }
      return output;
    };

    return S_Curve;

  })();

}).call(this);

// Generated by CoffeeScript 1.11.1

/*
Geometry Super Class
Written by Bryce Summers on 1 - 9 - 2017.

This class abstract away many common procedures and specifies a common interface for algorithms on geometries.
 */

(function() {
  BDS.Geometry = (function() {
    function Geometry(closed, filled) {
      this.closed = closed;
      this.filled = filled;
    }

    Geometry.prototype.generateBoundingBox = function() {};

    Geometry.prototype.containsPoint = function(pt) {};

    Geometry.prototype.detect_intersection_with_polyline = function(polyline) {
      throw new Error("Please Override Me!");
    };

    return Geometry;

  })();

}).call(this);

// Generated by CoffeeScript 1.11.1

/*
Point.

Written by Bryce Summers on 1 - 2 - 2017.

Implements Arithmetic.

add, sub, multScalar
 */

(function() {
  BDS.newDirection = function(x, y, z) {
    return new BDS.Point(x, y, z);
  };

  BDS.Point = (function() {
    function Point(x1, y1, z1) {
      this.x = x1;
      this.y = y1;
      this.z = z1;
      if (!this.z) {
        this.z = 0.0;
      }
    }

    Point.prototype.clone = function() {
      return new BDS.Point(this.x, this.y, this.z);
    };

    Point.prototype.add = function(pt) {
      var out;
      out = this.clone();
      out.x += pt.x;
      out.y += pt.y;
      out.z += pt.z;
      return out;
    };

    Point.prototype.sub = function(pt) {
      var out;
      out = this.clone();
      out.x -= pt.x;
      out.y -= pt.y;
      out.z -= pt.z;
      return out;
    };

    Point.prototype.multScalar = function(s) {
      var out;
      out = this.clone();
      out.x *= s;
      out.y *= s;
      out.z *= s;
      return out;
    };

    Point.prototype.divScalar = function(s) {
      var out;
      out = this.clone();
      out.x /= s;
      out.y /= s;
      out.z /= s;
      return out;
    };

    Point.prototype.toString = function() {
      var output;
      output = "Point(" + this.x + ", " + this.y;
      if (this.z) {
        output += ", " + this.z;
      }
      output += ")";
      return output;
    };

    Point.prototype.magnitude = function() {
      return this.norm();
    };

    Point.prototype.norm = function() {
      return Math.sqrt(this.norm2());
    };

    Point.prototype.norm2 = function() {
      return this.x * this.x + this.y * this.y + this.z * this.z;
    };

    Point.prototype.min = function(pt) {
      var out;
      out = this.clone();
      out.x = Math.min(this.x, pt.x);
      out.y = Math.min(this.y, pt.y);
      out.z = Math.min(this.z, pt.z);
      return out;
    };

    Point.prototype.max = function(pt) {
      var out;
      out = this.clone();
      out.x = Math.max(this.x, pt.x);
      out.y = Math.max(this.y, pt.y);
      out.z = Math.max(this.z, pt.z);
      return out;
    };

    Point.prototype.normalize = function() {
      return this.divScalar(this.norm());
    };

    Point.prototype.dot = function(pt) {
      return pt.x * this.x + pt.y * this.y + pt.z * this.z;
    };

    Point.prototype.lessThan = function(pt) {
      return this.x < pt.x && this.y < pt.y && this.z < pt.z;
    };

    Point.prototype.lessThanOrEqual = function(pt) {
      return this.x <= pt.x && this.y <= pt.y && this.z <= pt.z;
    };

    Point.prototype.greaterThan = function(pt) {
      return this.x > pt.x && this.y > pt.y && this.z > pt.z;
    };

    Point.prototype.greaterThanOrEqual = function(pt) {
      return this.x >= pt.x && this.y >= pt.y && this.z >= pt.z;
    };

    return Point;

  })();

}).call(this);

// Generated by CoffeeScript 1.11.1

/*
Polyline class (also represents polygons)

Written by Bryce Summers on 1 - 4 - 2017.

Note: Closed Polylines are polygons...
 - So we will put all of our polygon code into this class.

Note: this class assumes that it contains at least 1 point for collision tests.

Note: Polyline <--> polyline intersection tests assume that the polyline is not self intersecting.

FIXME: Return proper point in polyline tests for complemented filled polylines.
 */

(function() {
  BDS.Polyline = (function() {
    function Polyline(_isClosed, points_in, _isFilled) {
      this._isClosed = _isClosed;
      this._isFilled = _isFilled;
      if (this._isClosed === void 0) {
        this._isClosed = false;
      }
      if (this._isFilled === void 0) {
        this._isFilled = this._isClosed;
      }
      this._points = [];
      if (points_in) {
        this.appendPoints(points_in);
      }

      /*
       * These are commented out to save memory for applications that don't need these.
      @_boundingbox = null
      @_lineBVH = null
      @_obj # Associated Obj.
       */
    }

    Polyline.prototype.appendPoints = function(array) {
      var j, len1, p;
      for (j = 0, len1 = array.length; j < len1; j++) {
        p = array[j];
        this.addPoint(p);
      }
    };

    Polyline.prototype.addPoint = function(p) {
      this._points.push(p);
      if (this._boundingbox) {
        this._boundingbox.expandByPoint(p);
      }
    };

    Polyline.prototype.removeLastPoint = function() {
      return this._points.pop();
    };

    Polyline.prototype.getPoint = function(index) {
      return this._points[index];
    };

    Polyline.prototype.size = function() {
      return this._points.length;
    };

    Polyline.prototype.isClosed = function() {
      return this._isClosed;
    };

    Polyline.prototype.isFilled = function() {
      return this._isFilled;
    };


    /*
    * http://math.blogoverflow.com/2014/06/04/greens-theorem-and-area-of-polygons/
    * Computes the area of a 2D polygon directly from the polygon's coordinates.
    * The area will be positive or negative depending on the
    * clockwise / counter clockwise orientation of the points.
    * Also see: https://brycesummers.wordpress.com/2015/08/24/a-proof-of-simple-polygonal-area-via-greens-theorem/
    * Note: This function interprets this polyline as closed.
     *  -> float
     */

    Polyline.prototype.computeArea = function() {
      var area, i, j, len, p1, p2, ref;
      len = this._points.length;
      p1 = this._points[len - 1];
      area = 0.0;
      for (i = j = 0, ref = len; j < ref; i = j += 1) {
        p2 = this._points[i];
        area += (p2.x + p1.x) * (p2.y - p1.y);
        p1 = p2;
      }
      return area / 2.0;
    };

    Polyline.prototype.isComplemented = function() {
      return this.computeArea() > 0;
    };

    Polyline.prototype.generateBoundingBox = function(polygon) {
      var j, len1, pt, ref;
      this._boundingbox = new BDS.Box();
      ref = this._points;
      for (j = 0, len1 = ref.length; j < len1; j++) {
        pt = ref[j];
        this._boundingbox.expandByPoint(pt);
      }
      return this._boundingbox;
    };

    Polyline.prototype.getBoundingBox = function() {
      return this._boundingbox;
    };

    Polyline.prototype.setAssociatedData = function(obj) {
      return this._obj = obj;
    };

    Polyline.prototype.getAssociatedData = function() {
      return this._obj;
    };


    /*
    getBVH: () ->
        return @_lineBVH()
     */

    Polyline.prototype.toPolylineSegments = function(output) {
      var i, j, len, p0, p1, ref;
      if (output === void 0) {
        output = [];
      }
      len = this._points.length;
      for (i = j = 0, ref = len - 1; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
        p0 = this._points[i];
        p1 = this._points[i + 1];
        output.push(new BDS.Polyline(false, [p0, p1]));
      }
      if (this._isClosed) {
        p0 = this._points[len - 1];
        p1 = this._points[0];
        output.push(new BDS.Polyline(false, [p0, p1]));
      }
      return output;
    };

    Polyline.prototype._toLineSegments = function() {
      var i, j, len, line, output, ref;
      output = [];
      len = this._points.length;
      for (i = j = 0, ref = len - 1; j < ref; i = j += 1) {
        line = new BDS.Line(i, i + 1, this._points);
        line.p1_index;
        line.p2_index;
        output.push(line);
      }
      if (this._isClosed) {
        line = new BDS.Line(len - 1, 0, this._points);
        line.p1_index;
        line.p2_index;
        output.push(line);
      }
      return output;
    };

    Polyline.prototype.toRays = function(output) {
      var dir, i, j, len, p0, p1, ref;
      if (output === void 0) {
        output = [];
      }
      len = this._points.length;
      for (i = j = 0, ref = len - 1; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
        p0 = this._points[i];
        p1 = this._points[i + 1];
        dir = p1.sub(p0);
        output.push(new BDS.Ray(p0, dir));
      }
      if (this._isClosed) {
        p0 = this._points[len - 1];
        p1 = this._points[0];
        dir = p1.sub(p0);
        output.push(new BDS.Ray(p0, dir));
      }
      return output;
    };

    Polyline.prototype.containsPoint = function(pt) {
      if (this._lineBVH) {
        throw new ERROR("Implement me Please!");
      } else {
        return this._point_in_polygon_test(pt);
      }
    };

    Polyline.prototype._point_in_polygon_test = function(pt) {
      var j, len1, odd, ray, segment, segments;
      ray = new BDS.Ray(pt, BDS.newDirection(1.0, 0));
      odd = false;
      segments = this._toLineSegments();
      for (j = 0, len1 = segments.length; j < len1; j++) {
        segment = segments[j];
        if (ray.detect_intersection_with_line(segment)) {
          odd = !odd;
        }
      }
      return odd;
    };

    Polyline.prototype.detect_intersection_with_box = function(box) {
      var polyline;
      if (this._boundingbox === void 0) {
        this.generateBoundingBox();
      }
      if (!box.intersects_box(this._boundingbox)) {
        return false;
      }
      if (this.isFilled() && this.containsPoint(box.min)) {
        return true;
      }
      if (box.isFilled() && box.containsPoint(this._points[0])) {
        return true;
      }
      polyline = box.toPolyline();
      return this.detect_intersection_with_polyline(polyline);
    };

    Polyline.prototype.detect_intersection_with_polyline = function(polyline) {
      var all_lines, intersector, lines1, lines2;
      lines1 = this._toLineSegments();
      lines2 = polyline._toLineSegments();
      all_lines = lines1.concat(lines2);
      intersector = new BDS.Intersector();
      return intersector.detect_intersection_line_segments_partitioned(all_lines);
    };

    return Polyline;

  })();

}).call(this);

// Generated by CoffeeScript 1.11.1

/*
Ray Class.

Written by Bryce Summers on 1 - 6 - 2017.

Purpose:
 */

(function() {
  BDS.Ray = (function() {
    function Ray(point, dir, _time_scale) {
      this.dir = dir;
      this._time_scale = _time_scale;
      if (this._time_scale === void 0) {
        this._time_scale = this.dir.norm();
        this.dir = this.dir.divScalar(this._time_scale);
      } else {
        this.dir = this.dir.normalize();
      }
      this.p1 = point;
      this.p2 = this.p1.add(this.dir);
    }

    Ray.prototype.getPoint = function() {
      return this.p1.clone();
    };

    Ray.prototype.getDirection = function() {
      return this.dir;
    };

    Ray.prototype.getTimeScale = function() {
      return this._time_scale;
    };

    Ray.prototype.detect_intersection_with_line = function(line) {
      var correct_direction, normal, side1, side2;
      side1 = this.line_side_test(line.p1);
      side2 = this.line_side_test(line.p2);
      normal = line.getNormal(this.p1);
      correct_direction = normal.dot(this.dir) < 0;
      return side1 * side2 <= 0 && correct_direction;
    };

    Ray.prototype.line_side_test = function(c) {
      return (this.p2.x - this.p1.x) * (c.y - this.p1.y) - (this.p2.y - this.p1.y) * (c.x - this.p1.x);
    };

    return Ray;

  })();

}).call(this);

// Generated by CoffeeScript 1.11.1
(function() {
  BDS.BVH2D = (function() {
    function BVH2D(polygons, xy) {
      var i, j, left_partition, ref, ref1, right_partition;
      if (!xy) {
        xy = {
          val: 'x'
        };
      }
      this._leaf_node = false;
      this._ensure_bounding_boxes(polygons);
      this._AABB = this._compute_AABB(polygons);
      if (polygons.length < 4) {
        this._leaf_node = true;
        this._leafs = [];
        for (i = j = 0, ref = polygons.length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
          this._leafs.push(polygons[i]);
        }
        return;
      }
      if (xy.dim === 2) {
        this._AABB.min.z = -1;
        this._AABB.max.z = +1;
      }
      polygons = this._sort_polygon_list(polygons, xy);
      ref1 = this._partition_by_SA(polygons), left_partition = ref1[0], right_partition = ref1[1];
      xy.val = this._nextXY(xy);
      this._left = new BDS.BVH2D(left_partition, xy);
      this._right = new BDS.BVH2D(right_partition, xy);
    }


    /*
     - Private Construction Methods. -----------------------
     */

    BVH2D.prototype._sort_polygon_list = function(polygon_list, xy) {
      var centroid_index_list, i, j, len, output, polygon_index, ref, sort_function;
      centroid_index_list = this._centroid_index_list(polygon_list);
      sort_function = function(a, b) {
        switch (xy.val) {
          case 'x':
            return a.centroid.x - b.centroid.x;
          case 'y':
            return a.centroid.y - b.centroid.y;
        }
        debugger;
        return console.log("xy is malformed.");
      };
      centroid_index_list.sort(sort_function);
      output = [];
      len = polygon_list.length;
      for (i = j = 0, ref = len; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
        polygon_index = centroid_index_list[i].index;
        output.push(polygon_list[polygon_index]);
      }
      return output;
    };

    BVH2D.prototype._nextXY = function(xy) {
      switch (xy.val) {
        case 'x':
          return 'y';
        case 'y':
          return 'x';
      }
      debugger;
      console.log("xy is malformed.");
      debugger;
      return console.log("Case not handled.");
    };

    BVH2D.prototype._centroid_index_list = function(polygon_list) {
      var centroid_index_node, i, j, len, output, ref;
      output = [];
      len = polygon_list.length;
      for (i = j = 0, ref = len; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
        centroid_index_node = {};
        centroid_index_node.index = i;
        centroid_index_node.centroid = this._computeCentroid(polygon_list[i]);
        output.push(centroid_index_node);
      }
      return output;
    };

    BVH2D.prototype._computeCentroid = function(polygon) {
      var centroid, i, j, len, point, ref;
      centroid = new BDS.Point(0, 0);
      len = polygon.size();
      for (i = j = 0, ref = len; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
        point = polygon.getPoint(i);
        centroid = centroid.add(point);
      }
      return centroid.divScalar(len);
    };

    BVH2D.prototype._partition_by_SA = function(polygon_list) {
      var i, i0, j, k, l, left, left_AABB, m, min_index, min_sah, ref, ref1, ref2, ref3, ref4, right, right_AABB, sah, sah_left, sah_right;
      min_sah = Number.MAX_VALUE;
      min_index = -1;
      left = [polygon_list[0]];
      right = [];
      i0 = polygon_list.length - 1;
      for (i = j = ref = i0; ref <= 1 ? j <= 1 : j >= 1; i = ref <= 1 ? ++j : --j) {
        right.push(polygon_list[i]);
      }
      for (i = k = 1, ref1 = i0; 1 <= ref1 ? k <= ref1 : k >= ref1; i = 1 <= ref1 ? ++k : --k) {
        left_AABB = this._compute_AABB(left);
        sah_left = this._compute_SA(left_AABB);
        right_AABB = this._compute_AABB(right);
        sah_right = this._compute_SA(right_AABB);
        sah = Math.max(sah_left, sah_right);
        if (sah < min_sah) {
          min_sah = sah;
          min_index = i;
        }
        left.push(right.pop());
      }
      left = [];
      right = [];
      for (i = l = 0, ref2 = min_index; 0 <= ref2 ? l < ref2 : l > ref2; i = 0 <= ref2 ? ++l : --l) {
        left.push(polygon_list[i]);
      }
      for (i = m = ref3 = min_index, ref4 = i0; ref3 <= ref4 ? m <= ref4 : m >= ref4; i = ref3 <= ref4 ? ++m : --m) {
        right.push(polygon_list[i]);
      }
      return [left, right];
    };

    BVH2D.prototype._ensure_bounding_boxes = function(polygon_list) {
      var j, len1, polygon, results;
      results = [];
      for (j = 0, len1 = polygon_list.length; j < len1; j++) {
        polygon = polygon_list[j];
        results.push(polygon.generateBoundingBox());
      }
      return results;
    };

    BVH2D.prototype._compute_AABB = function(polygon_list) {
      var AABB, i, j, output, polygon, ref;
      output = new BDS.Box();
      for (i = j = 0, ref = polygon_list.length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
        polygon = polygon_list[i];
        AABB = polygon.getBoundingBox();
        output = output.union(AABB);
      }
      return output;
    };

    BVH2D.prototype._compute_SA = function(AABB) {
      var dx, dy, dz, max, min, sxy, sxz, syz;
      min = AABB.min;
      max = AABB.max;
      dx = max.x - min.x;
      dy = max.y - min.y;
      dz = max.z - min.z;
      sxy = dx * dy;
      sxz = dx * dz;
      syz = dy * dz;
      return sxy + sxz + syz;
    };

    BVH2D.prototype.query_point = function(pt) {
      var j, len1, polygon, ref, result;
      if (this._leaf_node) {
        ref = this._leafs;
        for (j = 0, len1 = ref.length; j < len1; j++) {
          polygon = ref[j];
          if (polygon.isClosed() && polygon.containsPoint(pt)) {
            return polygon;
          }
        }
        return null;
      }
      if (this._AABB.containsPoint(pt)) {
        result = this._left.query_point(pt);
        if (result !== null) {
          return result;
        }
        result = this._right.query_point(pt);
        return result;
      }
      return null;
    };

    BVH2D.prototype.query_point_all = function(pt, output_list) {
      var j, len1, polygon, ref;
      if (output_list === void 0) {
        output_list = [];
      }
      if (this._leaf_node) {
        ref = this._leafs;
        for (j = 0, len1 = ref.length; j < len1; j++) {
          polygon = ref[j];
          if (polygon.isClosed() && polygon.containsPoint(pt)) {
            output_list.push(polygon);
          }
        }
        return output_list;
      }
      if (this._AABB.containsPoint(pt)) {
        this._left.query_point_all(pt, output_list);
        this._right.query_point_all(pt, output_list);
      }
      return output_list;
    };

    BVH2D.prototype.query_box_all = function(query_box, output_list) {
      var j, len1, polygon, ref;
      if (output_list === void 0) {
        output_list = [];
      }
      if (this._leaf_node) {
        ref = this._leafs;
        for (j = 0, len1 = ref.length; j < len1; j++) {
          polygon = ref[j];
          if (polygon.detect_intersection_with_box(query_box)) {
            output_list.push(polygon);
          }
          continue;
        }
        return output_list;
      }
      if (this._AABB.intersects_box(query_box)) {
        this._left.query_box_all(query_box, output_list);
        this._right.query_box_all(query_box, output_list);
      }
      return output_list;
    };

    BVH2D.prototype.toPolylines = function() {
      var polylines;
      polylines = [];
      this._toPolylines(polylines);
      return polylines;
    };

    BVH2D.prototype._toPolylines = function(output) {
      var max, max_x, max_y, min, min_x, min_y, p0, p1, p2, p3, polyline;
      min = this._AABB.min;
      max = this._AABB.max;
      min_x = min.x;
      min_y = min.y;
      max_x = max.x;
      max_y = max.y;
      p0 = new BDS.Point(min_x, min_y, 0);
      p1 = new BDS.Point(max_x, min_y, 0);
      p2 = new BDS.Point(max_x, max_y, 0);
      p3 = new BDS.Point(min_x, max_y, 0);
      polyline = new BDS.Polyline(true, [p0, p1, p2, p3]);
      output.push(polyline);
      if (!this._leaf_node) {
        this._left._toPolylines(output);
        this._right._toPolylines(output);
      }
    };

    return BVH2D;

  })();

}).call(this);

// Generated by CoffeeScript 1.11.1

/*
 * Double Linked List Class
 * Written as part of the Bryce Summers Javascript Data Structures Libary.
 * Written by Bryce Summers on 1/3/2017.
 */

(function() {
  BDS.DoubleLinkedList = (function() {
    function DoubleLinkedList() {
      this.clear();
    }

    DoubleLinkedList.prototype.clear = function() {
      this._size = 0;
      this._head = new BDS.DoubleListNode(null, null, null);
      this._tail = new BDS.DoubleListNode(null, null, null);
      this._head.next = this._tail;
      return this._tail.prev = this._head;
    };

    DoubleLinkedList.prototype.isEmpty = function() {
      return this._size === 0;
    };

    DoubleLinkedList.prototype.size = function() {
      return this._size;
    };

    DoubleLinkedList.prototype.push_back = function(elem) {
      this._tail.data = elem;
      this._tail.next = new BDS.DoubleListNode(null, this._tail, null);
      this._tail = this._tail.next;
      this._size++;
    };

    DoubleLinkedList.prototype.pop_back = function() {
      var output;
      this._tail = this._tail.prev;
      this._tail.next.prev = null;
      this._tail.next = null;
      output = this._tail.data;
      this._tail.data = null;
      this._size--;
      return output;
    };

    DoubleLinkedList.prototype.push_front = function(elem) {
      this._head.data = elem;
      this._head.prev = new BDS.DoubleListNode(null, null, this._head);
      this._head = this._head.next;
      this._size++;
    };

    DoubleLinkedList.prototype.pop_front = function(elem) {
      var output;
      this._head = this._head.next;
      this._head.prev.next = null;
      this._head.prev = null;
      output = this._head.data;
      this._head.data = null;
      this._size--;
      return output;
    };

    DoubleLinkedList.prototype.add = function(elem) {
      this.push_back(elem);
    };

    DoubleLinkedList.prototype.push = function(elem) {
      this.push_back(elem);
    };

    DoubleLinkedList.prototype.pop = function(elem) {
      return this.pop_back();
    };

    DoubleLinkedList.prototype._remove = function(node) {
      if (node === this._head || node === this._tail) {
        throw new Error("Error: Do not attempt to remove the ending iterators, only use them to stop iteration.");
      }
      node.next.prev = node.prev;
      node.prev.next = node.next;
    };

    DoubleLinkedList.prototype.append = function(array) {
      var e, i, len;
      for (i = 0, len = array.length; i < len; i++) {
        e = array[i];
        this.push_back(e);
      }
    };

    DoubleLinkedList.prototype.begin = function() {
      return new BDS.DoubleListIterator(this._head, this);
    };

    DoubleLinkedList.prototype.end = function() {
      return new BDS.DoubleListIterator(this._tail, this);
    };

    DoubleLinkedList.prototype.toString = function() {
      var iter, output, results;
      output = "";
      iter = this.iterator();
      results = [];
      while (iter.hasNext()) {
        results.push(output += iter.next());
      }
      return results;
    };

    return DoubleLinkedList;

  })();

  BDS.DoubleListNode = (function() {
    function DoubleListNode(data, prev, next) {
      this.data = data;
      this.prev = prev;
      this.next = next;
    }

    return DoubleListNode;

  })();

  BDS.DoubleListIterator = (function() {
    function DoubleListIterator(_node, _list) {
      this._node = _node;
      this._list = _list;
    }

    DoubleListIterator.prototype.hasNext = function() {
      return this._node.next.data !== null;
    };

    DoubleListIterator.prototype.hasPrev = function() {
      return this._node.prev.data !== null;
    };

    DoubleListIterator.prototype.next = function() {
      this._node = this._node.next;
      return this._node.data;
    };

    DoubleListIterator.prototype.prev = function() {
      this._node = this._node.prev;
      return this._node.data;
    };

    DoubleListIterator.prototype.current = function() {
      return this._node.data;
    };

    DoubleListIterator.prototype.remove = function() {
      return this._list._remove(this._node);
    };

    return DoubleListIterator;

  })();

}).call(this);

// Generated by CoffeeScript 1.11.1

/*
Heap
Implements a priority Queue using an Array Heap.
Written by Bryce Summers on 11 - 2 - 2017.

 * 
 * Note : This is a MIN heap.
 * 
 * Heap property :  For every element in the tree,
 *                  it is less than or equal to its left and right children in the tree as defined by the elements at the indexes associated by
 *                  the relationships index_left(index) and index_right(index).
 *  
 * Root node is always at index 0.
 * 
 * Left biased, when equal keys are present, the one on the left will be chosen.
 * 
 * Allows for duplicate keys.
 * 
 * Binary tree invariants :
 * The heap is represented by a binary tree that is encoded by index relationships within an unbounded array.
 * We maintain the UBA with a minimality of nodes, so the UBA will only contain N elements, when size = n.
 * 
 * The heap is as balanced as possible. This causes their to be a preference for left children over right children.
 * 
 * FIXME : I will need to work to preserve key stability, so that all keys will eventually be deleted, even if all keys entered are equal.
 */

(function() {
  BDS.Heap = (function() {
    Heap._D = 3;

    function Heap(data_in, comparator) {
      this._LE = comparator;
      if (!data_in) {
        this._data = [];
      } else {
        this._data = data_in.slice(0);
        this._heapify();
      }
    }

    Heap.prototype.size = function() {
      return this._data.length;
    };

    Heap.prototype.isEmpty = function() {
      return this._data.length === 0;
    };

    Heap.prototype.add = function(elem) {
      var len;
      len = this._data.length;
      this._data.push(elem);
      return this._sift_up(len);
    };

    Heap.prototype.append = function(elems) {
      var e, j, len1, results;
      results = [];
      for (j = 0, len1 = elems.length; j < len1; j++) {
        e = elems[j];
        results.push(this.add(e));
      }
      return results;
    };

    Heap.prototype.peek = function() {
      return this._data[0];
    };

    Heap.prototype.dequeue = function() {
      var last, output;
      if (this._data.length === 1) {
        return this._data.pop();
      }
      output = this._data[0];
      last = this._data.pop();
      this._data[0] = last;
      this.sift_down(0);
      return output;
    };

    Heap.prototype.toArray = function() {
      return this._data.slice(0);
    };

    Heap.prototype.getElem = function(index) {
      return this._data[index];
    };


    /*
    // Heapifies all of the nodes of the Tree with a root at the given index.
    // Builds the heap invariant downwards to all sub trees.
    // O(n), checks each node in the tree once.
    // Transforms a random array into an array that meets the heap invariants.
     */

    Heap.prototype._heapify = function() {
      var i, j, ref;
      for (i = j = ref = this._data.length - 1; j >= 0; i = j += -1) {
        this.sift_down(i);
      }
    };


    /*
    // Given an index, swaps the node down the tree while maintaining the min
    // heap invariant until the node is in an invariant correct place.
    // O(log(n)). Non recursive, so has O(1) function calls.
    // SIFT down.
     */

    Heap.prototype.sift_down = function(index) {
      var child, child_index, elem, i, min_elem, min_elem_index, size;
      size = this._data.length;
      child_index = this._index_child(index, 1);
      elem = this._data[index];
      while (child_index < size) {
        min_elem_index = -1;
        min_elem = elem;
        i = child_index;
        while (i < child_index + BDS.Heap._D && i < size) {
          child = this._data[i];
          if (this._LE(child, min_elem)) {
            min_elem = child;
            min_elem_index = i;
          }
          i++;
        }
        if (min_elem === elem) {
          return;
        }
        this._min_first(index, min_elem_index);
        index = min_elem_index;
        child_index = this._index_child(index, 1);
      }
    };

    Heap.prototype._sift_up = function(index) {
      var parent_index, results;
      parent_index = this._index_parent(index);
      results = [];
      while (index > 0 && this._min_first(parent_index, index)) {
        index = parent_index;
        results.push(parent_index = this._index_parent(index));
      }
      return results;
    };

    Heap.prototype._index_parent = function(index) {
      return Math.floor((index - 1) / BDS.Heap._D);
    };

    Heap.prototype._index_child = function(index, child_index) {
      return BDS.Heap._D * index + child_index;
    };

    Heap.prototype._min_first = function(index1, index2) {
      var elem1, elem2;
      elem1 = this._data[index1];
      elem2 = this._data[index2];
      if (!this._LE(elem1, elem2)) {
        BDS.Arrays.swap(this._data, index1, index2);
        return true;
      }
      return false;
    };

    Heap.prototype.toString = function() {
      var elem, j, len1, output, ref;
      output = "";
      output += "\nMinHeap[";
      ref = this._data;
      for (j = 0, len1 = ref.length; j < len1; j++) {
        elem = ref[j];
        output += elem;
        output += ",\n";
      }
      output += "]";
      return output;
    };

    Heap.prototype.clone = function() {
      return new BDS.Heap(this._data, this._LE);
    };

    Heap.prototype.toSortedArray = function() {
      var heap, i, j, len, output, ref;
      len = this._data.length;
      output = [];
      heap = this.clone();
      for (i = j = 0, ref = len; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
        output.push(heap.dequeue());
      }
      return output;
    };

    Heap.prototype.clear = function() {
      return this._data = [];
    };

    return Heap;

  })();

}).call(this);

// Generated by CoffeeScript 1.11.1

/*
 * Single Linked List Class
 * Written as part of the Bryce Summers Javascript Data Structures Libary.
 * Written by Bryce Summers on 6/12/2015.
 * Adapted by Bryce on 1 - 3 - 2017.

This should be used for more space efficient queues, stacks, or just iteration lists that support removal during iteration, such as in a game loop.
 */

(function() {
  BDS.SingleLinkedList = (function() {
    function SingleLinkedList() {
      this.clear();
    }

    SingleLinkedList.prototype.clear = function() {
      this._size = 0;
      this._head = new BDS.ListNode(null);
      return this._tail = this._head;
    };

    SingleLinkedList.prototype.push = function(elem) {
      var new_head;
      new_head = new BDS.ListNode(elem, this._head);
      this._head = new_head;
      return this.size++;
    };

    SingleLinkedList.prototype.pop = function() {
      var output;
      output = this._head.data;
      this._head = this._head.next;
      this._size--;
      return output;
    };

    SingleLinkedList.prototype.add = function(elem) {
      return this.push(elem);
    };

    SingleLinkedList.prototype.append = function(array) {
      var e, i, len, results;
      results = [];
      for (i = 0, len = array.length; i < len; i++) {
        e = array[i];
        results.push(this.push(e));
      }
      return results;
    };

    SingleLinkedList.prototype.remove_beginning = function() {
      return this.pop();
    };

    SingleLinkedList.prototype.enqueue = function(elem) {
      this._tail.data = elem;
      this._tail.next = new BDS.ListNode(null, null);
      this._tail = this._tail.next;
      return this._size++;
    };

    SingleLinkedList.prototype.dequeue = function() {
      return this.pop();
    };

    SingleLinkedList.prototype.iterator = function() {
      return new ListIterator(this._head, this);
    };

    SingleLinkedList.prototype.isEmpty = function() {
      return this.size === 0;
    };

    SingleLinkedList.prototype.size = function() {
      return this._size;
    };

    SingleLinkedList.prototype.toString = function() {
      var iter, output, results;
      output = "";
      iter = this.iterator();
      results = [];
      while (iter.hasNext()) {
        results.push(output += iter.next());
      }
      return results;
    };

    return SingleLinkedList;

  })();

  BDS.ListNode = (function() {
    function ListNode(data, next) {
      this.data = data;
      this.next = next;
    }

    return ListNode;

  })();

  BDS.ListIterator = (function() {
    function ListIterator(_node, _list) {
      this._node = _node;
      this._list = _list;
      this.last = this._node;
    }

    ListIterator.prototype.hasNext = function() {
      return this._node.next !== null;
    };

    ListIterator.prototype.next = function() {
      var output;
      output = this._node.data;
      this._last = this._node;
      this._node = this._node.next;
      return output;
    };

    ListIterator.prototype.remove = function() {

      /*
      Copy all of the next node's information over to the node that was just returned.
      thereby erasing and possibly releasing the memory.
       */
      this._last.data = this._node.data;
      this._last.next = this._node.next;
      if (this._node.next === null) {
        this._list.tail = this._last;
      }
      this._node = this._last;
      return this._list._size--;
    };

    return ListIterator;

  })();

}).call(this);

/*
 * Defines namespaces.
 * Adapted by Bryce Summers on 12 - 30 - 2016.
 */

// Bryce Data Structures.
SCRIB = {};
// Generated by CoffeeScript 1.11.1

/*
    Polyline Graph Associated Data classes.

    Adapted by Bryce Summers on 1 - 3 - 2017.

    Purpose: These classes provide application specific associated data structures that are linked into HalfedgeGraph elements.

    They will be used for algorithms on planar graph embeddings from polyline inputs.
 */

(function() {
  SCRIB.Graph_Data = (function() {
    function Graph_Data(graph) {
      this.graph = graph;
    }

    Graph_Data.prototype.clearFaceMarks = function() {
      var iter, results;
      iter = this.graph.facesBegin();
      results = [];
      while (iter.hasNext()) {
        results.push(iter.next().data.marked = false);
      }
      return results;
    };

    Graph_Data.prototype.clearVertexMarks = function() {
      var iter, results;
      iter = this.graph.verticesBegin();
      results = [];
      while (iter.hasNext()) {
        results.push(iter.next().data.marked = false);
      }
      return results;
    };

    Graph_Data.prototype.clearEdgeMarks = function() {
      var iter, results;
      iter = this.graph.edgesBegin();
      results = [];
      while (iter.hasNext()) {
        results.push(iter.next().data.marked = false);
      }
      return results;
    };

    Graph_Data.prototype.clearHalfedgeMarks = function() {
      var iter, results;
      iter = this.graph.halfedgesBegin();
      results = [];
      while (iter.hasNext()) {
        results.push(iter.next().data.marked = false);
      }
      return results;
    };

    Graph_Data.prototype.clearMarks = function() {
      this.clearFaceMarks();
      this.clearVertexMarks();
      this.clearEdgeMarks();
      return this.clearHalfedgeMarks();
    };

    return Graph_Data;

  })();

  SCRIB.Face_Data = (function() {
    function Face_Data(face) {
      var hole_representatives;
      this.face = face;
      this.marked = false;
      hole_representatives = [];
    }

    Face_Data.prototype.addHole = function(hole) {
      return hole_representatives.push(hole);
    };


    /*
    // The area of the face is determined by the intersection this face with all of the hole faces,
    // which will be specified by exterior facing edge that enclose an infinite complemented area.
     */

    return Face_Data;

  })();

  SCRIB.Vertex_Data = (function() {
    function Vertex_Data(vertex) {
      this.vertex = vertex;
      this.point = null;
      this.marked = false;
      this.tail_point = false;
      this.intersection_point = false;
      this.singleton_point = false;

      /*
       * Used as a temporary structure for graph construction, but it is also may be relevant to users.
       * I don't know whether I will maintain this structure outside of graph construction.
       * FIXME: I might switch this to being a pointer to allow for me to null it out when no longer needed.
       * SCRIB.Halfedge[]
       */
      this.outgoing_edges = [];
    }

    Vertex_Data.prototype.isExtraordinary = function() {
      return this.tail_point || this.intersection_point;
    };

    return Vertex_Data;

  })();

  SCRIB.Edge_Data = (function() {
    function Edge_Data(edge) {
      this.edge = edge;
      this.marked = false;
    }

    return Edge_Data;

  })();

  SCRIB.Halfedge_Data = (function() {
    function Halfedge_Data(halfedge) {
      this.halfedge = halfedge;
      this.marked = false;
      this.next_extraordinary = null;
    }

    Halfedge_Data.prototype.isExtraordinary = function() {
      return this.halfedge.vertex.data.isExtraordinary();
    };

    return Halfedge_Data;

  })();

}).call(this);

// Generated by CoffeeScript 1.11.1

/*
* Transforms a set of input polylines into a planar graph embedding.
*
* Written by Bryce Summers.
*
* 8/16/2016: Written as a more fully advanced version of FaceFinder.h,
*            which outputs sophisticated graph structures oozing with useful connectivity information.
* 1/4/2017:  Ported to Coffeescript.
*
* Original C++ code written for the STUDIO for Creative Inquiry at Carnegie Mellon University.
 */


/*
* These algorithms include:
* Preprocessing:
* [EMPTY]
*
* Main Algorithm:
* 1. The main algorithm for embedding a set of polylines in space and determining the set of non chordal cycles in the
*    associated embedded planar graph.
*
* - A polygon is closed if it has identical starting and ending points and open otherwise.
*   The algorithm may be configured to output either open or closed polygons based on the closed_loop mode state.
*
* FIXME: If a user draws a second line completely around an original line, then their will be faces defined by both an external
*        face on the original polyline embedding and an internal face on the new enclosing embedding.
*        This may invalidate some users' assumptions of a global planar graph embedding without any holes.
*
* Post Processing:
* 1. Determine internal and external faces. (Initial Release)
* 2. Determine trivial and non trivial area faces according to a constant area threshold value. (8/11/2016)
*    (If you can't think of any good constant values, you might want to look at the field of
*     Topological Data Analysis and their 'barcode' concept: https://en.wikipedia.org/wiki/Topological_data_analysis.
* 3. Clipping off tails, i.e. portions of faces that enclose 0 area. (8/11/2016)
*    This could potentially be put into the getCycle function, but I think that it is best to make this a dedicated post processing step instead
*    in order to preserve the simplicity of the main algorithm.
*    This algorithm properly handles faces with either duplicated or non-duplicated starting and ending points.
*    i.e. Those produced in open and closed mode.
 */


/*
// FIXME: Write a list of all of the relevant interesting properties of the my planar embedding implementation.
// Edges always point to the forward facing halfedge.
// forward facing half edges are consecutively ordered in the first half.
// backwards facing half edges are consecutively ordered in the reverse order of the first half.
 */

(function() {
  SCRIB.PolylineGraphEmbedder = (function() {

    /*
    A User can explicitly pass false to force the intersection points to be found using a brute force algorithm that
    may potentially be more robust and reliable than the optimized intersection algorithm,
    but it kills the performance.
     */
    function PolylineGraphEmbedder(_useFastAlgo) {
      this._useFastAlgo = _useFastAlgo;
      if (this._useFastAlgo === void 0) {
        this._useFastAlgo = true;
      }
      this._points = [];
      this._lines_initial = [];
      this._lines_split = [];

      /*
      // The graph that is being built.
      // Once it is returned, the responsibility for this memory transfers to the user and the pointer is forgotten from this class.
       * FIXME: Should this graph embedded remember this guy?
       */
      this._graph = null;
    }


    /*
    Derives a planar graph embedding from the given input polyline.
    Assumes all points are distinct.
     */

    PolylineGraphEmbedder.prototype.embedPolyline = function(inputs) {
      if (inputs.size() <= 1) {
        return this._trivial(inputs);
      }
      this._loadPolyline(inputs);
      return this._do_the_rest();
    };


    /*
     * Derive faces from a set list of vertex disjoint polyline inputs.
     * Note: Each individual polyline specifies properties such as being closed or not.
     * Polyline[] (An array of polylines) -> SCRIB.Graph
     */

    PolylineGraphEmbedder.prototype.embedPolylineArray = function(inputs) {
      var e, j, len, len1;
      len = inputs.length;
      for (j = 0, len1 = inputs.length; j < len1; j++) {
        e = inputs[j];
        this._loadPolyline(e);
      }
      return this._do_the_rest();
    };

    PolylineGraphEmbedder.prototype._trivial = function(polyline) {
      var edge, exterior, exterior_data, graph, halfedge, interior, interior_data, twin, vertex, vertex_data;
      graph = this._newGraph();
      if (polyline.size() < 1) {
        return graph;
      }

      /*
      We construct one of each element for the singleton graph.
      NOTE: This allocation is a wrapper on top of the Graph allocation function, which allocates its Vertex_Data object.
      the other functions this->new[ ____ ] work in the same way.
       */
      vertex = this._newVertex();
      vertex_data = vertex.data;
      edge = this._newEdge();
      interior = this._newFace();
      exterior = this._newFace();
      interior_data = interior.data;
      exterior_data = exterior.data;
      halfedge = this._newHalfedge();
      twin = this._newHalfedge();
      vertex_data.point = polyline.getPoint(0);
      vertex.halfedge = halfedge;
      edge.halfedge = halfedge;
      interior.halfedge = halfedge;
      interior_data.addHole(exterior);
      exterior.halfedge = halfedge;
      halfedge.edge = edge;
      halfedge.face = exterior;
      halfedge.next = halfedge;
      halfedge.prev = halfedge;
      halfedge.twin = twin;
      halfedge.vertex = vertex;
      twin.edge = edge;
      twin.face = interior;
      twin.next = twin;
      twin.prev = twin;
      twin.twin = halfedge;
      twin.vertex = vertex;
      return graph;
    };

    PolylineGraphEmbedder.prototype._do_the_rest = function() {
      var output;
      this._splitIntersectionPoints();
      this._allocate_graph_from_input();
      this._sort_outgoing_edges_by_angle();
      this._associate_halfedge_cycles();
      output = this._deriveFaces();
      output.delete_index_arrays();
      this._cleanup();
      return output;
    };


    /*
    The embedding is broken down into seperate phases. Here I have listed each operation,
    followed by the data structures that they have built.
    
    Appends the given input points to the collated single input point array.
    Performs point fudging to avoid degenerate behavior.
    Starts up the indexed collection of points.
    SCRIB.Polyline -> ()
     */


    /*
    New Constructed data Fields:
    //The canonical collection of points at their proper indices.
    BDS.Point[] @_points
    // The original input lines.
    SCRIB.Line[] @_lines_initial
     */

    PolylineGraphEmbedder.prototype._loadPolyline = function(polyline) {
      var i, input_point, j, k, len, offset, ref, ref1;
      len = polyline.size();
      offset = this._points.length;
      for (i = j = 0, ref = len; j < ref; i = j += 1) {
        input_point = polyline.getPoint(i);
        if ((offset > 0 || i > 0) && this._points[offset + i - 1].x === input_point.x) {
          input_point.x += .001;
        }
        this._points.push(input_point);
      }
      for (i = k = 0, ref1 = len - 1; k < ref1; i = k += 1) {
        this._lines_initial.push(new BDS.Line(i + offset, i + offset + 1, this._points));
      }

      /*
      Add a line connecting the first and last points on the original set of input points if
      the polyline is closed.
      In other words put a duplicate copy of the initial point.
       */
      if (polyline.isClosed()) {
        this._lines_initial.push(new BDS.Line(len - 1 + offset, 0 + offset, this._points));
      }
    };


    /*
    Intersects the input lines, then splits them and connects them appropiatly.
    Populates the list of edge disjoint lines that only intersect at vertices.
    puts the edge in consecutive order following the input polylines.
    results put into this.lines_split
    () -> ()
     */


    /*
    New Constructed data Field:
    Split version of original input lines, where lines only intersect at vertices.
    SCRIB.Line[] @_lines_split
     */

    PolylineGraphEmbedder.prototype._splitIntersectionPoints = function() {
      var i, intersector, j, line, numLines, ref;
      intersector = new BDS.Intersector();
      if (this._bUseFastAlgo) {
        intersector.intersect(this._lines_initial);
      } else {
        intersector.intersect_brute_force(this._lines_initial);
      }
      numLines = this._lines_initial.length;
      for (i = j = 0, ref = numLines; j < ref; i = j += 1) {
        line = this._lines_initial[i];
        line.getSplitLines(this._lines_split);
      }
    };


    /*
    #-- Step 3. Proccess the embedded input and initialize the Planar Graph vertices, edges, and halfedges.
    Allocates the output graph object and allocates vertices, edges, and halfedges for the input data.
    Vertices are Indexed as follows [original points 1 for input polyline 1, then 2, ...,
    new intersection points for polyline 1, then 2, etc, ...]
    Halfedges are indexed in polyline input order, then in backwards input order.
    () -> ()
     */


    /*
    New Constructed data Field:
    The graph that is being built and will eventually be returned to the user.
    SCRIB.Graph @_graph
     */

    PolylineGraphEmbedder.prototype._allocate_graph_from_input = function() {
      var e, edge, edge_ID, halfedge, halfedge_ID, i, j, k, l, last_backwards_halfedge, last_forwards_halfedge, last_index, len, len1, len2, line, point, ref, ref1, ref2, twin, twin_ID, vert, vert_data, vert_twin, vert_twin_data, vertex_ID, vertex_twin_ID;
      this._graph = this._newGraph();
      ref = this._points;
      for (j = 0, len1 = ref.length; j < len1; j++) {
        point = ref[j];
        vert = this._newVertex();
        vert_data = vert.data;
        vert.halfedge = null;
        vert_data.point = point;
      }
      ref1 = this._lines_split;
      for (k = 0, len2 = ref1.length; k < len2; k++) {
        e = ref1[k];
        this._newHalfedge();
        this._newHalfedge();
        this._newEdge();
      }

      /*
      Associate edges <-> halfedges.
            halfedges <-> twin halfedges.
            halfedges <-> vertices.
       */
      last_forwards_halfedge = null;
      last_backwards_halfedge = null;
      len = this._lines_split.length;
      last_index = len * 2 - 1;
      for (i = l = 0, ref2 = len; l < ref2; i = l += 1) {
        line = this._lines_split[i];
        vertex_ID = line.p1_index;
        vertex_twin_ID = line.p2_index;
        edge_ID = i;
        halfedge_ID = i;
        twin_ID = last_index - i;
        edge = this._graph.getEdge(edge_ID);
        halfedge = this._graph.getHalfedge(halfedge_ID);
        twin = this._graph.getHalfedge(twin_ID);
        vert = this._graph.getVertex(vertex_ID);
        vert_twin = this._graph.getVertex(vertex_twin_ID);
        vert_data = vert.data;
        vert_twin_data = vert_twin.data;
        edge.halfedge = halfedge;
        halfedge.edge = edge;
        twin.edge = edge;
        halfedge.twin = twin;
        twin.twin = halfedge;
        halfedge.vertex = vert;
        twin.vertex = vert_twin;
        if (vert.halfedge === null) {
          vert.halfedge = halfedge;
        }
        if (vert_twin.halfedge === null) {
          vert_twin.halfedge = twin;
        }
        if (halfedge === void 0 || twin === void 0) {
          debugger;
        }
        vert_data.outgoing_edges.push(halfedge);
        vert_twin_data.outgoing_edges.push(twin);
      }
    };

    PolylineGraphEmbedder.prototype._sort_outgoing_edges_by_angle = function() {
      var iter, outgoing_edges, vert_data;
      iter = this._graph.verticesBegin();
      while (iter.hasNext()) {
        vert_data = iter.next().data;
        outgoing_edges = vert_data.outgoing_edges;
        this._sort_outgoing_edges(outgoing_edges);
      }
    };

    PolylineGraphEmbedder.prototype._sort_outgoing_edges = function(outgoing_edges) {
      var angle, angles, center_data, center_point, center_vert, edge, hedge_in, hedge_out, i, i1, i2, j, k, l, len, len1, outer_data, outer_point, outer_vert, outgoing_halfedge_representative, ref, ref1, temp_f, temp_he;
      len = outgoing_edges.length;
      if (len <= 2) {
        return;
      }
      angles = [];
      outgoing_halfedge_representative = outgoing_edges[0];
      center_vert = outgoing_halfedge_representative.vertex;
      center_data = center_vert.data;
      center_point = center_data.point;
      for (j = 0, len1 = outgoing_edges.length; j < len1; j++) {
        edge = outgoing_edges[j];
        hedge_out = edge;
        hedge_in = hedge_out.twin;
        outer_vert = hedge_in.vertex;
        outer_data = outer_vert.data;
        outer_point = outer_data.point;
        angle = Math.atan2(outer_point.y - center_point.y, outer_point.x - center_point.x);
        angles.push(angle);
      }
      for (i = k = 0, ref = len; k < ref; i = k += 1) {
        for (i2 = l = ref1 = i - 1; l >= 0; i2 = l += -1) {
          i1 = i2 + 1;
          if (angles[i2] <= angles[i1]) {
            break;
          }
          temp_f = angles[i2];
          angles[i2] = angles[i1];
          angles[i1] = temp_f;
          temp_he = outgoing_edges[i2];
          outgoing_edges[i2] = outgoing_edges[i1];
          outgoing_edges[i1] = temp_he;
          if (outgoing_edges[i1] === void 0 || outgoing_edges[i2] === void 0) {
            debugger;
          }
        }
      }
    };


    /*
     * -- Step 5.
    Determines the next and previous pointers for the halfedges in the Graph.
    This is done almost entirely using the sets of outgoing edges for each vertex.
    vertices of degree 2 associate their 2 pairs of neighbors.
    vertices of degree are on a tail and associate their one pair of neighbors.
    vertices of degree >2 are intersection points and they first sort their neighbors, then associate their star.
    This function sets the Vertex_Data objects classification data.
     * () -> ()
     */

    PolylineGraphEmbedder.prototype._associate_halfedge_cycles = function() {
      var degree, halfedge, hedge_in, hedge_out, i, iter, j, outgoing_edges, ref, vert, vert_data;
      iter = this._graph.verticesBegin();
      while (iter.hasNext()) {
        vert = iter.next();
        vert_data = vert.data;
        outgoing_edges = vert_data.outgoing_edges;
        degree = outgoing_edges.length;
        if (degree === 0) {
          vert_data.singleton_point = true;
          halfedge = vert.halfedge;
          halfedge.next = halfedge;
          halfedge.prev = halfedge;
          continue;
        }
        if (degree === 1) {
          vert_data.tail_point = true;
          hedge_out = vert.halfedge;
          hedge_in = hedge_out.twin;
          hedge_out.prev = hedge_in;
          hedge_in.next = hedge_out;
          continue;
        }
        if (degree > 2) {
          vert_data.intersection_point = true;
        }
        for (i = j = 0, ref = degree; j < ref; i = j += 1) {
          hedge_out = outgoing_edges[i];
          if (hedge_out === void 0 || hedge_out.twin === void 0) {
            debugger;
          }
          hedge_in = hedge_out.twin;
          hedge_in.next = outgoing_edges[(i + 1) % degree];
          hedge_out.prev = outgoing_edges[(i + degree - 1) % degree].twin;
        }
        continue;
      }
    };


    /*
     * Step 6.
     * Uses the vertex and edge complete halfedge mesh to add face data.
     * Also produces simpler cycle structures along that serve as an alternate representation of the faces.
     * () -> SCRIB.Graph
     */

    PolylineGraphEmbedder.prototype._deriveFaces = function() {
      var face, halfedge, halfedge_data, iter;
      iter = this._graph.halfedgesBegin();
      while (iter.hasNext()) {
        halfedge = iter.next();
        halfedge_data = halfedge.data;
        if (halfedge_data.marked) {
          continue;
        }
        face = this._newFace();
        face.halfedge = halfedge;
        this._trace_face(face);
      }
      this._graph.data.clearHalfedgeMarks();
      return this._graph;
    };


    /*
    REQUIRES: 1. face -> halfedge well defined already.
              2. halfedge next pointer well defined already.
    ENSURES:  links every halfedge in the loop starting and ending at face -> halfedge
              with the face.
     * SCRIB.Face -> ()
     */

    PolylineGraphEmbedder.prototype._trace_face = function(face) {
      var current, start;
      start = face.halfedge;
      current = start;
      while (true) {
        current.face = face;
        current.data.marked = true;
        current = current.next;
        if (current === start) {
          break;
        }
      }
    };


    /*
    Free all of the intermediary data structures.
    Clear input structures.
    Unmark the output.
     */

    PolylineGraphEmbedder.prototype._cleanup = function() {
      this._points = [];
      this._lines_initial = [];
      return this._lines_split = [];
    };

    PolylineGraphEmbedder.prototype._newGraph = function() {
      var output;
      output = new SCRIB.Graph(true);
      output.data = new SCRIB.Graph_Data(output);
      return output;
    };

    PolylineGraphEmbedder.prototype._newFace = function() {
      var output;
      output = this._graph.newFace();
      output.data = new SCRIB.Face_Data(output);
      return output;
    };

    PolylineGraphEmbedder.prototype._newEdge = function() {
      var output;
      output = this._graph.newEdge();
      output.data = new SCRIB.Edge_Data(output);
      return output;
    };

    PolylineGraphEmbedder.prototype._newHalfedge = function() {
      var output;
      output = this._graph.newHalfedge();
      output.data = new SCRIB.Halfedge_Data(output);
      return output;
    };

    PolylineGraphEmbedder.prototype._newVertex = function() {
      var output;
      output = this._graph.newVertex();
      output.data = new SCRIB.Vertex_Data(output);
      return output;
    };

    return PolylineGraphEmbedder;

  })();

}).call(this);

// Generated by CoffeeScript 1.11.1

/*
The PolylineGraphPostProcessor class.
*
* Written and adapted from FaceFinder on 8/18/2016.
* Ported to Coffeescript on 1 - 4 - 2017.
*
* Purpose:
*
* Allows users to convert Planar Polyline Embedded Graphs into mainstream C++ data structures.
* This class then provides some useful processing algorithms on these output structures.
*
* I may also put information extraction algorithms here.
*
* The key idea is that the post processor doesn't mutate the Graph object in any way.
* FIXME: Use the Graph Mutator Proccessor instead (Currenly non existant.) if you wish to modify the graph.
*
* Maybe I will make a modification mode.
 */


/*

Tested Features:
    convert_to_face_infos()

Untested Features:
    clipTails()
    mergeFaces()
    BDS.BVH2D = generateBVH() [requires HalfedgeMesh]

     * Splits the current embedding by the given polyline.
    embedAnotherPolyline(polyLine)
    eraseEdgesInCircle()
 */

(function() {
  SCRIB.Edge_Info = (function() {
    function Edge_Info(edge1) {
      this.edge = edge1;
    }

    return Edge_Info;

  })();

  SCRIB.Halfedge_Info = (function() {

    /*
     * Represents and points to a halfedge. Its pointers may not be valid after algorithms such as tail clipping.
    // Faces and twin pointers should still be valid though...
     * @halfedge is only defined for HalfedgeGraph based souce embeddings.
     * Also contains a pointer to its face_info object.
     */
    function Halfedge_Info(halfedge1, face_info1) {
      var next_data, next_point, next_vert, vert, vert_data;
      this.halfedge = halfedge1;
      this.face_info = face_info1;
      vert = this.halfedge.vertex;
      vert_data = vert.data;
      this.point = vert_data.point;
      this.id = vert_data.id;
      this.polyline = new BDS.Polyline(false);
      this.polyline.addPoint(this.point);
      this.polyline.setAssociatedData(this);
      next_vert = this.halfedge.next.vertex;
      next_data = next_vert.data;
      next_point = next_data.point;
      this.polyline.addPoint(next_point);
    }

    return Halfedge_Info;

  })();

  SCRIB.Face_Info = (function() {
    function Face_Info(face1) {
      this.face = face1;
      this.holes = [];
      this.halfedges = [];
      this._halfedge_bvh = null;
      this.polyline = new BDS.Polyline(true);
      this.polyline.setAssociatedData(this);
      this.faces_id_set = new Set();
      this.complemented = false;
    }

    Face_Info.prototype.size = function() {
      return this.points.length;
    };

    Face_Info.prototype.isClosed = function() {
      return polyline.isClosed();
    };

    Face_Info.prototype.getLastPointInfo = function() {
      return this.points[this.points.length - 1];
    };

    Face_Info.prototype.push = function(halfedge_info) {
      this.points.push(halfedge_info);
      return this.polyline.addPoint(halfedge_info.point);
    };

    Face_Info.prototype.pop = function() {
      this.polyline.removeLastPoint();
      return this.points.pop();
    };

    Face_Info.prototype.at = function(index) {
      return this.points[index];
    };

    Face_Info.prototype.isComplemented = function() {
      return this.polyline.isComplemented();
    };

    Face_Info.prototype.generateBVH = function() {
      var halfedge, i, j, len, polyline, ref, segments;
      segments = this.polyline.toPolylineSegments();
      len = polyline.length;
      for (i = j = 0, ref = len; j < ref; i = j += 1) {
        polyline = segments[i];
        halfedge = this.halfedges[i];
        polyline.setAssociatedData(halfedge);
      }
      return this._halfedge_bvh = new BDS.BVH2D(segments);
    };

    Face_Info.prototype.query_halfedges_in_box = function(box, output_list) {
      var j, len1, line, polylines;
      if (output_list === void 0) {
        output_list = [];
      }
      polylines = this._halfedge_bvh.query_box_all(box);
      for (j = 0, len1 = polylines.length; j < len1; j++) {
        line = polylines[j];
        output_list.push(line.getAssociatedData());
      }
      return output_list;
    };

    return Face_Info;

  })();

  SCRIB.PolylineGraphPostProcessor = (function() {
    function PolylineGraphPostProcessor() {
      this._graph = null;
      this._face_vector = null;
      this._face_bvh = null;
    }

    PolylineGraphPostProcessor.prototype.generate_faces_info = function() {
      var current, face, face_output, halfedge_info, iter, output, starting_half_edge;
      output = [];
      iter = this._graph.facesBegin();
      while (iter.hasNext()) {
        face = iter.next();
        face_output = new SCRIB.Face_Info(face);
        face_output.faces_id_set.add(face.id);
        starting_half_edge = face.halfedge;
        current = starting_half_edge;
        while (true) {
          halfedge_info = new SCRIB.Halfedge_Info(current, face_output);
          face_output.halfedges.push(halfedge_info);
          face_output.polyline.addPoint(halfedge_info.point);
          current = current.next;
          if (starting_half_edge === current) {
            break;
          }
        }
        output.push(face_output);
        continue;
      }
      this._face_vector = output;
      return output;
    };

    PolylineGraphPostProcessor.prototype.get_current_faces_info = function() {
      return this._face_vector;
    };

    PolylineGraphPostProcessor.prototype.load_graph = function(_graph) {
      this._graph = _graph;
      return this._face_vector = null;
    };

    PolylineGraphPostProcessor.prototype.free_face_vector = function() {
      return this._face_vector = null;
    };

    PolylineGraphPostProcessor.prototype.free_graph = function() {
      return this._graph = null;
    };


    /*
    Appends the indices of any external faces amongst the input list of faces to the output vector.
    NOTE : The input type is equivelant to the output type of the face finding functions,
    so using this function may be a natural extension of using the original functions.
     * int[] -> () [appends complemented faces to input]
     */

    PolylineGraphPostProcessor.prototype.determineComplementedFaces = function(output) {
      var area, face_info, index, j, len, ref;
      len = this._face_vector.length;
      for (index = j = 0, ref = len; 0 <= ref ? j < ref : j > ref; index = 0 <= ref ? ++j : --j) {
        face_info = this._face_vector[index];
        area = face_info.polyline.computeAreaOfPolygon();
        if (area > 0) {
          output.push(index);
        }
      }
    };

    PolylineGraphPostProcessor.prototype.determineNonTrivialAreaFaces = function(output, min_area) {
      var area, face_info, index, j, len, ref;
      len = this._face_vector.length;
      for (index = j = 0, ref = len; 0 <= ref ? j < ref : j > ref; index = 0 <= ref ? ++j : --j) {
        face_info = this._face_vector[index];
        area = face_info.polyline.computeAreaOfPolygon();
        area = area >= 0 ? area : -area;
        if (area >= min_area) {
          output.push(index);
        }
      }
    };

    PolylineGraphPostProcessor.prototype.determineTrivialAreaFaces = function(output, min_area) {
      var area, face_info, index, j, len, ref;
      len = this._face_vector.length;
      for (index = j = 0, ref = len; 0 <= ref ? j < ref : j > ref; index = 0 <= ref ? ++j : --j) {
        face_info = this._face_vector[index];
        area = face_info.polyline.computeAreaOfPolygon();
        area = area >= 0 ? area : -area;
        if (area < min_area) {
          output.push(index);
        }
      }
    };


    /*
    Input: a set of faces, Output: a new set of faces that have no trivial contiguous subfaces.
    clips all of the polylines currently loaded in this post processor.
    ENSURES: Polygons will be output either open or closed in the manner that they are passed in.
    ENSURES: Omits faces consisting of only a single long tail.
    The user is still responsible to deallocating the original vector.
     * () -> face_info[] (with no tails)
     */

    PolylineGraphPostProcessor.prototype.clipAllTails = function() {
      var clipped_face, index, input, j, len, output, ref, unclipped_face;
      input = this._face_vector;
      output = [];
      len = input(function() {
        return size();
      });
      for (index = j = 0, ref = len; 0 <= ref ? j < ref : j > ref; index = 0 <= ref ? ++j : --j) {
        unclipped_face = input[index];
        clipped_face = this._clipTails(unclipped_face);
        if (clipped_face.size() > 0) {
          output.push(clipped_face);
        }
      }
      return output;
    };

    PolylineGraphPostProcessor.prototype._clipTails = function(input) {
      var clipped_previous, i, j, len, non_empty_output, output, p_end, p_next, p_previous, p_start, prune_num, ref;
      output = new SCRIB.Face_Info();
      len = input(function() {
        return size();
      });
      if (len < 3 || !input.isClosed()) {
        return output;
      }
      p_start = (input(function() {
        return at(0);
      })).ID;
      p_end = (input(function() {
        return at(len - 1);
      })).ID;

      /*
      The main idea behind tail clipping is to transform regions of the form ABA --> A,
      in other words removing any consecutive pairs of half edges cooresponding to the same full edge.
      We therefore
       */
      clipped_previous = false;
      non_empty_output = false;
      for (i = j = 0, ref = len; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
        p_previous = 0/0;
        non_empty_output = output.size() > 0;
        if (non_empty_output) {
          p_previous = output.getLastPointInfo().ID;
        } else {
          p_previous = input.points[len - 1].ID;
        }
        p_next = input.points[(i + 1) % len].ID;
        if (p_previous !== p_next) {
          output.push(input.at(i % len));
          clipped_previous = false;
          continue;
        }
        clipped_previous = true;
        if (non_empty_output) {
          output.pop();
        } else {
          len -= 1;
        }

        /*
        Don't add the current point, because we prune it as well.
        If p_next ends up now being a non tail point, it will be successfully added during the next iteration.
        We don't add it now, because we want to give it the opportunity to pruned by its next neighbor.
         */
        continue;
      }
      prune_num = 0;
      while (clipped_previous) {
        len = output.size();
        if (len < 3) {
          return output;
        }
        p_previous = (output.at(len - 1)).ID;
        p_next = (output.at(prune_num + 1)).ID;
        if (p_previous !== p_next) {
          break;
        }
        prune_num += 1;
        output.pop();
        continue;
      }
      if (clipped_previous) {
        output.splice(0, prune_num);
      }
      return output;
    };


    /*
    Uses the currently loaded this->graph object as Input.
    Takes in a vector containing the integer IDs of the faces to be merged.
    Takes a dictionary containing integers and outputs a set of faces representing the merge.
    Outputs the result of unioning all of the faces.
    Set -> SCRIB.FaceInfo[]
     */

    PolylineGraphPostProcessor.prototype.mergeFaces = function(face_ID_set) {
      var current, face, face_info, faces_complemented, faces_uncomplemented, id, j, k, l, len1, len2, len3, len4, m, map, output, set, start, uncomplemented_face;
      faces_uncomplemented = [];
      faces_complemented = [];
      for (j = 0, len1 = face_ID_Set.length; j < len1; j++) {
        id = face_ID_Set[j];
        Face * (face = graph.getFace(id));
        Halfedge * (start = face.halfedge);
        Halfedge * (current = face.halfedge);
        while (true) {
          if (current.data.marked === false && this._halfedgeInUnion(face_ID_set, current)) {
            face_info = this._traceUnionFace(face_ID_set, current);
            if (!face_info.isComplemented()) {
              face.complemented = false;
              faces_uncomplemented.push(face);
            } else {
              face.complemented = true;
              faces_complemented.push(face);
            }
          }
          current = current.next;
          if (current === start) {
            break;
          }
        }
        continue;
      }
      graph.data.clearHalfedgeMarks();
      output = [];
      map = {};
      for (k = 0, len2 = faces_uncomplemented.length; k < len2; k++) {
        face_info = faces_uncomplemented[k];
        output.push_back(face_info);
        set = face_info.faces_ID_set;
        for (l = 0, len3 = set.length; l < len3; l++) {
          id = set[l];
          map[id] = face;
        }
      }
      for (m = 0, len4 = faces_complemented.length; m < len4; m++) {
        face_info = faces_complemented[m];
        id = face_info.faces_id_set.keys().next().value;
        uncomplemented_face = map[id];
        if (!uncomplemented_face) {
          output.push(face);
          continue;
        }
        uncomplemented_face.holes.push_back(face_info);
      }
      return output;
    };


    /*
    Returns true iff the given hafedge is included in the output of the union of the given faces.
    I.E. returns true iff the given half edge -> face is within the set of unioned faces and half_edge->twin -> face is not.
    Tail edges, where the halfedge and its twin are on the same face are not considered to be in a halfedgeUnion face.
    Set, SCRIB.Halfedge -> bool.
     */

    PolylineGraphPostProcessor.prototype._halfedgeInUnion = function(face_id_set, start) {
      var face, face_found, face_id, twin_ID, twin_face, twin_face_found;
      face = start.face;
      face_id = face.id;
      face_found = face_id_set.has(face_id);
      twin_face = start.twin.face;
      twin_ID = twin_face(function() {
        return ID;
      });
      twin_face_found = face_Id_set.has(twin_ID);
      return face_found && !twin_face_found;
    };


    /*
    // Given an In Union halfege, traces its face_info union face information.
    // Properly sets the output's: points and face_IDs fields.
    // Marks halfedges, therefore calling functions are responsible for unmarking halfedges.
    Set, SCRIB.Halfedge -> SCRIB.Face_Info
     */

    PolylineGraphPostProcessor.prototype._traceUnionFace = function(face_ID_set, start) {
      var current, current_face_ID, current_point_info, output, output_ID_set;
      output = new SCRIB.Face_Info();
      output_ID_set = output.faces_ID_set;
      current = start;
      while (true) {
        current.data.marked = true;
        current_point_info = this._halfedgeToPointInfo(current);
        output.push(current_point);
        current_face_ID = current.face.ID;
        output_ID_set.add(current_face_ID);
        current = this._nextUnionFace(face_ID_set, current);
        if (current === start) {
          break;
        }
      }
      return output;
    };

    PolylineGraphPostProcessor.prototype._nextUnionFace = function(face_ID_Set, current) {
      current = current.twin.prev.twin;
      while (!this._halfedgeInUnion(face_ID_Set, current)) {
        current = current.prev.twin;
      }
      return current;
    };

    PolylineGraphPostProcessor.prototype._halfedgeToPointInfo = function(halfedge) {
      var vertex, vertex_data;
      vertex = halfedge.vertex;
      vertex_data = vertex.data;
      return new SCRIB.Point_Info(vertex_data.point, vertex.ID, halfedge);
    };

    PolylineGraphPostProcessor.prototype.generateBVH = function() {
      var polylines;
      polylines = this.facesToPolylines(this._face_vector);
      return this._face_bvh = new BDS.BVH2D(polylines);
    };

    PolylineGraphPostProcessor.prototype.facesToPolylines = function(face_infos, allow_complemented_faces) {
      var allow_compleemented_faces, face_info, j, len1, output, polyline;
      if (allow_complemented_faces === void 0) {
        allow_compleemented_faces = false;
      }
      output = [];
      for (j = 0, len1 = face_infos.length; j < len1; j++) {
        face_info = face_infos[j];
        polyline = face_info.polyline;
        if ((!polyline.isComplemented()) || allow_complemented_faces) {
          output.push(polyline);
        }
        continue;
      }
      return output;
    };

    PolylineGraphPostProcessor.prototype.polylinesToAssociatedData = function(polylines) {
      var j, len1, line, output;
      output = [];
      for (j = 0, len1 = polylines.length; j < len1; j++) {
        line = polylines[j];
        output.push(line.getAssociatedData());
      }
      return output;
    };

    PolylineGraphPostProcessor.prototype.embedAnotherPolyline = function(polyLine) {
      throw new Error("IMPLEMENT ME PLEASE!");
    };


    /*
     * Edge Queries.
     * Returns elements within the edge bvh in the given area regions.
     * Note: Edge queries are implemented by first performing a face query
     * and then perfomring edge queries on those face's edge bvh's in the Face_Info objects.
     */

    PolylineGraphPostProcessor.prototype.query_edges_in_circle = function(circle, output) {
      return this.query_edges_in_geometry(circle, output);
    };

    PolylineGraphPostProcessor.prototype.query_edges_in_polyline = function(polyline, output) {
      return this.query_edges_in_geometry(polyline, output);
    };

    PolylineGraphPostProcessor.prototype.query_edges_in_geometry = function(geom, output) {
      var halfedge, hedge, j, len1, polyline;
      hedge = this.query_halfedges_in_box(geom.generateBoundingBox());
      for (j = 0, len1 = edges.length; j < len1; j++) {
        halfedge = edges[j];
        polyline = halfedge.polyline;
        if (geom.detect_intersection_with_polyline(polyline)) {
          output.push(geom);
        }
      }
      return output;
    };

    PolylineGraphPostProcessor.prototype.query_halfedges_in_box = function(box, output) {
      var face, faces, j, len1;
      faces = this.query_faces_in_box(box);
      if (output === void 0) {
        output = [];
      }
      for (j = 0, len1 = faces.length; j < len1; j++) {
        face = faces[j];
        face.query_halfedges_in_box(box, output);
      }
      return output;
    };


    /*
     * Face Queries.
     * Returns elements within the face bvh in the given area regions.
     */

    PolylineGraphPostProcessor.prototype.query_faces_in_circle = function(circle) {
      return this.query_faces_in_geometry(circle);
    };

    PolylineGraphPostProcessor.prototype.query_faces_in_polyline = function(polyline) {
      return this.query_faces_in_geometry(polyline);
    };

    PolylineGraphPostProcessor.prototype.query_faces_in_geometry = function(geom) {
      var box, j, len1, output, polyline, polylines_in_box;
      box = geom.generateBoundingBox();
      polylines_in_box = this._face_bvh.query_box_all(box);
      output = [];
      for (j = 0, len1 = polylines_in_box.length; j < len1; j++) {
        polyline = polylines_in_box[j];
        if (geom.detect_intersection_with_polyline(polyline)) {
          output.push(polyline.getAssociatedData());
        }
      }
      return output;
    };

    PolylineGraphPostProcessor.prototype.query_faces_in_box = function(box) {
      return this.polylinesToAssociatedData(this._face_bvh.query_box_all(box));
    };


    /*
     * Element Deletion Methods.
     * These delete all Halfedge Mesh elements within a given region.
     * They then rebuild and preserve the invariants of the mesh.
     */

    PolylineGraphPostProcessor.prototype.eraseEdges = function(edges) {};

    PolylineGraphPostProcessor.prototype._eraseEdge = function(edge) {};

    return PolylineGraphPostProcessor;

  })();

}).call(this);

// Generated by CoffeeScript 1.11.1

/*
Halfedge Graph / Mesh class.
Written by Bryce Summers on 1 - 2 - 2017.
 */


/*
* FIXME: Writeup my modified usage, now that we are in javasccript.
*
* Usage:
*
* The Application programmer / New Media Artist specifies the following:
* 1. The data format they have availible for graph construction (e.g. vectors of openframeworks points.)
* 2. The Algorithms they need.
* 3. The data format that they wish to receive the results in.
*
* They will do so by specifying which class definitions they want.
*
* The algorithm designer / computational geometer specifies the following:
* 1. Definitions for the associated data.
* 2. The interface for constructing Graphs from application data
* 3. The interface for running algorithms on the Graphs.
* 4. The interface for allowing the application programmer to retrieve the results.
*
* If done elegantly, the New Media Artist should never need to touch the halfedge mesh, go on pointer journeys, and
* they should be able to treat the internal implementation as a black box.
 */


/*
 * -- Associated Data Classes.

#Since Javascript is untyped, these will mostly be her for convenience, and the user can insert the data they wish into each of these structures.

Every graph element will have a reserved variable called 'data' for linking to application specific information.

class SCRIB.Graph_Data
class SCRIB.Vertex_Data
class SCRIB.Face_Data
class SCRIB.Halfedge_Data
class SCRIB.Edge_Data
 */


/*
// FIXME: Clean up this prose.

// -- Structural definition of classes.
// Every class is specified by its connectivity information and a pointer to associated user data.

// All elements may be marked and unmarked by algorithms and users to specific sets of elements that meet various criteria.

// The Graph class represents an entire graph embedding defined by points in space.
// For the purposes of the facefinder, the output graph will be planar.
// connected via edges that intersect only at vertices.
// The FaceFinder class may be used to derive a Graph from a set of potentially intersecting input polylines.
 */

(function() {
  SCRIB.Graph = (function() {

    /*
    // Graph classes are where all of the actual data will be stored, so it contains vectors of valued data,
    // rather than pointers.
    // All ID's contained within these vectors will reference tha index of the object within these vectors.
    
    // Ideally, vertices, edges, and halfedges will be ordered logically according to the order they were input into the facefinder,
    // but I will need to do some more thinking on how to formally specify these things.
     */
    function Graph(_allocate_index_arrays) {
      this._allocate_index_arrays = _allocate_index_arrays;
      this._faces = new BDS.DoubleLinkedList();
      this._vertices = new BDS.DoubleLinkedList();
      this._edges = new BDS.DoubleLinkedList();
      this._halfedges = new BDS.DoubleLinkedList();
      this._next_face_id = 0;
      this._next_vertice_id = 0;
      this._next_edge_id = 0;
      this._next_halfedge_id = 0;
      if (this._allocate_index_arrays) {
        this._face_array = [];
        this._vertex_array = [];
        this._edge_array = [];
        this._halfedge_array = [];
      }
      this._data = null;
    }

    Graph.prototype.newFace = function() {
      var id, iter, output;
      id = this._next_face_id++;
      output = new SCRIB.Face();
      this._faces.push_back(output);
      if (this._face_array) {
        this._face_array.push(output);
      }
      output.id = id;
      iter = this._faces.end();
      iter.prev()._iterator = iter;
      return output;
    };

    Graph.prototype.newVertex = function() {
      var id, iter, output;
      id = this._next_vertice_id++;
      output = new SCRIB.Vertex();
      this._vertices.push_back(output);
      if (this._vertex_array) {
        this._vertex_array.push(output);
      }
      output.id = id;
      iter = this._vertices.end();
      iter.prev()._iterator = iter;
      return output;
    };

    Graph.prototype.newEdge = function() {
      var id, iter, output;
      id = this._next_edge_id++;
      output = new SCRIB.Edge();
      this._edges.push_back(output);
      if (this._edge_array) {
        this._edge_array.push(output);
      }
      output.id = id;
      iter = this._edges.end();
      iter.prev()._iterator = iter;
      return output;
    };

    Graph.prototype.newHalfedge = function() {
      var id, iter, output;
      id = this._next_halfedge_id++;
      output = new SCRIB.Halfedge();
      this._halfedges.push_back(output);
      if (this._halfedge_array) {
        this._halfedge_array.push(output);
      }
      output.id = id;
      iter = this._halfedges.end();
      iter.prev()._iterator = iter;
      return output;
    };

    Graph.prototype.deleteElement = function(e) {
      return e._iterator.remove();
    };

    Graph.prototype.getData = function() {
      return this._data;
    };

    Graph.prototype.numFaces = function() {
      return this._faces.size();
    };

    Graph.prototype.numVertices = function() {
      return this._vertices.size();
    };

    Graph.prototype.numEdges = function() {
      return this._edges.size();
    };

    Graph.prototype.numHalfedges = function() {
      return this._halfedges.size();
    };

    Graph.prototype.getFace = function(id) {
      return this._face_array[id];
    };

    Graph.prototype.getVertex = function(id) {
      return this._vertex_array[id];
    };

    Graph.prototype.getEdge = function(id) {
      return this._edge_array[id];
    };

    Graph.prototype.getHalfedge = function(id) {
      return this._halfedge_array[id];
    };

    Graph.prototype.delete_index_arrays = function() {
      delete this._face_array;
      delete this._vertex_array;
      delete this._edge_array;
      return delete this._halfedge_array;
    };


    /*
     - Iteration functions.
     - These all return BDS.DoubleListIterator's
     */

    Graph.prototype.facesBegin = function() {
      return this._faces.begin();
    };

    Graph.prototype.facesEnd = function() {
      return this._faces.end();
    };

    Graph.prototype.verticesBegin = function() {
      return this._vertices.begin();
    };

    Graph.prototype.verticesEnd = function() {
      return this._vertices.end();
    };

    Graph.prototype.edgesBegin = function() {
      return this._edges.begin();
    };

    Graph.prototype.edgesEnd = function() {
      return this._edges.end();
    };

    Graph.prototype.halfedgesBegin = function() {
      return this._halfedges.begin();
    };

    Graph.prototype.halfedgesEnd = function() {
      return this._halfedges.end();
    };

    return Graph;

  })();

  SCRIB.Face = (function() {
    function Face() {
      this.halfedge = null;
      this.data = new SCRIB.Face_Data();
      this.id = null;
      this._iterator = null;
    }

    return Face;

  })();

  SCRIB.Vertex = (function() {
    function Vertex() {
      this.halfedge = null;
      this.data = null;
      this.id = null;
      this._iterator = null;
    }

    return Vertex;

  })();

  SCRIB.Edge = (function() {
    function Edge() {}

    Edge.halfedge = null;

    Edge.data = null;

    Edge.id = null;

    Edge._iterator = null;

    return Edge;

  })();

  SCRIB.Halfedge = (function() {
    function Halfedge() {
      this.twin = null;
      this.next = null;
      this.prev = null;
      this.face = null;
      this.edge = null;
      this.vertex = null;
      this.data = null;
      this.id = null;
      this._iterator = null;
    }

    return Halfedge;

  })();

}).call(this);
