/*! Scribble JS, a project by Bryce Summers.
 *  Single File concatenated by Grunt Concatenate on 25-01-2017
 */
/*
 * Defines namespaces.
 * Adapted by Bryce Summers on 12 - 30 - 2016.
 */

// Bryce Data Structures.
SCRIB = {};
// Generated by CoffeeScript 1.11.1

/*
    Polyline Graph Associated Data classes.

    Adapted by Bryce Summers on 1 - 3 - 2017.

    Purpose: These classes provide application specific associated data structures that are linked into HalfedgeGraph elements.

    They will be used for algorithms on planar graph embeddings from polyline inputs.
 */

(function() {
  SCRIB.Graph_Data = (function() {
    function Graph_Data(graph) {
      this.graph = graph;
    }

    Graph_Data.prototype.clearFaceMarks = function() {
      var iter, results;
      iter = this.graph.facesBegin();
      results = [];
      while (iter.hasNext()) {
        results.push(iter.next().data.marked = false);
      }
      return results;
    };

    Graph_Data.prototype.clearVertexMarks = function() {
      var iter, results;
      iter = this.graph.verticesBegin();
      results = [];
      while (iter.hasNext()) {
        results.push(iter.next().data.marked = false);
      }
      return results;
    };

    Graph_Data.prototype.clearEdgeMarks = function() {
      var iter, results;
      iter = this.graph.edgesBegin();
      results = [];
      while (iter.hasNext()) {
        results.push(iter.next().data.marked = false);
      }
      return results;
    };

    Graph_Data.prototype.clearHalfedgeMarks = function() {
      var iter, results;
      iter = this.graph.halfedgesBegin();
      results = [];
      while (iter.hasNext()) {
        results.push(iter.next().data.marked = false);
      }
      return results;
    };

    Graph_Data.prototype.clearMarks = function() {
      this.clearFaceMarks();
      this.clearVertexMarks();
      this.clearEdgeMarks();
      return this.clearHalfedgeMarks();
    };

    return Graph_Data;

  })();

  SCRIB.Face_Data = (function() {
    function Face_Data(face) {
      var hole_representatives;
      this.face = face;
      this.marked = false;
      hole_representatives = [];
      this.info = null;
    }

    Face_Data.prototype.addHole = function(hole) {
      return hole_representatives.push(hole);
    };


    /*
    // The area of the face is determined by the intersection this face with all of the hole faces,
    // which will be specified by exterior facing edge that enclose an infinite complemented area.
     */

    return Face_Data;

  })();

  SCRIB.Vertex_Data = (function() {
    function Vertex_Data(vertex) {
      this.vertex = vertex;
      this.point = null;
      this.marked = false;
      this.tail_point = false;
      this.intersection_point = false;
      this.singleton_point = false;

      /*
       * Used as a temporary structure for graph construction, but it is also may be relevant to users.
       * I don't know whether I will maintain this structure outside of graph construction.
       * FIXME: I might switch this to being a pointer to allow for me to null it out when no longer needed.
       * SCRIB.Halfedge[]
       */
      this.outgoing_edges = [];
      this.info = null;
    }

    Vertex_Data.prototype.isExtraordinary = function() {
      return this.tail_point || this.intersection_point;
    };

    return Vertex_Data;

  })();

  SCRIB.Edge_Data = (function() {
    function Edge_Data(edge) {
      this.edge = edge;
      this.marked = false;
      this.info = null;
    }

    return Edge_Data;

  })();

  SCRIB.Halfedge_Data = (function() {
    function Halfedge_Data(halfedge) {
      this.halfedge = halfedge;
      this.marked = false;
      this.next_extraordinary = null;
      this.info = null;
    }

    Halfedge_Data.prototype.isExtraordinary = function() {
      return this.halfedge.vertex.data.isExtraordinary();
    };

    return Halfedge_Data;

  })();

}).call(this);

// Generated by CoffeeScript 1.11.1

/*
* Transforms a set of input polylines into a planar graph embedding.
*
* Written by Bryce Summers.
*
* 8/16/2016: Written as a more fully advanced version of FaceFinder.h,
*            which outputs sophisticated graph structures oozing with useful connectivity information.
* 1/4/2017:  Ported to Coffeescript.
*
* Original C++ code written for the STUDIO for Creative Inquiry at Carnegie Mellon University.
 */


/*
* These algorithms include:
* Preprocessing:
* [EMPTY]
*
* Main Algorithm:
* 1. The main algorithm for embedding a set of polylines in space and determining the set of non chordal cycles in the
*    associated embedded planar graph.
*
* - A polygon is closed if it has identical starting and ending points and open otherwise.
*   The algorithm may be configured to output either open or closed polygons based on the closed_loop mode state.
*
* FIXME: If a user draws a second line completely around an original line, then their will be faces defined by both an external
*        face on the original polyline embedding and an internal face on the new enclosing embedding.
*        This may invalidate some users' assumptions of a global planar graph embedding without any holes.
*
* Post Processing:
* 1. Determine internal and external faces. (Initial Release)
* 2. Determine trivial and non trivial area faces according to a constant area threshold value. (8/11/2016)
*    (If you can't think of any good constant values, you might want to look at the field of
*     Topological Data Analysis and their 'barcode' concept: https://en.wikipedia.org/wiki/Topological_data_analysis.
* 3. Clipping off tails, i.e. portions of faces that enclose 0 area. (8/11/2016)
*    This could potentially be put into the getCycle function, but I think that it is best to make this a dedicated post processing step instead
*    in order to preserve the simplicity of the main algorithm.
*    This algorithm properly handles faces with either duplicated or non-duplicated starting and ending points.
*    i.e. Those produced in open and closed mode.
 */


/*
// FIXME: Write a list of all of the relevant interesting properties of the my planar embedding implementation.
// Edges always point to the forward facing halfedge.
// forward facing half edges are consecutively ordered in the first half.
// backwards facing half edges are consecutively ordered in the reverse order of the first half.
 */

(function() {
  SCRIB.PolylineGraphEmbedder = (function() {

    /*
    A User can explicitly pass false to force the intersection points to be found using a brute force algorithm that
    may potentially be more robust and reliable than the optimized intersection algorithm,
    but it kills the performance.
     */
    function PolylineGraphEmbedder(_useFastAlgo) {
      this._useFastAlgo = _useFastAlgo;
      if (this._useFastAlgo === void 0) {
        this._useFastAlgo = true;
      }
      this._points = [];
      this._lines_initial = [];
      this._lines_split = [];

      /*
      // The graph that is being built.
      // Once it is returned, the responsibility for this memory transfers to the user and the pointer is forgotten from this class.
       * FIXME: Should this graph embedded remember this guy?
       */
      this._graph = null;
    }


    /*
    Derives a planar graph embedding from the given input polyline.
    Assumes all points are distinct.
     */

    PolylineGraphEmbedder.prototype.embedPolyline = function(input) {
      if (input.size() <= 1) {
        return this._trivial(input);
      }
      this._loadPolyline(input);
      return this._do_the_rest();
    };


    /*
     * Derive faces from a set list of vertex disjoint polyline inputs.
     * Note: Each individual polyline specifies properties such as being closed or not.
     * Polyline[] (An array of polylines) -> SCRIB.Graph
     */

    PolylineGraphEmbedder.prototype.embedPolylineArray = function(inputs) {
      var e, j, len, len1;
      len = inputs.length;
      for (j = 0, len1 = inputs.length; j < len1; j++) {
        e = inputs[j];
        this._loadPolyline(e);
      }
      return this._do_the_rest();
    };

    PolylineGraphEmbedder.prototype._trivial = function(polyline) {
      var edge, exterior, exterior_data, graph, halfedge, interior, interior_data, twin, vertex, vertex_data;
      graph = this._newGraph();
      if (polyline.size() < 1) {
        return graph;
      }

      /*
      We construct one of each element for the singleton graph.
      NOTE: This allocation is a wrapper on top of the Graph allocation function, which allocates its Vertex_Data object.
      the other functions this->new[ ____ ] work in the same way.
       */
      vertex = this._newVertex();
      vertex_data = vertex.data;
      edge = this._newEdge();
      interior = this._newFace();
      exterior = this._newFace();
      interior_data = interior.data;
      exterior_data = exterior.data;
      halfedge = this._newHalfedge();
      twin = this._newHalfedge();
      vertex_data.point = polyline.getPoint(0);
      vertex.halfedge = halfedge;
      edge.halfedge = halfedge;
      interior.halfedge = halfedge;
      interior_data.addHole(exterior);
      exterior.halfedge = halfedge;
      halfedge.edge = edge;
      halfedge.face = exterior;
      halfedge.next = halfedge;
      halfedge.prev = halfedge;
      halfedge.twin = twin;
      halfedge.vertex = vertex;
      twin.edge = edge;
      twin.face = interior;
      twin.next = twin;
      twin.prev = twin;
      twin.twin = halfedge;
      twin.vertex = vertex;
      return graph;
    };

    PolylineGraphEmbedder.prototype._do_the_rest = function() {
      var output;
      this._splitIntersectionPoints();
      this._allocate_graph_from_input();
      this._sort_outgoing_edges_by_angle();
      this._associate_halfedge_cycles();
      output = this._deriveFaces();
      output.delete_index_arrays();
      this._cleanup();
      return output;
    };


    /*
    The embedding is broken down into seperate phases. Here I have listed each operation,
    followed by the data structures that they have built.
    
    Appends the given input points to the collated single input point array.
    Performs point fudging to avoid degenerate behavior.
    Starts up the indexed collection of points.
    SCRIB.Polyline -> ()
     */


    /*
    New Constructed data Fields:
    //The canonical collection of points at their proper indices.
    BDS.Point[] @_points
    // The original input lines.
    SCRIB.Line[] @_lines_initial
     */

    PolylineGraphEmbedder.prototype._loadPolyline = function(polyline) {
      var i, input_point, j, k, len, offset, ref, ref1;
      len = polyline.size();
      offset = this._points.length;
      for (i = j = 0, ref = len; j < ref; i = j += 1) {
        input_point = polyline.getPoint(i);
        if ((offset > 0 || i > 0) && this._points[offset + i - 1].x === input_point.x) {
          input_point.x += .001;
        }
        if (isNaN(input_point.x)) {
          debugger;
        }
        this._points.push(input_point);
      }
      for (i = k = 0, ref1 = len - 1; k < ref1; i = k += 1) {
        this._lines_initial.push(new BDS.Line(i + offset, i + offset + 1, this._points));
      }

      /*
      Add a line connecting the first and last points on the original set of input points if
      the polyline is closed.
      In other words put a duplicate copy of the initial point.
       */
      if (polyline.isClosed()) {
        this._lines_initial.push(new BDS.Line(len - 1 + offset, 0 + offset, this._points));
      }
    };


    /*
    Intersects the input lines, then splits them and connects them appropiatly.
    Populates the list of edge disjoint lines that only intersect at vertices.
    puts the edge in consecutive order following the input polylines.
    results put into this.lines_split
    () -> ()
     */


    /*
    New Constructed data Field:
    Split version of original input lines, where lines only intersect at vertices.
    SCRIB.Line[] @_lines_split
     */

    PolylineGraphEmbedder.prototype._splitIntersectionPoints = function() {
      var i, intersector, j, line, numLines, ref;
      intersector = new BDS.Intersector();
      if (this._useFastAlgo) {
        intersector.intersectLineSegments(this._lines_initial);
      } else {
        intersector.intersect_brute_force(this._lines_initial);
      }
      numLines = this._lines_initial.length;
      for (i = j = 0, ref = numLines; j < ref; i = j += 1) {
        line = this._lines_initial[i];
        line.getSplitLines(this._lines_split);
      }
    };


    /*
    #-- Step 3. Proccess the embedded input and initialize the Planar Graph vertices, edges, and halfedges.
    Allocates the output graph object and allocates vertices, edges, and halfedges for the input data.
    Vertices are Indexed as follows [original points 1 for input polyline 1, then 2, ...,
    new intersection points for polyline 1, then 2, etc, ...]
    Halfedges are indexed in polyline input order, then in backwards input order.
    () -> ()
     */


    /*
    New Constructed data Field:
    The graph that is being built and will eventually be returned to the user.
    SCRIB.Graph @_graph
     */

    PolylineGraphEmbedder.prototype._allocate_graph_from_input = function() {
      var e, edge, edge_ID, halfedge, halfedge_ID, i, j, k, l, last_backwards_halfedge, last_forwards_halfedge, last_index, len, len1, len2, line, point, ref, ref1, ref2, twin, twin_ID, vert, vert_data, vert_twin, vert_twin_data, vertex_ID, vertex_twin_ID;
      this._graph = this._newGraph();
      ref = this._points;
      for (j = 0, len1 = ref.length; j < len1; j++) {
        point = ref[j];
        vert = this._newVertex();
        vert_data = vert.data;
        vert.halfedge = null;
        vert_data.point = point;
      }
      ref1 = this._lines_split;
      for (k = 0, len2 = ref1.length; k < len2; k++) {
        e = ref1[k];
        this._newHalfedge();
        this._newHalfedge();
        this._newEdge();
      }

      /*
      Associate edges <-> halfedges.
            halfedges <-> twin halfedges.
            halfedges <-> vertices.
       */
      last_forwards_halfedge = null;
      last_backwards_halfedge = null;
      len = this._lines_split.length;
      last_index = len * 2 - 1;
      for (i = l = 0, ref2 = len; l < ref2; i = l += 1) {
        line = this._lines_split[i];
        vertex_ID = line.p1_index;
        vertex_twin_ID = line.p2_index;
        edge_ID = i;
        halfedge_ID = i;
        twin_ID = last_index - i;
        edge = this._graph.getEdge(edge_ID);
        halfedge = this._graph.getHalfedge(halfedge_ID);
        twin = this._graph.getHalfedge(twin_ID);
        vert = this._graph.getVertex(vertex_ID);
        vert_twin = this._graph.getVertex(vertex_twin_ID);
        vert_data = vert.data;
        vert_twin_data = vert_twin.data;
        edge.halfedge = halfedge;
        halfedge.edge = edge;
        twin.edge = edge;
        halfedge.twin = twin;
        twin.twin = halfedge;
        halfedge.vertex = vert;
        twin.vertex = vert_twin;
        if (vert.halfedge === null) {
          vert.halfedge = halfedge;
        }
        if (vert_twin.halfedge === null) {
          vert_twin.halfedge = twin;
        }
        if (halfedge === void 0 || twin === void 0) {
          debugger;
        }
        vert_data.outgoing_edges.push(halfedge);
        vert_twin_data.outgoing_edges.push(twin);
      }
    };

    PolylineGraphEmbedder.prototype._sort_outgoing_edges_by_angle = function() {
      var iter, outgoing_edges, vert_data;
      iter = this._graph.verticesBegin();
      while (iter.hasNext()) {
        vert_data = iter.next().data;
        outgoing_edges = vert_data.outgoing_edges;
        this._sort_outgoing_edges(outgoing_edges);
      }
    };

    PolylineGraphEmbedder.prototype._sort_outgoing_edges = function(outgoing_edges) {
      var angle, angles, center_data, center_point, center_vert, edge, hedge_in, hedge_out, i, i1, i2, j, k, l, len, len1, outer_data, outer_point, outer_vert, outgoing_halfedge_representative, ref, ref1, temp_f, temp_he;
      len = outgoing_edges.length;
      if (len <= 2) {
        return;
      }
      angles = [];
      outgoing_halfedge_representative = outgoing_edges[0];
      center_vert = outgoing_halfedge_representative.vertex;
      center_data = center_vert.data;
      center_point = center_data.point;
      for (j = 0, len1 = outgoing_edges.length; j < len1; j++) {
        edge = outgoing_edges[j];
        hedge_out = edge;
        hedge_in = hedge_out.twin;
        outer_vert = hedge_in.vertex;
        outer_data = outer_vert.data;
        outer_point = outer_data.point;
        angle = Math.atan2(outer_point.y - center_point.y, outer_point.x - center_point.x);
        angles.push(angle);
      }
      for (i = k = 0, ref = len; k < ref; i = k += 1) {
        for (i2 = l = ref1 = i - 1; l >= 0; i2 = l += -1) {
          i1 = i2 + 1;
          if (angles[i2] <= angles[i1]) {
            break;
          }
          temp_f = angles[i2];
          angles[i2] = angles[i1];
          angles[i1] = temp_f;
          temp_he = outgoing_edges[i2];
          outgoing_edges[i2] = outgoing_edges[i1];
          outgoing_edges[i1] = temp_he;
          if (outgoing_edges[i1] === void 0 || outgoing_edges[i2] === void 0) {
            debugger;
          }
        }
      }
    };


    /*
     * -- Step 5.
    Determines the next and previous pointers for the halfedges in the Graph.
    This is done almost entirely using the sets of outgoing edges for each vertex.
    vertices of degree 2 associate their 2 pairs of neighbors.
    vertices of degree are on a tail and associate their one pair of neighbors.
    vertices of degree >2 are intersection points and they first sort their neighbors, then associate their star.
    This function sets the Vertex_Data objects classification data.
     * () -> ()
     */

    PolylineGraphEmbedder.prototype._associate_halfedge_cycles = function() {
      var degree, halfedge, hedge_in, hedge_out, i, iter, j, outgoing_edges, ref, vert, vert_data;
      iter = this._graph.verticesBegin();
      while (iter.hasNext()) {
        vert = iter.next();
        vert_data = vert.data;
        outgoing_edges = vert_data.outgoing_edges;
        degree = outgoing_edges.length;
        if (degree === 0) {
          vert_data.singleton_point = true;
          halfedge = vert.halfedge;
          halfedge.next = halfedge;
          halfedge.prev = halfedge;
          continue;
        }
        if (degree === 1) {
          vert_data.tail_point = true;
          hedge_out = vert.halfedge;
          hedge_in = hedge_out.twin;
          hedge_out.prev = hedge_in;
          hedge_in.next = hedge_out;
          continue;
        }
        if (degree > 2) {
          vert_data.intersection_point = true;
        }
        for (i = j = 0, ref = degree; j < ref; i = j += 1) {
          hedge_out = outgoing_edges[i];
          if (hedge_out === void 0 || hedge_out.twin === void 0) {
            debugger;
          }
          hedge_in = hedge_out.twin;
          hedge_in.next = outgoing_edges[(i + 1) % degree];
          hedge_out.prev = outgoing_edges[(i + degree - 1) % degree].twin;
        }
        continue;
      }
    };


    /*
     * Step 6.
     * Uses the vertex and edge complete halfedge mesh to add face data.
     * Also produces simpler cycle structures along that serve as an alternate representation of the faces.
     * () -> SCRIB.Graph
     */

    PolylineGraphEmbedder.prototype._deriveFaces = function() {
      var face, halfedge, halfedge_data, iter;
      iter = this._graph.halfedgesBegin();
      while (iter.hasNext()) {
        halfedge = iter.next();
        halfedge_data = halfedge.data;
        if (halfedge_data.marked) {
          continue;
        }
        face = this._newFace();
        face.halfedge = halfedge;
        this._trace_face(face);
      }
      this._graph.data.clearHalfedgeMarks();
      return this._graph;
    };


    /*
    REQUIRES: 1. face -> halfedge well defined already.
              2. halfedge next pointer well defined already.
    ENSURES:  links every halfedge in the loop starting and ending at face -> halfedge
              with the face.
     * SCRIB.Face -> ()
     */

    PolylineGraphEmbedder.prototype._trace_face = function(face) {
      var current, start;
      start = face.halfedge;
      current = start;
      while (true) {
        current.face = face;
        current.data.marked = true;
        current = current.next;
        if (current === start) {
          break;
        }
      }
    };


    /*
    Free all of the intermediary data structures.
    Clear input structures.
    Unmark the output.
     */

    PolylineGraphEmbedder.prototype._cleanup = function() {
      this._points = [];
      this._lines_initial = [];
      return this._lines_split = [];
    };

    PolylineGraphEmbedder.prototype._newGraph = function() {
      return SCRIB.PolylineGraphEmbedder.newGraph();
    };

    PolylineGraphEmbedder.prototype._newFace = function() {
      return SCRIB.PolylineGraphEmbedder.newFace(this._graph);
    };

    PolylineGraphEmbedder.prototype._newEdge = function() {
      return SCRIB.PolylineGraphEmbedder.newEdge(this._graph);
    };

    PolylineGraphEmbedder.prototype._newHalfedge = function() {
      return SCRIB.PolylineGraphEmbedder.newHalfedge(this._graph);
    };

    PolylineGraphEmbedder.prototype._newVertex = function() {
      return SCRIB.PolylineGraphEmbedder.newVertex(this._graph);
    };

    PolylineGraphEmbedder.newGraph = function() {
      var output;
      output = new SCRIB.Graph(true);
      output.data = new SCRIB.Graph_Data(output);
      return output;
    };

    PolylineGraphEmbedder.newFace = function(graph) {
      var output;
      output = graph.newFace();
      output.data = new SCRIB.Face_Data(output);
      return output;
    };

    PolylineGraphEmbedder.newEdge = function(graph) {
      var output;
      output = graph.newEdge();
      output.data = new SCRIB.Edge_Data(output);
      return output;
    };

    PolylineGraphEmbedder.newHalfedge = function(graph) {
      var output;
      output = graph.newHalfedge();
      output.data = new SCRIB.Halfedge_Data(output);
      return output;
    };

    PolylineGraphEmbedder.newVertex = function(graph) {
      var output;
      output = graph.newVertex();
      output.data = new SCRIB.Vertex_Data(output);
      return output;
    };

    return PolylineGraphEmbedder;

  })();

}).call(this);

// Generated by CoffeeScript 1.11.1

/*
The PolylineGraphPostProcessor class.
*
* Written and adapted from FaceFinder on 8/18/2016.
* Ported to Coffeescript on 1 - 4 - 2017.
*
* Purpose:
*
* Allows users to convert Planar Polyline Embedded Graphs into mainstream C++ data structures.
* This class then provides some useful processing algorithms on these output structures.
*
* I may also put information extraction algorithms here.
*
* The key idea is that the post processor doesn't mutate the Graph object in any way.
* FIXME: Use the Graph Mutator Proccessor instead (Currenly non existant.) if you wish to modify the graph.
*
* Maybe I will make a modification mode.
 */


/*

Tested Features:
    convert_to_face_infos()

Untested Features:
    clipTails()
    mergeFaces()
    BDS.BVH2D = generateBVH() [requires HalfedgeMesh]

     * Splits the current embedding by the given polyline.
    embedAnotherPolyline(polyLine)
    eraseEdgesInCircle()
 */

(function() {
  SCRIB.Verex_Info = (function() {
    function Verex_Info(vertex1) {
      this.vertex = vertex1;
      this.id = this.vertex.id;
      this.vertex.data.info = this;
    }

    return Verex_Info;

  })();

  SCRIB.Edge_Info = (function() {
    function Edge_Info(edge1) {
      this.edge = edge1;
      this.id = this.edge.id;
      this.edge.data.info = this;
    }

    return Edge_Info;

  })();

  SCRIB.Halfedge_Info = (function() {

    /*
     * Represents and points to a halfedge. Its pointers may not be valid after algorithms such as tail clipping.
    // Faces and twin pointers should still be valid though...
     * @halfedge is only defined for HalfedgeGraph based souce embeddings.
     * Also contains a pointer to its face_info object.
     */
    function Halfedge_Info(halfedge3) {
      var next_data, next_point, next_vert, vert, vert_data;
      this.halfedge = halfedge3;
      this.halfedge.data.info = this;
      vert = this.halfedge.vertex;
      vert_data = vert.data;
      this.point = vert_data.point;
      this.id = this.halfedge.id;
      this.polyline = new BDS.Polyline(false);
      this.polyline.addPoint(this.point);
      this.polyline.setAssociatedData(this);
      next_vert = this.halfedge.next.vertex;
      next_data = next_vert.data;
      next_point = next_data.point;
      this.polyline.addPoint(next_point);
    }

    return Halfedge_Info;

  })();

  SCRIB.Face_Info = (function() {
    function Face_Info(face) {
      this.generateInfoFromFace(face);
    }

    Face_Info.prototype.generateInfoFromFace = function(face) {
      var current, halfedge_info, starting_half_edge;
      if (face === void 0) {
        face = this.face;
      } else {
        this.face = face;
      }
      this.face.data.info = this;
      this.holes = [];
      this.halfedges = [];
      this._halfedge_bvh = null;
      this.polyline = new BDS.Polyline(true);
      this.polyline.setAssociatedData(this);
      this.faces_id_set = new Set();
      this.faces_id_set.add(face.id);
      this.id = face.id;
      starting_half_edge = face.halfedge;
      current = starting_half_edge;
      while (true) {
        halfedge_info = new SCRIB.Halfedge_Info(current);
        this.push(halfedge_info);
        current = current.next;
        if (starting_half_edge === current) {
          break;
        }
      }
      this.complemented = this.polyline.isComplemented();
    };

    Face_Info.prototype.size = function() {
      return this.points.length;
    };

    Face_Info.prototype.isClosed = function() {
      return polyline.isClosed();
    };

    Face_Info.prototype.getLastPointInfo = function() {
      return this.points[this.points.length - 1];
    };

    Face_Info.prototype.push = function(halfedge_info) {
      this.halfedges.push(halfedge_info);
      return this.polyline.addPoint(halfedge_info.point);
    };

    Face_Info.prototype.pop = function() {
      this.polyline.removeLastPoint();
      return this.points.pop();
    };

    Face_Info.prototype.at = function(index) {
      return this.points[index];
    };

    Face_Info.prototype.isComplemented = function() {
      return this.polyline.isComplemented();
    };

    Face_Info.prototype.isExterior = function() {
      return this.isComplemented();
    };

    Face_Info.prototype.generateBVH = function() {
      var halfedge, i, j, len, line, ref, segments;
      segments = this.polyline.toPolylineSegments();
      len = segments.length;
      for (i = j = 0, ref = len; j < ref; i = j += 1) {
        line = segments[i];
        halfedge = this.halfedges[i];
        line.setAssociatedData(halfedge);
      }
      this._halfedge_bvh = new BDS.BVH2D(segments);
      return this._halfedge_bvh;
    };


    /*
    Edge Intersection functions.
    Returns all edges within this face that are also within the given geometries.
     */

    Face_Info.prototype.query_halfedges_in_circle = function(circle, output) {
      return this.query_halfedges_in_geometry(circle, output);
    };

    Face_Info.prototype.query_halfedges_in_polyline = function(polyline, output) {
      return this.query_halfedges_in_geometry(polyline, output);
    };

    Face_Info.prototype.query_halfedges_in_geometry = function(geom, output) {
      var all_halfedges, halfedge, j, len1, polyline;
      all_halfedges = this.query_halfedges_in_box(geom.generateBoundingBox());
      for (j = 0, len1 = all_halfedges.length; j < len1; j++) {
        halfedge = all_halfedges[j];
        polyline = halfedge.polyline;
        if (geom.detect_intersection_with_polyline(polyline)) {
          output.push(halfedge);
        }
      }
      return output;
    };

    Face_Info.prototype.query_halfedges_in_box = function(box, output_list) {
      var j, len1, line, polylines;
      if (this._halfedge_bvh === null) {
        this.generateBVH();
      }
      if (output_list === void 0) {
        output_list = [];
      }
      polylines = this._halfedge_bvh.query_box_all(box);
      for (j = 0, len1 = polylines.length; j < len1; j++) {
        line = polylines[j];
        output_list.push(line.getAssociatedData());
      }
      return output_list;
    };

    return Face_Info;

  })();

  SCRIB.PolylineGraphPostProcessor = (function() {
    function PolylineGraphPostProcessor(_graph) {
      this._graph = _graph;
      this._graph = null;
      this._face_vector = [];
      this._face_bvh = null;
    }

    PolylineGraphPostProcessor.prototype.generate_faces_info = function() {
      var face, face_output, iter, next_old_face, next_old_index, old_faces, result;
      old_faces = this._face_vector;
      next_old_index = 0;
      next_old_face = null;
      if (old_faces.length > 0) {
        next_old_face = old_faces[next_old_index];
        next_old_index++;
      }
      this._face_vector = [];
      iter = this._graph.facesBegin();
      while (iter.hasNext()) {
        face = iter.next();
        while (next_old_face !== null && next_old_face.id < face.id) {
          if (this._face_bvh !== null) {
            result = this._face_bvh.remove(next_old_face.polyline);
            if (!result) {
              debugger;
            }
          }
          if (next_old_index < old_faces.length) {
            next_old_face = old_faces[next_old_index];
            next_old_index++;
          } else {
            next_old_face = null;
          }
        }
        if (next_old_face !== null && next_old_face.id === face.id) {
          this._face_vector.push(next_old_face);
          if (next_old_face.face.data.marked) {
            next_old_face.face.data.marked = false;
            this._face_bvh.remove(face_info.polyline);
            next_old_face.generateInfoFromFace();
            next_old_face.generateBVH();
            this._face_bvh.add(face_info.polyline);
          }
          if (next_old_index < old_faces.length) {
            next_old_face = old_faces[next_old_index];
            next_old_index++;
          } else {
            next_old_face = null;
          }
          continue;
        }
        face_output = new SCRIB.Face_Info(face);
        this._face_vector.push(face_output);
        if (this._face_bvh !== null) {
          this._face_bvh.add(face_output.polyline);
        }
        continue;
      }
      while (next_old_face !== null) {
        if (this._face_bvh !== null) {
          result = this._face_bvh.remove(next_old_face.polyline);
          if (next_old_index < old_faces.length) {
            next_old_face = old_faces[next_old_index];
            next_old_index++;
          } else {
            next_old_face = null;
          }
        }
      }
      if (this._face_bvh !== null) {
        this._face_bvh.optimize();
      }
      return this._face_vector;
    };

    PolylineGraphPostProcessor.prototype.generate_faces_info = function() {
      var face, face_output, iter;
      this._face_vector = [];
      iter = this._graph.facesBegin();
      while (iter.hasNext()) {
        face = iter.next();
        face_output = new SCRIB.Face_Info(face);
        this._face_vector.push(face_output);
      }
      this.generateBVH();
      return this._face_vector;
    };

    PolylineGraphPostProcessor.prototype.generate_faces_info = function() {
      var face, face_info, iter, old_faces, old_faces_index, ref, result;
      old_faces = this._face_vector;
      old_faces_index = 0;
      this._face_vector = [];
      iter = this._graph.facesBegin();
      while (iter.hasNext()) {
        face = iter.next();
        ref = this._nextFaceInfo(face, old_faces, old_faces_index), face_info = ref[0], old_faces_index = ref[1];
        if (face_info === null) {
          face_info = new SCRIB.Face_Info(face);
          face_info.face.data.marked = true;
        }
        this._proccessFaceInfo(face_info);
        this._face_vector.push(face_info);
      }
      if (this._face_bvh !== null) {
        while (old_faces_index < old_faces.length) {
          face_info = old_faces[old_faces_index];
          result = this._face_bvh.remove(face_info.polyline);
          if (result === false) {
            debugger;
          }
          old_faces_index++;
        }
      }
      if (this._face_bvh !== null) {
        this._face_bvh.optimize();
      }
      return this._face_vector;
    };

    PolylineGraphPostProcessor.prototype._nextFaceInfo = function(face, faces, min_index) {
      var face_info, result, target_id;
      target_id = face.id;
      while (min_index < faces.length) {
        face_info = faces[min_index];
        if (face_info.id === target_id) {
          return [face_info, min_index + 1];
        }
        if (face_info.id > target_id) {
          return [null, min_index];
        }
        min_index++;
        if (this._face_bvh !== null) {
          result = this._face_bvh.remove(face_info.polyline);
          if (!result) {
            debugger;
          }
        }
      }
      return [null, min_index];
    };

    PolylineGraphPostProcessor.prototype._proccessFaceInfo = function(face_info) {
      if (this._face_bvh !== null && face_info.face.data.marked === true) {
        this._face_bvh.remove(face_info.polyline);
        face_info.generateInfoFromFace();
        this._face_bvh.add(face_info.polyline);
        return face_info.face.data.marked = false;
      }
    };

    PolylineGraphPostProcessor.prototype.get_current_faces_info = function() {
      return this._face_vector;
    };

    PolylineGraphPostProcessor.prototype.load_graph = function(_graph) {
      this._graph = _graph;
      this._face_vector = [];
      return this._face_bvh = null;
    };

    PolylineGraphPostProcessor.prototype.free_face_vector = function() {
      return this._face_vector = null;
    };

    PolylineGraphPostProcessor.prototype.free_graph = function() {
      return this._graph = null;
    };


    /*
    Appends the indices of any external faces amongst the input list of faces to the output vector.
    NOTE : The input type is equivelant to the output type of the face finding functions,
    so using this function may be a natural extension of using the original functions.
     * int[] -> () [appends complemented faces to input]
     */

    PolylineGraphPostProcessor.prototype.determineComplementedFaces = function(output) {
      var area, face_info, index, j, len, ref;
      len = this._face_vector.length;
      for (index = j = 0, ref = len; 0 <= ref ? j < ref : j > ref; index = 0 <= ref ? ++j : --j) {
        face_info = this._face_vector[index];
        area = face_info.polyline.computeAreaOfPolygon();
        if (area > 0) {
          output.push(index);
        }
      }
    };

    PolylineGraphPostProcessor.prototype.determineNonTrivialAreaFaces = function(output, min_area) {
      var area, face_info, index, j, len, ref;
      len = this._face_vector.length;
      for (index = j = 0, ref = len; 0 <= ref ? j < ref : j > ref; index = 0 <= ref ? ++j : --j) {
        face_info = this._face_vector[index];
        area = face_info.polyline.computeAreaOfPolygon();
        area = area >= 0 ? area : -area;
        if (area >= min_area) {
          output.push(index);
        }
      }
    };

    PolylineGraphPostProcessor.prototype.determineTrivialAreaFaces = function(output, min_area) {
      var area, face_info, index, j, len, ref;
      len = this._face_vector.length;
      for (index = j = 0, ref = len; 0 <= ref ? j < ref : j > ref; index = 0 <= ref ? ++j : --j) {
        face_info = this._face_vector[index];
        area = face_info.polyline.computeAreaOfPolygon();
        area = area >= 0 ? area : -area;
        if (area < min_area) {
          output.push(index);
        }
      }
    };


    /*
    Input: a set of faces, Output: a new set of faces that have no trivial contiguous subfaces.
    clips all of the polylines currently loaded in this post processor.
    ENSURES: Polygons will be output either open or closed in the manner that they are passed in.
    ENSURES: Omits faces consisting of only a single long tail.
    The user is still responsible to deallocating the original vector.
     * () -> face_info[] (with no tails)
     */

    PolylineGraphPostProcessor.prototype.clipAllTails = function() {
      var clipped_face, index, input, j, len, output, ref, unclipped_face;
      input = this._face_vector;
      output = [];
      len = input(function() {
        return size();
      });
      for (index = j = 0, ref = len; 0 <= ref ? j < ref : j > ref; index = 0 <= ref ? ++j : --j) {
        unclipped_face = input[index];
        clipped_face = this._clipTails(unclipped_face);
        if (clipped_face.size() > 0) {
          output.push(clipped_face);
        }
      }
      return output;
    };

    PolylineGraphPostProcessor.prototype._clipTails = function(input) {
      var clipped_previous, i, j, len, non_empty_output, output, p_end, p_next, p_previous, p_start, prune_num, ref;
      output = new SCRIB.Face_Info();
      len = input(function() {
        return size();
      });
      if (len < 3 || !input.isClosed()) {
        return output;
      }
      p_start = (input(function() {
        return at(0);
      })).ID;
      p_end = (input(function() {
        return at(len - 1);
      })).ID;

      /*
      The main idea behind tail clipping is to transform regions of the form ABA --> A,
      in other words removing any consecutive pairs of half edges cooresponding to the same full edge.
      We therefore
       */
      clipped_previous = false;
      non_empty_output = false;
      for (i = j = 0, ref = len; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
        p_previous = 0/0;
        non_empty_output = output.size() > 0;
        if (non_empty_output) {
          p_previous = output.getLastPointInfo().ID;
        } else {
          p_previous = input.points[len - 1].ID;
        }
        p_next = input.points[(i + 1) % len].ID;
        if (p_previous !== p_next) {
          output.push(input.at(i % len));
          clipped_previous = false;
          continue;
        }
        clipped_previous = true;
        if (non_empty_output) {
          output.pop();
        } else {
          len -= 1;
        }

        /*
        Don't add the current point, because we prune it as well.
        If p_next ends up now being a non tail point, it will be successfully added during the next iteration.
        We don't add it now, because we want to give it the opportunity to pruned by its next neighbor.
         */
        continue;
      }
      prune_num = 0;
      while (clipped_previous) {
        len = output.size();
        if (len < 3) {
          return output;
        }
        p_previous = (output.at(len - 1)).ID;
        p_next = (output.at(prune_num + 1)).ID;
        if (p_previous !== p_next) {
          break;
        }
        prune_num += 1;
        output.pop();
        continue;
      }
      if (clipped_previous) {
        output.splice(0, prune_num);
      }
      return output;
    };


    /*
    Uses the currently loaded this->graph object as Input.
    Takes in a vector containing the integer IDs of the faces to be merged.
    Takes a dictionary containing integers and outputs a set of faces representing the merge.
    Outputs the result of unioning all of the faces.
    Set -> SCRIB.FaceInfo[]
     */

    PolylineGraphPostProcessor.prototype.mergeFaces = function(face_ID_set) {
      var current, face, face_info, faces_complemented, faces_uncomplemented, id, j, k, l, len1, len2, len3, len4, m, map, output, set, start, uncomplemented_face;
      faces_uncomplemented = [];
      faces_complemented = [];
      for (j = 0, len1 = face_ID_Set.length; j < len1; j++) {
        id = face_ID_Set[j];
        Face * (face = graph.getFace(id));
        Halfedge * (start = face.halfedge);
        Halfedge * (current = face.halfedge);
        while (true) {
          if (current.data.marked === false && this._halfedgeInUnion(face_ID_set, current)) {
            face_info = this._traceUnionFace(face_ID_set, current);
            if (!face_info.isComplemented()) {
              face.complemented = false;
              faces_uncomplemented.push(face);
            } else {
              face.complemented = true;
              faces_complemented.push(face);
            }
          }
          current = current.next;
          if (current === start) {
            break;
          }
        }
        continue;
      }
      graph.data.clearHalfedgeMarks();
      output = [];
      map = {};
      for (k = 0, len2 = faces_uncomplemented.length; k < len2; k++) {
        face_info = faces_uncomplemented[k];
        output.push_back(face_info);
        set = face_info.faces_ID_set;
        for (l = 0, len3 = set.length; l < len3; l++) {
          id = set[l];
          map[id] = face;
        }
      }
      for (m = 0, len4 = faces_complemented.length; m < len4; m++) {
        face_info = faces_complemented[m];
        id = face_info.faces_id_set.keys().next().value;
        uncomplemented_face = map[id];
        if (!uncomplemented_face) {
          output.push(face);
          continue;
        }
        uncomplemented_face.holes.push_back(face_info);
      }
      return output;
    };


    /*
    Returns true iff the given hafedge is included in the output of the union of the given faces.
    I.E. returns true iff the given half edge -> face is within the set of unioned faces and half_edge->twin -> face is not.
    Tail edges, where the halfedge and its twin are on the same face are not considered to be in a halfedgeUnion face.
    Set, SCRIB.Halfedge -> bool.
     */

    PolylineGraphPostProcessor.prototype._halfedgeInUnion = function(face_id_set, start) {
      var face, face_found, face_id, twin_ID, twin_face, twin_face_found;
      face = start.face;
      face_id = face.id;
      face_found = face_id_set.has(face_id);
      twin_face = start.twin.face;
      twin_ID = twin_face(function() {
        return ID;
      });
      twin_face_found = face_Id_set.has(twin_ID);
      return face_found && !twin_face_found;
    };


    /*
    // Given an In Union halfege, traces its face_info union face information.
    // Properly sets the output's: points and face_IDs fields.
    // Marks halfedges, therefore calling functions are responsible for unmarking halfedges.
    Set, SCRIB.Halfedge -> SCRIB.Face_Info
     */

    PolylineGraphPostProcessor.prototype._traceUnionFace = function(face_ID_set, start) {
      var current, current_face_ID, current_point_info, output, output_ID_set;
      output = new SCRIB.Face_Info();
      output_ID_set = output.faces_ID_set;
      current = start;
      while (true) {
        current.data.marked = true;
        current_point_info = this._halfedgeToPointInfo(current);
        output.push(current_point);
        current_face_ID = current.face.ID;
        output_ID_set.add(current_face_ID);
        current = this._nextUnionFace(face_ID_set, current);
        if (current === start) {
          break;
        }
      }
      return output;
    };

    PolylineGraphPostProcessor.prototype._nextUnionFace = function(face_ID_Set, current) {
      current = current.twin.prev.twin;
      while (!this._halfedgeInUnion(face_ID_Set, current)) {
        current = current.prev.twin;
      }
      return current;
    };

    PolylineGraphPostProcessor.prototype._halfedgeToPointInfo = function(halfedge) {
      var vertex, vertex_data;
      vertex = halfedge.vertex;
      vertex_data = vertex.data;
      return new SCRIB.Point_Info(vertex_data.point, vertex.ID, halfedge);
    };

    PolylineGraphPostProcessor.prototype.generateBVH = function() {
      var polylines;
      polylines = this.facesToPolylines(this._face_vector, true);
      return this._face_bvh = new BDS.BVH2D(polylines);
    };

    PolylineGraphPostProcessor.prototype.facesToPolylines = function(face_infos, allow_complemented_faces) {
      var allow_compleemented_faces, face_info, j, len1, output, polyline;
      if (allow_complemented_faces === void 0) {
        allow_compleemented_faces = false;
      }
      output = [];
      for (j = 0, len1 = face_infos.length; j < len1; j++) {
        face_info = face_infos[j];
        polyline = face_info.polyline;
        if ((!polyline.isComplemented()) || allow_complemented_faces) {
          output.push(polyline);
        }
        continue;
      }
      return output;
    };

    PolylineGraphPostProcessor.prototype.polylinesToAssociatedData = function(polylines) {
      var j, len1, line, output;
      output = [];
      for (j = 0, len1 = polylines.length; j < len1; j++) {
        line = polylines[j];
        output.push(line.getAssociatedData());
      }
      return output;
    };

    PolylineGraphPostProcessor.prototype.embedAnotherPolyline = function(polyLine) {
      throw new Error("IMPLEMENT ME PLEASE!");
    };


    /*
     * Graph wide Edge Queries.
     * Returns all elements in the graph within the given regions.
     * NOTE: If you already have faces found, it will be better to use the Face_Info query functions.
     * Note: Edge queries are implemented by first performing a face query
     * and then perfomring edge queries on those face's edge bvh's in the Face_Info objects.
     */

    PolylineGraphPostProcessor.prototype.query_edges_in_circle = function(circle, output) {
      return this.query_edges_in_geometry(circle, output);
    };

    PolylineGraphPostProcessor.prototype.query_edges_in_polyline = function(polyline, output) {
      return this.query_edges_in_geometry(polyline, output);
    };

    PolylineGraphPostProcessor.prototype.query_edges_in_geometry = function(geom, output) {
      var edges, halfedge, j, len1, polyline;
      edges = this.query_halfedges_in_box(geom.generateBoundingBox());
      for (j = 0, len1 = edges.length; j < len1; j++) {
        halfedge = edges[j];
        polyline = halfedge.polyline;
        if (geom.detect_intersection_with_polyline(polyline)) {
          output.push(geom);
        }
      }
      return output;
    };

    PolylineGraphPostProcessor.prototype.query_halfedges_in_box = function(box, output) {
      var face, faces, j, len1;
      faces = this.query_faces_in_box(box);
      if (output === void 0) {
        output = [];
      }
      for (j = 0, len1 = faces.length; j < len1; j++) {
        face = faces[j];
        face.query_halfedges_in_box(box, output);
      }
      return output;
    };


    /*
     * Face Queries.
     * Returns elements within the face bvh in the given area regions.
     */

    PolylineGraphPostProcessor.prototype.query_faces_in_circle = function(circle) {
      return this.query_faces_in_geometry(circle);
    };

    PolylineGraphPostProcessor.prototype.query_faces_in_polyline = function(polyline) {
      return this.query_faces_in_geometry(polyline);
    };

    PolylineGraphPostProcessor.prototype.query_faces_in_geometry = function(geom) {
      var box, j, len1, output, polyline, polylines_in_box;
      box = geom.generateBoundingBox();
      polylines_in_box = this._face_bvh.query_box_all(box);
      output = [];
      for (j = 0, len1 = polylines_in_box.length; j < len1; j++) {
        polyline = polylines_in_box[j];
        if (geom.detect_intersection_with_polyline(polyline)) {
          output.push(polyline.getAssociatedData());
        }
      }
      return output;
    };

    PolylineGraphPostProcessor.prototype.query_faces_in_box = function(box) {
      return this.polylinesToAssociatedData(this._face_bvh.query_box_all(box));
    };

    PolylineGraphPostProcessor.prototype.halfedgesToEdges = function(halfedge_infos) {
      var edge, edge_info, halfedge, halfedge_info, id, j, len1, output, set;
      output = [];
      set = new Set();
      for (j = 0, len1 = halfedge_infos.length; j < len1; j++) {
        halfedge_info = halfedge_infos[j];
        halfedge = halfedge_info.halfedge;
        edge = halfedge.edge;
        id = edge.id;
        if (set.has(id)) {
          continue;
        }
        set.add(id);
        edge_info = new SCRIB.Edge_Info(edge);
        output.push(edge_info);
        continue;
      }
      return output;
    };


    /*
     * Element Deletion Methods.
     * These delete all Halfedge Mesh elements within a given region.
     * They then rebuild and preserve the invariants of the mesh.
     */

    PolylineGraphPostProcessor.prototype.eraseEdges = function(edge_infos, params) {
      var edge_info, j, len1;
      for (j = 0, len1 = edge_infos.length; j < len1; j++) {
        edge_info = edge_infos[j];
        this._eraseEdge(edge_info, params);
      }
      this.generate_faces_info();
    };

    PolylineGraphPostProcessor.prototype._eraseEdge = function(edge_info, params) {
      var degree1, degree2, edge, face, face1, face2, halfedge, halfedge1, halfedge2, halfedge_info, merge_faces, next, prev, split_faces, vert1, vert2;
      halfedge = edge_info.edge.halfedge;
      halfedge_info = halfedge.data.info;
      halfedge1 = halfedge_info.halfedge;
      halfedge2 = halfedge1.twin;
      edge = halfedge1.edge;
      vert1 = halfedge1.vertex;
      vert2 = halfedge2.vertex;
      degree1 = vert1.degree();
      degree2 = vert2.degree();
      face1 = halfedge1.face;
      face2 = halfedge2.face;
      merge_faces = face1 !== face2;
      face = null;
      if (merge_faces) {
        face = this._merge_faces(face1, face2);
      } else {
        face = face1;
      }
      if (degree1 === 1) {
        if (params.erase_lonely_vertices) {
          vert1.destroy();
        } else {
          vert1.make_lonely();
        }
      }
      if (degree2 === 1) {
        if (params.erase_lonely_vertices) {
          vert2.destroy();
        } else {
          vert2.make_lonely();
        }
      }
      if (degree1 === 1 && degree2 === 1) {
        face1.destroy();
        edge.destroy();
        halfedge1.destroy();
        halfedge2.destroy();
        return;
      }
      if (degree2 > 1) {
        next = halfedge1.next;
        prev = halfedge2.prev;
        next.prev = prev;
        prev.next = next;
        face.halfedge = next;
        vert2.halfedge = next;
      }
      if (degree1 > 1) {
        next = halfedge2.next;
        prev = halfedge1.prev;
        next.prev = prev;
        prev.next = next;
        face.halfedge = next;
        vert1.halfedge = next;
      }
      split_faces = !merge_faces && degree1 > 1 && degree2 > 1;
      if (split_faces) {
        this._split_face_at_edge(edge);
      }
      if (!split_faces && !merge_faces) {
        face.data.marked = true;
      }
      halfedge1.destroy();
      halfedge2.destroy();
      edge.destroy();
    };

    PolylineGraphPostProcessor.prototype._merge_faces = function(face1, face2) {
      var current, h0, halfedge1, halfedge2, new_face;
      new_face = SCRIB.PolylineGraphEmbedder.newFace(this._graph);
      halfedge1 = face1.halfedge;
      halfedge2 = face2.halfedge;
      h0 = halfedge1;
      current = h0;
      while (true) {
        current.face = new_face;
        current = current.next;
        if (current === h0) {
          break;
        }
      }
      h0 = halfedge2;
      current = h0;
      while (true) {
        current.face = new_face;
        current = current.next;
        if (current === h0) {
          break;
        }
      }
      new_face.halfedge = h0;
      face1.destroy();
      face2.destroy();
      return new_face;
    };

    PolylineGraphPostProcessor.prototype._split_face_at_edge = function(edge) {
      var current, face_new1, face_new2, face_old, halfedge1, halfedge2, next1, next2, start;
      halfedge1 = edge.halfedge;
      halfedge2 = halfedge1.twin;
      face_new1 = SCRIB.PolylineGraphEmbedder.newFace(this._graph);
      face_new2 = SCRIB.PolylineGraphEmbedder.newFace(this._graph);
      face_old = halfedge1.next.face;
      face_old.destroy();
      next1 = halfedge1.next;
      next2 = halfedge2.next;
      face_new1.halfedge = next1;
      face_new2.halfedge = next2;
      start = next1;
      current = start;
      while (true) {
        current.face = face_new1;
        current = current.next;
        if (current === start) {
          break;
        }
      }
      start = next2;
      current = start;
      while (true) {
        current.face = face_new2;
        current = current.next;
        if (current === start) {
          break;
        }
      }
      return [face_new1, face_new2];
    };

    return PolylineGraphPostProcessor;

  })();

}).call(this);

// Generated by CoffeeScript 1.11.1

/*
Halfedge Graph / Mesh class.
Written by Bryce Summers on 1 - 2 - 2017.
 */


/*
* FIXME: Writeup my modified usage, now that we are in javasccript.
*
* Usage:
*
* The Application programmer / New Media Artist specifies the following:
* 1. The data format they have availible for graph construction (e.g. vectors of openframeworks points.)
* 2. The Algorithms they need.
* 3. The data format that they wish to receive the results in.
*
* They will do so by specifying which class definitions they want.
*
* The algorithm designer / computational geometer specifies the following:
* 1. Definitions for the associated data.
* 2. The interface for constructing Graphs from application data
* 3. The interface for running algorithms on the Graphs.
* 4. The interface for allowing the application programmer to retrieve the results.
*
* If done elegantly, the New Media Artist should never need to touch the halfedge mesh, go on pointer journeys, and
* they should be able to treat the internal implementation as a black box.
 */


/*
 * -- Associated Data Classes.

#Since Javascript is untyped, these will mostly be her for convenience, and the user can insert the data they wish into each of these structures.

Every graph element will have a reserved variable called 'data' for linking to application specific information.

class SCRIB.Graph_Data
class SCRIB.Vertex_Data
class SCRIB.Face_Data
class SCRIB.Halfedge_Data
class SCRIB.Edge_Data
 */


/*
// FIXME: Clean up this prose.

// -- Structural definition of classes.
// Every class is specified by its connectivity information and a pointer to associated user data.

// All elements may be marked and unmarked by algorithms and users to specific sets of elements that meet various criteria.

// The Graph class represents an entire graph embedding defined by points in space.
// For the purposes of the facefinder, the output graph will be planar.
// connected via edges that intersect only at vertices.
// The FaceFinder class may be used to derive a Graph from a set of potentially intersecting input polylines.
 */

(function() {
  SCRIB.Graph = (function() {

    /*
    // Graph classes are where all of the actual data will be stored, so it contains vectors of valued data,
    // rather than pointers.
    // All ID's contained within these vectors will reference tha index of the object within these vectors.
    
    // Ideally, vertices, edges, and halfedges will be ordered logically according to the order they were input into the facefinder,
    // but I will need to do some more thinking on how to formally specify these things.
     */
    function Graph(_allocate_index_arrays) {
      this._allocate_index_arrays = _allocate_index_arrays;
      this._faces = new BDS.DoubleLinkedList();
      this._vertices = new BDS.DoubleLinkedList();
      this._edges = new BDS.DoubleLinkedList();
      this._halfedges = new BDS.DoubleLinkedList();
      this._next_face_id = 0;
      this._next_vertice_id = 0;
      this._next_edge_id = 0;
      this._next_halfedge_id = 0;
      if (this._allocate_index_arrays) {
        this._face_array = [];
        this._vertex_array = [];
        this._edge_array = [];
        this._halfedge_array = [];
      }
      this._data = null;
    }

    Graph.prototype.newFace = function() {
      var id, iter, output;
      id = this._next_face_id++;
      output = new SCRIB.Face();
      this._faces.push_back(output);
      if (this._face_array) {
        this._face_array.push(output);
      }
      output.id = id;
      iter = this._faces.end();
      iter.prev()._iterator = iter;
      return output;
    };

    Graph.prototype.newVertex = function() {
      var id, iter, output;
      id = this._next_vertice_id++;
      output = new SCRIB.Vertex();
      this._vertices.push_back(output);
      if (this._vertex_array) {
        this._vertex_array.push(output);
      }
      output.id = id;
      iter = this._vertices.end();
      iter.prev()._iterator = iter;
      return output;
    };

    Graph.prototype.newEdge = function() {
      var id, iter, output;
      id = this._next_edge_id++;
      output = new SCRIB.Edge();
      this._edges.push_back(output);
      if (this._edge_array) {
        this._edge_array.push(output);
      }
      output.id = id;
      iter = this._edges.end();
      iter.prev()._iterator = iter;
      return output;
    };

    Graph.prototype.newHalfedge = function() {
      var id, iter, output;
      id = this._next_halfedge_id++;
      output = new SCRIB.Halfedge();
      this._halfedges.push_back(output);
      if (this._halfedge_array) {
        this._halfedge_array.push(output);
      }
      output.id = id;
      iter = this._halfedges.end();
      iter.prev()._iterator = iter;
      return output;
    };

    Graph.prototype.deleteElement = function(e) {
      return e._iterator.remove();
    };

    Graph.prototype.getData = function() {
      return this._data;
    };

    Graph.prototype.numFaces = function() {
      return this._faces.size();
    };

    Graph.prototype.numVertices = function() {
      return this._vertices.size();
    };

    Graph.prototype.numEdges = function() {
      return this._edges.size();
    };

    Graph.prototype.numHalfedges = function() {
      return this._halfedges.size();
    };

    Graph.prototype.getFace = function(id) {
      return this._face_array[id];
    };

    Graph.prototype.getVertex = function(id) {
      return this._vertex_array[id];
    };

    Graph.prototype.getEdge = function(id) {
      return this._edge_array[id];
    };

    Graph.prototype.getHalfedge = function(id) {
      return this._halfedge_array[id];
    };

    Graph.prototype.delete_index_arrays = function() {
      delete this._face_array;
      delete this._vertex_array;
      delete this._edge_array;
      return delete this._halfedge_array;
    };


    /*
     - Iteration functions.
     - These all return BDS.DoubleListIterator's
     */

    Graph.prototype.facesBegin = function() {
      return this._faces.begin();
    };

    Graph.prototype.facesEnd = function() {
      return this._faces.end();
    };

    Graph.prototype.verticesBegin = function() {
      return this._vertices.begin();
    };

    Graph.prototype.verticesEnd = function() {
      return this._vertices.end();
    };

    Graph.prototype.edgesBegin = function() {
      return this._edges.begin();
    };

    Graph.prototype.edgesEnd = function() {
      return this._edges.end();
    };

    Graph.prototype.halfedgesBegin = function() {
      return this._halfedges.begin();
    };

    Graph.prototype.halfedgesEnd = function() {
      return this._halfedges.end();
    };

    return Graph;

  })();

  SCRIB.Face = (function() {
    function Face() {
      this.halfedge = null;
      this.data = new SCRIB.Face_Data();
      this.id = null;
      this._iterator = null;
    }

    Face.prototype.destroy = function() {
      return this._iterator.remove();
    };

    return Face;

  })();

  SCRIB.Vertex = (function() {
    function Vertex() {
      this.halfedge = null;
      this.data = null;
      this.id = null;
      this._iterator = null;
    }

    Vertex.prototype.destroy = function() {
      return this._iterator.remove();
    };

    Vertex.prototype.alone = function() {
      return this.halfedge === null;
    };

    Vertex.prototype.degree = function() {
      var count, current, start;
      start = this.halfedge;
      current = start.twin.next;
      count = 1;
      while (start !== current) {
        count++;
        current = current.twin.next;
        continue;
      }
      return count;
    };

    Vertex.prototype.make_lonely = function() {
      return this.halfedge = null;
    };

    return Vertex;

  })();

  SCRIB.Edge = (function() {
    function Edge() {}

    Edge.halfedge = null;

    Edge.data = null;

    Edge.id = null;

    Edge._iterator = null;

    Edge.prototype.destroy = function() {
      return this._iterator.remove();
    };

    return Edge;

  })();

  SCRIB.Halfedge = (function() {
    function Halfedge() {
      this.twin = null;
      this.next = null;
      this.prev = null;
      this.face = null;
      this.edge = null;
      this.vertex = null;
      this.data = null;
      this.id = null;
      this._iterator = null;
    }

    Halfedge.prototype.destroy = function() {
      return this._iterator.remove();
    };

    return Halfedge;

  })();

}).call(this);
