/*! Scribble JS, a project by Bryce Summers.
 *  Single File concatenated by Grunt Concatenate on 06-04-2017
 */
/*
 * Defines namespaces.
 * Adapted by Bryce Summers on 12 - 30 - 2016.
 */

// Bryce Data Structures.
SCRIB = {};



// Used for debugging.
// Prints, counts, and unit tests the halfedge graph.
// This should be called from the console.
SCRIB.printHalfedgeMesh = function(graph)
{
    if(graph === undefined)
    {
        graph = EX.Graph;
    }

    var iter = graph.halfedgesBegin();

    while(iter.hasNext())
    {

        halfedge = iter.next();
        console.log(halfedge);

        SCRIB.ASSERT(halfedge.edge != null);
        SCRIB.ASSERT(halfedge.twin != null);
        SCRIB.ASSERT(halfedge.twin.twin == halfedge);
        SCRIB.ASSERT(halfedge.next != null);
        SCRIB.ASSERT(halfedge.prev != null);
        SCRIB.ASSERT(halfedge.next.prev == halfedge);
        SCRIB.ASSERT(halfedge.prev.next == halfedge);
    }

    // -- Test edges.
    var iter = graph.edgesBegin();
    while(iter.hasNext())
    {
        edge = iter.next();
        SCRIB.ASSERT(edge.halfedge.edge == edge);
    }

    var iter = graph.facesBegin();
    while(iter.hasNext())
    {
        face = iter.next();
        SCRIB.printFace(face);// Print the faces present.
        SCRIB.ASSERT(face.halfedge.face == face);
    }

    SCRIB.ASSERT(graph.numHalfedges() == graph.numEdges()*2);

    console.log("TotalHalfedges = " + graph.numHalfedges());
    console.log("TotalEdges = " + graph.numEdges());
    console.log("TotalFaces = "     + graph.numFaces());
    console.log("TotalVerts = "     + graph.numVertices());

    return "All Tests have passed";
};

SCRIB.printFace = function(face)
{
    console.log(face);
    var out = ""
    var start   = face.halfedge;
    var current = start;

    do
    {
        //SCRIB.ASSERT(current.face == face);
        console.log("vert " + current.vertex.id + "--> face " + current.face.id)
        out = out + "" + current.vertex.id + ", "
        current = current.next;
    }while(current != start);

    console.log(out);

    var out = ""
    var start   = face.halfedge;
    var current = start;

    // Watch out for cycles.
    var hare = start;

    do
    {
        SCRIB.ASSERT(current.face == face);
        out = out + "" + current.vertex.id + ", "
        current = current.prev;
        hare = hare.prev.prev;

        if (current != start && hare == current)
        {
            console.log("ERROR: Malformed previous pointers.");
            throw new Error("Errof: Malformed previous pointer.");
            SCRIB.ASSERT(false);
        }

    }while(current != start);
    console.log("Face Backwards.");
    console.log(out);
};

SCRIB.printHalfedge = function(halfedge)
{
    out = ""
    out = out + halfedge.vertex.id + " --> " + halfedge.twin.vertex.id
    console.log(out);
    return out
};

SCRIB.printEdge = function(edge)
{
    out = ""
    out = out + edge.halfedge.vertex.id + " <--> " + edge.halfedge.twin.vertex.id
    console.log(out);
    return out   
};

SCRIB.ASSERT = function(b)
{
    if(!b)
    {
        err = new Error()
        console.log(err.stack)
        debugger
        throw new Error("Assertion Failed!")
    }
};
// Generated by CoffeeScript 1.11.1

/*

A Useful Graphics class for drawing Scribble.js objects,
such as Polyline Graph embeddings, HalfedgeGraphs, etc
onto a canvas element.

Takes in a BDS.G_ object and creates these calls using that object.
Because of this, A canvas target drawing class may be swapped out for a three.js, serial writing, 
or alternative drawing class that comes along.


It also has some visual design and aethetics functions, such as colorGraph(), which 6 colors a list of face_infos.
 */

(function() {
  SCRIB.G_Graphs = (function() {
    function G_Graphs(_G) {
      this._G = _G;
    }

    G_Graphs.prototype.setLowerG = function(g) {
      return this._G = g;
    };

    G_Graphs.prototype.getLowerG = function() {
      return this._G;
    };

    G_Graphs.prototype.drawVerts = function(graph) {
      var circle, iter, point, results, vert;
      iter = graph.verticesBegin();
      results = [];
      while (iter.hasNext()) {
        vert = iter.next();
        point = vert.data.point;
        circle = new BDS.Circle(point, 5, true);
        this._G.strokeColor(0xffffff);
        this._G.fillColor(0x222222);
        this._G.drawCircle(circle);
        this._G.fillColor(0xffffff);
        results.push(this._G.drawText(vert.id, point.x + 16, point.y + 16));
      }
      return results;
    };

    G_Graphs.prototype.drawFaceInfoArray = function(face_info_array) {
      var color, comp_faces, face, i, j, len, ref, results;
      comp_faces = [];
      len = face_info_array.length;
      for (i = j = 0, ref = len; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
        face = face_info_array[i];
        if (face.color === void 0) {
          face.color = this._G.randomColor();
        }
        color = face.color;
        if (!face.isExterior()) {
          this._G.fillColor(color);
          this._G.strokeColor(0x000000);
          this._G.drawPolygon(face.polyline);
          this._G.drawPolyline(face.polyline);
        } else {
          comp_faces.push(face);
        }
      }
      results = [];
      while (comp_faces.length > 0) {
        face = comp_faces.pop();
        this._G.strokeColor(0xffffff);
        results.push(this._G.drawPolyline(face.polyline));
      }
      return results;
    };

    G_Graphs.prototype.drawEdgeInfoArray = function(edge_info_array) {
      var edge_info, i, j, len, ref, results;
      this._G.strokeColor(0xff0000);
      len = edge_info_array.length;
      results = [];
      for (i = j = 0, ref = len; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
        edge_info = edge_info_array[i];
        results.push(this._G.drawPolyline(edge_info.polyline));
      }
      return results;
    };

    G_Graphs.prototype.drawPolyLine_Array = function(polylines) {
      var i, j, len, ref, results;
      this._G.strokeColor(0xff0000);
      len = polylines.length;
      results = [];
      for (i = j = 0, ref = len; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
        results.push(this._G.drawPolyline(polylines[i]));
      }
      return results;
    };

    G_Graphs.prototype.colorGraph = function(graph, face_infos) {
      var color_id, coloring, colors, faceGraph, face_info, i, j, ref, results;
      faceGraph = new SCRIB.FaceGraph(graph);
      coloring = faceGraph.autoColor();
      colors = [0xbae3ff, 0xffbae3, 0xe3ffba, 0xffd6ba, 0xbac1ff, 0xbafff9];
      results = [];
      for (i = j = 0, ref = face_infos.length; j < ref; i = j += 1) {
        face_info = face_infos[i];
        color_id = parseInt(coloring[face_info.id]);
        if (color_id >= colors.length) {
          results.push(face_info.color = this._G.newColor(100, 100, 100));
        } else {
          results.push(face_info.color = colors[color_id]);
        }
      }
      return results;
    };

    return G_Graphs;

  })();

}).call(this);

// Generated by CoffeeScript 1.11.1

/*
    Polyline Graph Associated Data classes.

    Adapted by Bryce Summers on 1 - 3 - 2017.

    Purpose: These classes provide application specific associated data structures that are linked into HalfedgeGraph elements.

    They will be used for algorithms on planar graph embeddings from polyline inputs.
 */

(function() {
  SCRIB.Graph_Data = (function() {
    function Graph_Data(graph) {
      this.graph = graph;
    }

    Graph_Data.prototype.clearFaceMarks = function() {
      var iter, results;
      iter = this.graph.facesBegin();
      results = [];
      while (iter.hasNext()) {
        results.push(iter.next().data.marked = false);
      }
      return results;
    };

    Graph_Data.prototype.clearVertexMarks = function() {
      var iter, results;
      iter = this.graph.verticesBegin();
      results = [];
      while (iter.hasNext()) {
        results.push(iter.next().data.marked = false);
      }
      return results;
    };

    Graph_Data.prototype.clearEdgeMarks = function() {
      var iter, results;
      iter = this.graph.edgesBegin();
      results = [];
      while (iter.hasNext()) {
        results.push(iter.next().data.marked = false);
      }
      return results;
    };

    Graph_Data.prototype.clearHalfedgeMarks = function() {
      var iter, results;
      iter = this.graph.halfedgesBegin();
      results = [];
      while (iter.hasNext()) {
        results.push(iter.next().data.marked = false);
      }
      return results;
    };

    Graph_Data.prototype.clearMarks = function() {
      this.clearFaceMarks();
      this.clearVertexMarks();
      this.clearEdgeMarks();
      return this.clearHalfedgeMarks();
    };

    return Graph_Data;

  })();

  SCRIB.Face_Data = (function() {
    function Face_Data(face) {
      var hole_representatives;
      this.face = face;
      this.marked = false;
      hole_representatives = [];
      this.hole_polylines = [];
      this.info = null;
    }

    Face_Data.prototype.addHole = function(hole) {
      return hole_representatives.push(hole);
    };


    /*
    // The area of the face is determined by the intersection this face with all of the hole faces,
    // which will be specified by exterior facing edge that enclose an infinite complemented area.
     */

    return Face_Data;

  })();

  SCRIB.Vertex_Data = (function() {
    function Vertex_Data(vertex) {
      this.vertex = vertex;
      this.point = null;
      this.marked = false;
      this.tail_point = false;
      this.intersection_point = false;
      this.singleton_point = false;

      /*
       * Used as a temporary structure for graph construction, but it is also may be relevant to users.
       * I don't know whether I will maintain this structure outside of graph construction.
       * FIXME: I might switch this to being a pointer to allow for me to null it out when no longer needed.
       * SCRIB.Halfedge[]
       */
      this.outgoing_edges = [];
      this.info = null;
    }

    Vertex_Data.prototype.isExtraordinary = function() {
      return this.tail_point || this.intersection_point;
    };

    return Vertex_Data;

  })();

  SCRIB.Edge_Data = (function() {
    function Edge_Data(edge) {
      this.edge = edge;
      this.marked = false;
      this.info = null;
    }

    return Edge_Data;

  })();

  SCRIB.Halfedge_Data = (function() {
    function Halfedge_Data(halfedge) {
      this.halfedge = halfedge;
      this.marked = false;
      this.next_extraordinary = null;
      this.info = null;

      /*
      @_curve
      @_time1
      @_time2
       */
    }

    Halfedge_Data.prototype.isExtraordinary = function() {
      return this.halfedge.vertex.data.isExtraordinary();
    };

    Halfedge_Data.prototype.setAssociatedCurve = function(obj) {
      this._curve = obj;
    };

    Halfedge_Data.prototype.getAssociatedCurve = function() {
      return this._curve;
    };

    Halfedge_Data.prototype.setTimes = function(time1, time2) {
      this._time1 = time1;
      return this._time2 = time2;
    };

    Halfedge_Data.prototype.getTimes = function() {
      if (this._time1 === void 0) {
        return void 0;
      }
      return [this._time1, this._time2];
    };

    return Halfedge_Data;

  })();

}).call(this);

// Generated by CoffeeScript 1.11.1

/*
* Transforms a set of input polylines into a planar graph embedding.
*
* Written by Bryce Summers.
*
* 8/16/2016: Written as a more fully advanced version of FaceFinder.h,
*            which outputs sophisticated graph structures oozing with useful connectivity information.
* 1/4/2017:  Ported to Coffeescript.
*
* Original C++ code written for the STUDIO for Creative Inquiry at Carnegie Mellon University.
 */


/*
* These algorithms include:
* Preprocessing:
* [EMPTY]
*
* Main Algorithm:
* 1. The main algorithm for embedding a set of polylines in space and determining the set of non chordal cycles in the
*    associated embedded planar graph.
*
* - A polygon is closed if it has identical starting and ending points and open otherwise.
*   The algorithm may be configured to output either open or closed polygons based on the closed_loop mode state.
*
* FIXME: If a user draws a second line completely around an original line, then there will be faces defined by both an external
*        face on the original polyline embedding and an internal face on the new enclosing embedding.
*        This may invalidate some users' assumptions of a global planar graph embedding without any holes.
*
*
* FIXME: This has been moved to the polylineGraphPostProcessor class.
* Post Processing:
* 1. Determine internal and external faces. (Initial Release)
* 2. Determine trivial and non trivial area faces according to a constant area threshold value. (8/11/2016)
*    (If you can't think of any good constant values, you might want to look at the field of
*     Topological Data Analysis and their 'barcode' concept: https://en.wikipedia.org/wiki/Topological_data_analysis.
* 3. Clipping off tails, i.e. portions of faces that enclose 0 area. (8/11/2016)
*    This could potentially be put into the getCycle function, but I think that it is best to make this a dedicated post processing step instead
*    in order to preserve the simplicity of the main algorithm.
*    This algorithm properly handles faces with either duplicated or non-duplicated starting and ending points.
*    i.e. Those produced in open and closed mode.
 */


/*
// FIXME: Write a list of all of the relevant interesting properties of the my planar embedding implementation.
// Edges always point to the forward facing halfedge.
// forward facing half edges are consecutively ordered in the first half.
// backwards facing half edges are consecutively ordered in the reverse order of the first half.
 */

(function() {
  SCRIB.PolylineGraphEmbedder = (function() {

    /*
    A User can explicitly pass false to force the intersection points to be found using a brute force algorithm that
    may potentially be more robust and reliable than the optimized intersection algorithm,
    but it kills the performance.
     */
    function PolylineGraphEmbedder(_useFastAlgo) {
      this._useFastAlgo = _useFastAlgo;
      if (this._useFastAlgo === void 0) {
        this._useFastAlgo = true;
      }
      this._points = [];
      this._lines_initial = [];
      this._lines_split = [];

      /*
      // The graph that is being built.
      // Once it is returned, the responsibility for this memory transfers to the user and the pointer is forgotten from this class.
       * FIXME: Should this graph embedded remember this guy?
       */
      this._graph = null;
    }


    /*
    Derives a planar graph embedding from the given input polyline.
    Assumes all points are distinct.
     */

    PolylineGraphEmbedder.prototype.embedPolyline = function(input) {
      if (input.size() <= 1) {
        return this._trivial(input);
      }
      this._loadPolyline(input);
      return this._do_the_rest();
    };


    /*
     * Derive faces from a set list of vertex disjoint polyline inputs.
     * Note: Each individual polyline specifies properties such as being closed or not.
     * Polyline[] (An array of polylines) -> SCRIB.Graph
     */

    PolylineGraphEmbedder.prototype.embedPolylineArray = function(inputs) {
      var e, j, len, len1;
      len = inputs.length;
      for (j = 0, len1 = inputs.length; j < len1; j++) {
        e = inputs[j];
        this._loadPolyline(e);
      }
      return this._do_the_rest();
    };

    PolylineGraphEmbedder.prototype._trivial = function(polyline) {
      var graph, linker, vertex, vertex_data;
      graph = this._newGraph();
      if (polyline.size() < 1) {
        return graph;
      }
      linker = new SCRIB.TopologyLinker(SCRIB.PolylineGraphEmbedder, graph);
      vertex = linker.link_island_vertex();
      vertex_data = vertex.data;
      vertex_data.point = polyline.getPoint(0);
      return graph;
    };

    PolylineGraphEmbedder.prototype._do_the_rest = function() {
      var output;
      this._splitIntersectionPoints();
      this._allocate_graph_from_input();
      this._sort_outgoing_edges_by_angle();
      this._associate_halfedge_cycles();
      output = this._deriveFaces();
      output.delete_index_arrays();
      this._cleanup();
      return output;
    };


    /*
    The embedding is broken down into seperate phases. Here I have listed each operation,
    followed by the data structures that they have built.
    
    Appends the given input points to the collated single input point array.
    Performs point fudging to avoid degenerate behavior.
    Starts up the indexed collection of points.
    SCRIB.Polyline -> ()
     */


    /*
    New Constructed data Fields:
    //The canonical collection of points at their proper indices.
    BDS.Point[] @_points
    // The original input lines.
    SCRIB.Line[] @_lines_initial
     */

    PolylineGraphEmbedder.prototype._loadPolyline = function(polyline) {
      var ass_data, curve, i, i_line, input_point, j, k, len, offset, ref, ref1, times;
      len = polyline.size();
      offset = this._points.length;
      for (i = j = 0, ref = len; j < ref; i = j += 1) {
        input_point = polyline.getPoint(i);
        if ((offset > 0 || i > 0) && this._points[offset + i - 1].x === input_point.x) {
          input_point.x += .001;
        }
        if (isNaN(input_point.x)) {
          debugger;
        }
        this._points.push(input_point);
      }
      curve = polyline.getAssociatedData();
      times = polyline.getTimes();
      ass_data = false;
      if (curve && times) {
        ass_data = true;
      }
      for (i = k = 0, ref1 = len - 1; k < ref1; i = k += 1) {
        i_line = new BDS.Line(i + offset, i + offset + 1, this._points);
        if (ass_data) {
          i_line.setAssociatedCurve(curve);
          i_line.setTimes(times[i], times[i + 1]);
        }
        this._lines_initial.push(i_line);
      }

      /*
      Add a line connecting the first and last points on the original set of input points if
      the polyline is closed.
      In other words put a duplicate copy of the initial point.
       */
      if (polyline.isClosed()) {
        i_line = new BDS.Line(len - 1 + offset, 0 + offset, this._points);
        if (ass_data) {
          i_line.setAssociatedCurve(curve);
          i_line.setTimes(times[len - 1], 0);
        }
        this._lines_initial.push(i_line);
      }
    };


    /*
    Intersects the input lines, then splits them and connects them appropiatly.
    Populates the list of edge disjoint lines that only intersect at vertices.
    puts the edge in consecutive order following the input polylines.
    results put into this.lines_split
    () -> ()
     */


    /*
    New Constructed data Field:
    Split version of original input lines, where lines only intersect at vertices.
    SCRIB.Line[] @_lines_split
     */

    PolylineGraphEmbedder.prototype._splitIntersectionPoints = function() {
      var i, intersector, j, line, numLines, ref;
      intersector = new BDS.Intersector();
      if (this._useFastAlgo) {
        intersector.intersectLineSegments(this._lines_initial);
      } else {
        intersector.intersect_brute_force(this._lines_initial);
      }
      numLines = this._lines_initial.length;
      for (i = j = 0, ref = numLines; j < ref; i = j += 1) {
        line = this._lines_initial[i];
        line.getSplitLines(this._lines_split);
      }
    };


    /*
    #-- Step 3. Proccess the embedded input and initialize the Planar Graph vertices, edges, and halfedges.
    Allocates the output graph object and allocates vertices, edges, and halfedges for the input data.
    Vertices are Indexed as follows [original points 1 for input polyline 1, then 2, ...,
    new intersection points for polyline 1, then 2, etc, ...]
    Halfedges are indexed in polyline input order, then in backwards input order.
    () -> ()
     */


    /*
    New Constructed data Field:
    The graph that is being built and will eventually be returned to the user.
    SCRIB.Graph @_graph
     */

    PolylineGraphEmbedder.prototype._allocate_graph_from_input = function() {
      var curve, e, edge, edge_ID, halfedge, halfedge_ID, i, j, k, l, last_backwards_halfedge, last_forwards_halfedge, last_index, len, len1, len2, line, point, ref, ref1, ref2, ref3, time1, time2, twin, twin_ID, vert, vert_data, vert_twin, vert_twin_data, vertex_ID, vertex_twin_ID;
      this._graph = this._newGraph();
      ref = this._points;
      for (j = 0, len1 = ref.length; j < len1; j++) {
        point = ref[j];
        vert = this._newVertex();
        vert_data = vert.data;
        vert.halfedge = null;
        vert_data.point = point;
      }
      ref1 = this._lines_split;
      for (k = 0, len2 = ref1.length; k < len2; k++) {
        e = ref1[k];
        this._newHalfedge();
        this._newHalfedge();
        this._newEdge();
      }

      /*
      Associate edges <-> halfedges.
            halfedges <-> twin halfedges.
            halfedges <-> vertices.
       */
      last_forwards_halfedge = null;
      last_backwards_halfedge = null;
      len = this._lines_split.length;
      last_index = len * 2 - 1;
      for (i = l = 0, ref2 = len; l < ref2; i = l += 1) {
        line = this._lines_split[i];
        vertex_ID = line.p1_index;
        vertex_twin_ID = line.p2_index;
        edge_ID = i;
        halfedge_ID = i;
        twin_ID = last_index - i;
        edge = this._graph.getEdge(edge_ID);
        halfedge = this._graph.getHalfedge(halfedge_ID);
        twin = this._graph.getHalfedge(twin_ID);
        vert = this._graph.getVertex(vertex_ID);
        vert_twin = this._graph.getVertex(vertex_twin_ID);
        vert_data = vert.data;
        vert_twin_data = vert_twin.data;
        edge.halfedge = halfedge;
        halfedge.edge = edge;
        twin.edge = edge;
        halfedge.twin = twin;
        twin.twin = halfedge;
        halfedge.vertex = vert;
        twin.vertex = vert_twin;
        if (line.hasAssociatedCurve()) {
          curve = line.getAssociatedCurve();
          halfedge.data.setAssociatedCurve(curve);
          ref3 = line.getTimes(), time1 = ref3[0], time2 = ref3[1];
          halfedge.data.setTimes(time1, time2);
          twin.data.setAssociatedCurve(curve);
          twin.data.setTimes(time2, time1);
        }
        if (vert.halfedge === null) {
          vert.halfedge = halfedge;
        }
        if (vert_twin.halfedge === null) {
          vert_twin.halfedge = twin;
        }
        if (halfedge === void 0 || twin === void 0) {
          debugger;
        }
        vert_data.outgoing_edges.push(halfedge);
        vert_twin_data.outgoing_edges.push(twin);
      }
    };

    PolylineGraphEmbedder.prototype._sort_outgoing_edges_by_angle = function() {
      var iter, outgoing_edges, vert_data;
      iter = this._graph.verticesBegin();
      while (iter.hasNext()) {
        vert_data = iter.next().data;
        outgoing_edges = vert_data.outgoing_edges;
        this._sort_outgoing_edges(outgoing_edges);
      }
    };

    PolylineGraphEmbedder.prototype._sort_outgoing_edges = function(outgoing_edges) {
      var angle, angles, center_data, center_point, center_vert, edge, hedge_in, hedge_out, i, i1, i2, j, k, l, len, len1, outer_data, outer_point, outer_vert, outgoing_halfedge_representative, ref, ref1, temp_f, temp_he;
      len = outgoing_edges.length;
      if (len <= 2) {
        return;
      }
      angles = [];
      outgoing_halfedge_representative = outgoing_edges[0];
      center_vert = outgoing_halfedge_representative.vertex;
      center_data = center_vert.data;
      center_point = center_data.point;
      for (j = 0, len1 = outgoing_edges.length; j < len1; j++) {
        edge = outgoing_edges[j];
        hedge_out = edge;
        hedge_in = hedge_out.twin;
        outer_vert = hedge_in.vertex;
        outer_data = outer_vert.data;
        outer_point = outer_data.point;
        angle = Math.atan2(outer_point.y - center_point.y, outer_point.x - center_point.x);
        angles.push(angle);
      }
      for (i = k = 0, ref = len; k < ref; i = k += 1) {
        for (i2 = l = ref1 = i - 1; l >= 0; i2 = l += -1) {
          i1 = i2 + 1;
          if (angles[i2] <= angles[i1]) {
            break;
          }
          temp_f = angles[i2];
          angles[i2] = angles[i1];
          angles[i1] = temp_f;
          temp_he = outgoing_edges[i2];
          outgoing_edges[i2] = outgoing_edges[i1];
          outgoing_edges[i1] = temp_he;
          if (outgoing_edges[i1] === void 0 || outgoing_edges[i2] === void 0) {
            debugger;
          }
        }
      }
    };


    /*
     * -- Step 5.
    Determines the next and previous pointers for the halfedges in the Graph.
    This is done almost entirely using the sets of outgoing edges for each vertex.
    vertices of degree 2 associate their 2 pairs of neighbors.
    vertices of degree are on a tail and associate their one pair of neighbors.
    vertices of degree >2 are intersection points and they first sort their neighbors, then associate their star.
    This function sets the Vertex_Data objects classification data.
     * () -> ()
     */

    PolylineGraphEmbedder.prototype._associate_halfedge_cycles = function() {
      var degree, hedge_in, hedge_out, i, iter, j, linker, outgoing_edges, ref, vert, vert_data;
      iter = this._graph.verticesBegin();
      while (iter.hasNext()) {
        vert = iter.next();
        vert_data = vert.data;
        outgoing_edges = vert_data.outgoing_edges;
        degree = outgoing_edges.length;
        if (degree === 0) {
          linker = new SCRIB.TopologyLinker(SCRIB.PolylineGraphEmbedder, this._graph);
          linker.link_island_vertex(vert);
          vert_data.singleton_point = true;
          continue;
        }
        if (degree === 1) {
          vert_data.tail_point = true;
          hedge_out = vert.halfedge;
          hedge_in = hedge_out.twin;
          hedge_out.prev = hedge_in;
          hedge_in.next = hedge_out;
          continue;
        }
        if (degree > 2) {
          vert_data.intersection_point = true;
        }
        for (i = j = 0, ref = degree; j < ref; i = j += 1) {
          hedge_out = outgoing_edges[i];
          if (hedge_out === void 0 || hedge_out.twin === void 0) {
            debugger;
          }
          hedge_in = hedge_out.twin;
          hedge_in.next = outgoing_edges[(i + 1) % degree];
          hedge_out.prev = outgoing_edges[(i + degree - 1) % degree].twin;
        }
        continue;
      }
    };


    /*
     * Step 6.
     * Uses the vertex and edge complete halfedge mesh to add face data.
     * Also produces simpler cycle structures along that serve as an alternate representation of the faces.
     * () -> SCRIB.Graph
     */

    PolylineGraphEmbedder.prototype._deriveFaces = function() {
      var face, halfedge, halfedge_data, iter;
      iter = this._graph.halfedgesBegin();
      while (iter.hasNext()) {
        halfedge = iter.next();
        halfedge_data = halfedge.data;
        if (halfedge_data.marked) {
          continue;
        }
        face = this._newFace();
        face.halfedge = halfedge;
        this._trace_face(face);
      }
      this._graph.data.clearHalfedgeMarks();
      return this._graph;
    };


    /*
    REQUIRES: 1. face -> halfedge well defined already.
              2. halfedge next pointer well defined already.
    ENSURES:  links every halfedge in the loop starting and ending at face -> halfedge
              with the face.
     * SCRIB.Face -> ()
     */

    PolylineGraphEmbedder.prototype._trace_face = function(face) {
      var current, start;
      start = face.halfedge;
      current = start;
      while (true) {
        current.face = face;
        current.data.marked = true;
        current = current.next;
        if (current === start) {
          break;
        }
      }
    };


    /*
    Free all of the intermediary data structures.
    Clear input structures.
    Unmark the output.
     */

    PolylineGraphEmbedder.prototype._cleanup = function() {
      this._points = [];
      this._lines_initial = [];
      return this._lines_split = [];
    };

    PolylineGraphEmbedder.prototype._newGraph = function() {
      return SCRIB.PolylineGraphEmbedder.newGraph();
    };

    PolylineGraphEmbedder.prototype._newFace = function() {
      return SCRIB.PolylineGraphEmbedder.newFace(this._graph);
    };

    PolylineGraphEmbedder.prototype._newEdge = function() {
      return SCRIB.PolylineGraphEmbedder.newEdge(this._graph);
    };

    PolylineGraphEmbedder.prototype._newHalfedge = function() {
      return SCRIB.PolylineGraphEmbedder.newHalfedge(this._graph);
    };

    PolylineGraphEmbedder.prototype._newVertex = function() {
      return SCRIB.PolylineGraphEmbedder.newVertex(this._graph);
    };

    PolylineGraphEmbedder.newGraph = function() {
      var output;
      output = new SCRIB.Graph(true);
      output.data = new SCRIB.Graph_Data(output);
      return output;
    };

    PolylineGraphEmbedder.newFace = function(graph) {
      var output;
      output = graph.newFace();
      output.data = new SCRIB.Face_Data(output);
      return output;
    };

    PolylineGraphEmbedder.newEdge = function(graph) {
      var output;
      output = graph.newEdge();
      output.data = new SCRIB.Edge_Data(output);
      return output;
    };

    PolylineGraphEmbedder.newHalfedge = function(graph) {
      var output;
      output = graph.newHalfedge();
      output.data = new SCRIB.Halfedge_Data(output);
      return output;
    };

    PolylineGraphEmbedder.newVertex = function(graph) {
      var output;
      output = graph.newVertex();
      output.data = new SCRIB.Vertex_Data(output);
      return output;
    };

    return PolylineGraphEmbedder;

  })();

}).call(this);

// Generated by CoffeeScript 1.11.1

/*

Polyline Graph Topology Generator.

Generates Halfedge Topology associated with Polyline Graph Data Objects.

Written by Bryce Summers
Move to its own file on 3 - 7 - 2017.
 */

(function() {
  SCRIB.PolylineGraphGenerator = (function() {
    function PolylineGraphGenerator(_graph) {
      this._graph = _graph;
    }

    PolylineGraphGenerator.prototype.newGraph = function() {
      return SCRIB.PolylineGraphEmbedder.newGraph();
    };

    PolylineGraphGenerator.prototype.newFace = function(graph) {
      if (!graph) {
        graph = this._graph;
      }
      return SCRIB.PolylineGraphEmbedder.newFace(graph);
    };

    PolylineGraphGenerator.prototype.newEdge = function(graph) {
      if (!graph) {
        graph = this._graph;
      }
      return SCRIB.PolylineGraphEmbedder.newEdge(graph);
    };

    PolylineGraphGenerator.prototype.newHalfedge = function(graph) {
      if (!graph) {
        graph = this._graph;
      }
      return SCRIB.PolylineGraphEmbedder.newHalfedge(graph);
    };

    PolylineGraphGenerator.prototype.newVertex = function(graph) {
      if (!graph) {
        graph = this._graph;
      }
      return SCRIB.PolylineGraphEmbedder.newVertex(graph);
    };

    PolylineGraphGenerator.prototype.line_side_test = function(vert1, vert2, vert3) {
      var pt_c, ray;
      pt_c = vert3.data.point;
      ray = this._ray(vert1, vert2);
      return ray.line_side_test(pt_c);
    };

    PolylineGraphGenerator.prototype.vert_in_angle = function(vert_a, vert_b, vert_c, vert_pt) {
      var angle1, angle2, angle_pt, ray1, ray2, ray_pt;
      ray1 = this._ray(vert_b, vert_c);
      ray2 = this._ray(vert_b, vert_a);
      ray_pt = this._ray(vert_b, vert_pt);
      angle1 = ray1.getAngle();
      angle2 = ray2.getAngle();
      angle_pt = ray_pt.getAngle();
      if (angle2 <= angle1) {
        angle2 += Math.PI * 2;
      }
      if (angle_pt < angle1) {
        angle_pt += Math.PI * 2;
      }
      return angle1 <= angle_pt && angle_pt <= angle2;
    };

    PolylineGraphGenerator.prototype._ray = function(v1, v2) {
      var a, b, dir, ray;
      a = v1.data.point;
      b = v2.data.point;
      dir = b.sub(a);
      ray = new BDS.Ray(a, dir, 1);
      return ray;
    };

    return PolylineGraphGenerator;

  })();

}).call(this);

// Generated by CoffeeScript 1.11.1

/*
The PolylineGraphPostProcessor class.
*
* Written and adapted from FaceFinder on 8/18/2016.
* Ported to Coffeescript on 1 - 4 - 2017.
*
* Purpose:
*
* Allows users to convert Planar Polyline Embedded Graphs into mainstream C++ data structures.
* This class then provides some useful processing algorithms on these output structures.
*
* I may also put information extraction algorithms here.
*
* The key idea is that the post processor doesn't mutate the Graph object in any way.
* FIXME: Use the Graph Mutator Proccessor instead (Currenly non existant.) if you wish to modify the graph.
*
* Maybe I will make a modification mode.
 */


/*

Tested Features:
    convert_to_face_infos()

Untested Features:
    clipTails()
    mergeFaces()
    BDS.BVH2D = generateBVH() [requires HalfedgeMesh]

     * Splits the current embedding by the given polyline.
    embedAnotherPolyline(polyLine)
    eraseEdgesInCircle()
 */

(function() {
  SCRIB.Vertex_Info = (function() {
    function Vertex_Info(vertex1) {
      this.vertex = vertex1;
      this.id = this.vertex.id;
      this.vertex.data.info = this;
    }

    return Vertex_Info;

  })();

  SCRIB.Edge_Info = (function() {
    function Edge_Info(edge1) {
      this.edge = edge1;
      this.id = this.edge.id;
      this.edge.data.info = this;
    }

    return Edge_Info;

  })();

  SCRIB.Halfedge_Info = (function() {

    /*
     * Represents and points to a halfedge. Its pointers may not be valid after algorithms such as tail clipping.
    // Faces and twin pointers should still be valid though...
     * @halfedge is only defined for HalfedgeGraph based souce embeddings.
     * Also contains a pointer to its face_info object.
     */
    function Halfedge_Info(halfedge3) {
      var next_data, next_point, next_vert, vert, vert_data;
      this.halfedge = halfedge3;
      this.halfedge.data.info = this;
      vert = this.halfedge.vertex;
      vert_data = vert.data;
      this.point = vert_data.point;
      this.id = this.halfedge.id;
      this.polyline = new BDS.Polyline(false);
      this.polyline.addPoint(this.point);
      this.polyline.setAssociatedData(this);
      next_vert = this.halfedge.next.vertex;
      next_data = next_vert.data;
      next_point = next_data.point;
      this.polyline.addPoint(next_point);
    }

    return Halfedge_Info;

  })();

  SCRIB.Face_Info = (function() {
    function Face_Info(face) {
      this.generateInfoFromFace(face);
    }

    Face_Info.prototype.generateInfoFromFace = function(face) {
      var current, halfedge_info, starting_half_edge;
      if (face === void 0) {
        face = this.face;
      } else {
        this.face = face;
      }
      this.face.data.info = this;
      this.holes = [];
      this.halfedges = [];
      this._halfedge_bvh = null;
      this.polyline = new BDS.Polyline(true);
      this.polyline.setAssociatedData(this);
      this.faces_id_set = new Set();
      this.faces_id_set.add(face.id);
      this.id = face.id;
      starting_half_edge = face.halfedge;
      current = starting_half_edge;
      while (true) {
        halfedge_info = new SCRIB.Halfedge_Info(current);
        this.push(halfedge_info);
        current = current.next;
        if (starting_half_edge === current) {
          break;
        }
      }
      this.complemented = this.polyline.isComplemented();
    };

    Face_Info.prototype.size = function() {
      return this.points.length;
    };

    Face_Info.prototype.isClosed = function() {
      return polyline.isClosed();
    };

    Face_Info.prototype.getLastPointInfo = function() {
      return this.points[this.points.length - 1];
    };

    Face_Info.prototype.push = function(halfedge_info) {
      this.halfedges.push(halfedge_info);
      return this.polyline.addPoint(halfedge_info.point);
    };

    Face_Info.prototype.pop = function() {
      this.polyline.removeLastPoint();
      return this.points.pop();
    };

    Face_Info.prototype.at = function(index) {
      return this.points[index];
    };

    Face_Info.prototype.isComplemented = function() {
      return this.polyline.isComplemented();
    };

    Face_Info.prototype.isExterior = function() {
      return this.isComplemented();
    };

    Face_Info.prototype.generateBVH = function() {
      var halfedge, i, j, len, line, ref, segments;
      segments = this.polyline.toPolylineSegments();
      len = segments.length;
      for (i = j = 0, ref = len; j < ref; i = j += 1) {
        line = segments[i];
        halfedge = this.halfedges[i];
        line.setAssociatedData(halfedge);
      }
      this._halfedge_bvh = new BDS.BVH2D(segments);
      return this._halfedge_bvh;
    };

    Face_Info.prototype.toCurves = function() {
      var current, curve, next_curve, output, ref, ref1, start, t1, t2, time1, time2, vert;
      start = this.face.halfedge;
      current = start;
      while (true) {
        vert = current.vertex;
        if (vert.degree() !== 2) {
          break;
        }
        current = current.next;
        if (current === start) {
          break;
        }
      }

      /*
      if current == start after looping, then this is a singleton cycle topology.
       */
      output = [];
      start = current;
      while (true) {
        ref = current.data.getTimes(), t1 = ref[0], t2 = ref[1];
        time1 = t1;
        curve = current.data.getAssociatedCurve();
        while (true) {
          current = current.next;
          next_curve = current.data.getAssociatedCurve();
          if (current.vertex.degree() !== 2) {
            break;
          }
          if (current === start) {
            break;
          }
        }
        ref1 = current.prev.data.getTimes(), t1 = ref1[0], t2 = ref1[1];
        time2 = t2;
        output.push(curve.subCurve(time1, time2));
        if (current === start) {
          break;
        }
      }
      return output;
    };


    /*
    Edge Intersection functions.
    Returns all edges within this face that are also within the given geometries.
     */

    Face_Info.prototype.query_halfedges_in_circle = function(circle, output) {
      return this.query_halfedges_in_geometry(circle, output);
    };

    Face_Info.prototype.query_halfedges_in_polyline = function(polyline, output) {
      return this.query_halfedges_in_geometry(polyline, output);
    };

    Face_Info.prototype.query_halfedges_in_geometry = function(geom, output) {
      var all_halfedges, halfedge, j, len1, polyline;
      all_halfedges = this.query_halfedges_in_box(geom.generateBoundingBox());
      for (j = 0, len1 = all_halfedges.length; j < len1; j++) {
        halfedge = all_halfedges[j];
        polyline = halfedge.polyline;
        if (geom.detect_intersection_with_polyline(polyline)) {
          output.push(halfedge);
        }
      }
      return output;
    };

    Face_Info.prototype.query_halfedges_in_box = function(box, output_list) {
      var j, len1, line, polylines;
      if (this._halfedge_bvh === null) {
        this.generateBVH();
      }
      if (output_list === void 0) {
        output_list = [];
      }
      polylines = this._halfedge_bvh.query_box_all(box);
      for (j = 0, len1 = polylines.length; j < len1; j++) {
        line = polylines[j];
        output_list.push(line.getAssociatedData());
      }
      return output_list;
    };

    Face_Info.prototype.addHole = function(polyline) {
      return this.face.data.hole_polylines.push(polyline);
    };

    Face_Info.prototype.getHoles = function() {
      var holes, j, len1, output, pline;
      holes = this.face.data.hole_polylines;
      output = [];
      for (j = 0, len1 = holes.length; j < len1; j++) {
        pline = holes[j];
        output.push(pline.clone());
      }
      return output;
    };

    return Face_Info;

  })();

  SCRIB.PolylineGraphPostProcessor = (function() {
    function PolylineGraphPostProcessor(_graph) {
      this._graph = _graph;
      this._graph = null;
      this._face_vector = [];
      this._face_bvh = null;
    }

    PolylineGraphPostProcessor.prototype.generate_faces_info = function() {
      var face, face_output, iter, next_old_face, next_old_index, old_faces, result;
      old_faces = this._face_vector;
      next_old_index = 0;
      next_old_face = null;
      if (old_faces.length > 0) {
        next_old_face = old_faces[next_old_index];
        next_old_index++;
      }
      this._face_vector = [];
      iter = this._graph.facesBegin();
      while (iter.hasNext()) {
        face = iter.next();
        while (next_old_face !== null && next_old_face.id < face.id) {
          if (this._face_bvh !== null) {
            result = this._face_bvh.remove(next_old_face.polyline);
            if (!result) {
              debugger;
            }
          }
          if (next_old_index < old_faces.length) {
            next_old_face = old_faces[next_old_index];
            next_old_index++;
          } else {
            next_old_face = null;
          }
        }
        if (next_old_face !== null && next_old_face.id === face.id) {
          this._face_vector.push(next_old_face);
          if (next_old_face.face.data.marked) {
            next_old_face.face.data.marked = false;
            this._face_bvh.remove(face_info.polyline);
            next_old_face.generateInfoFromFace();
            next_old_face.generateBVH();
            this._face_bvh.add(face_info.polyline);
          }
          if (next_old_index < old_faces.length) {
            next_old_face = old_faces[next_old_index];
            next_old_index++;
          } else {
            next_old_face = null;
          }
          continue;
        }
        face_output = new SCRIB.Face_Info(face);
        this._face_vector.push(face_output);
        if (this._face_bvh !== null) {
          this._face_bvh.add(face_output.polyline);
        }
        continue;
      }
      while (next_old_face !== null) {
        if (this._face_bvh !== null) {
          result = this._face_bvh.remove(next_old_face.polyline);
          if (next_old_index < old_faces.length) {
            next_old_face = old_faces[next_old_index];
            next_old_index++;
          } else {
            next_old_face = null;
          }
        }
      }
      if (this._face_bvh !== null) {
        this._face_bvh.optimize();
      }
      return this._face_vector;
    };

    PolylineGraphPostProcessor.prototype.generate_faces_info = function() {
      var face, face_output, iter;
      this._face_vector = [];
      iter = this._graph.facesBegin();
      while (iter.hasNext()) {
        face = iter.next();
        face_output = new SCRIB.Face_Info(face);
        this._face_vector.push(face_output);
      }
      this.generateBVH();
      return this._face_vector;
    };

    PolylineGraphPostProcessor.prototype.generate_faces_info = function() {
      var face, face_info, iter, old_faces, old_faces_index, ref, result;
      old_faces = this._face_vector;
      old_faces_index = 0;
      this._face_vector = [];
      iter = this._graph.facesBegin();
      while (iter.hasNext()) {
        face = iter.next();
        ref = this._nextFaceInfo(face, old_faces, old_faces_index), face_info = ref[0], old_faces_index = ref[1];
        if (face_info === null) {
          face_info = new SCRIB.Face_Info(face);
          face_info.face.data.marked = true;
        }
        this._proccessFaceInfo(face_info);
        this._face_vector.push(face_info);
      }
      if (this._face_bvh !== null) {
        while (old_faces_index < old_faces.length) {
          face_info = old_faces[old_faces_index];
          result = this._face_bvh.remove(face_info.polyline);
          if (result === false) {
            debugger;
          }
          old_faces_index++;
        }
      }
      if (this._face_bvh !== null) {
        this._face_bvh.optimize();
      }
      return this._face_vector;
    };

    PolylineGraphPostProcessor.prototype._nextFaceInfo = function(face, faces, min_index) {
      var face_info, result, target_id;
      target_id = face.id;
      while (min_index < faces.length) {
        face_info = faces[min_index];
        if (face_info.id === target_id) {
          return [face_info, min_index + 1];
        }
        if (face_info.id > target_id) {
          return [null, min_index];
        }
        min_index++;
        if (this._face_bvh !== null) {
          result = this._face_bvh.remove(face_info.polyline);
          if (!result) {
            debugger;
          }
        }
      }
      return [null, min_index];
    };

    PolylineGraphPostProcessor.prototype._proccessFaceInfo = function(face_info) {
      if (this._face_bvh !== null && face_info.face.data.marked === true) {
        this._face_bvh.remove(face_info.polyline);
        face_info.generateInfoFromFace();
        this._face_bvh.add(face_info.polyline);
        return face_info.face.data.marked = false;
      }
    };

    PolylineGraphPostProcessor.prototype.get_current_faces_info = function() {
      return this._face_vector;
    };

    PolylineGraphPostProcessor.prototype.load_graph = function(_graph) {
      this._graph = _graph;
      this._face_vector = [];
      return this._face_bvh = null;
    };

    PolylineGraphPostProcessor.prototype.getCurrentGraph = function() {
      return this._graph;
    };

    PolylineGraphPostProcessor.prototype.free_face_vector = function() {
      return this._face_vector = null;
    };

    PolylineGraphPostProcessor.prototype.free_graph = function() {
      return this._graph = null;
    };


    /*
    Appends the indices of any external faces amongst the input list of faces to the output vector.
    NOTE : The input type is equivelant to the output type of the face finding functions,
    so using this function may be a natural extension of using the original functions.
     * int[] -> () [appends complemented faces to input]
     */

    PolylineGraphPostProcessor.prototype.determineComplementedFaces = function(output) {
      var area, face_info, index, j, len, ref;
      len = this._face_vector.length;
      for (index = j = 0, ref = len; 0 <= ref ? j < ref : j > ref; index = 0 <= ref ? ++j : --j) {
        face_info = this._face_vector[index];
        area = face_info.polyline.computeAreaOfPolygon();
        if (area > 0) {
          output.push(index);
        }
      }
    };

    PolylineGraphPostProcessor.prototype.determineNonTrivialAreaFaces = function(output, min_area) {
      var area, face_info, index, j, len, ref;
      len = this._face_vector.length;
      for (index = j = 0, ref = len; 0 <= ref ? j < ref : j > ref; index = 0 <= ref ? ++j : --j) {
        face_info = this._face_vector[index];
        area = face_info.polyline.computeAreaOfPolygon();
        area = area >= 0 ? area : -area;
        if (area >= min_area) {
          output.push(index);
        }
      }
    };

    PolylineGraphPostProcessor.prototype.determineTrivialAreaFaces = function(output, min_area) {
      var area, face_info, index, j, len, ref;
      len = this._face_vector.length;
      for (index = j = 0, ref = len; 0 <= ref ? j < ref : j > ref; index = 0 <= ref ? ++j : --j) {
        face_info = this._face_vector[index];
        area = face_info.polyline.computeAreaOfPolygon();
        area = area >= 0 ? area : -area;
        if (area < min_area) {
          output.push(index);
        }
      }
    };


    /*
    Input: a set of faces, Output: a new set of faces that have no trivial contiguous subfaces.
    clips all of the polylines currently loaded in this post processor.
    ENSURES: Polygons will be output either open or closed in the manner that they are passed in.
    ENSURES: Omits faces consisting of only a single long tail.
    The user is still responsible to deallocating the original vector.
     * () -> face_info[] (with no tails)
     */

    PolylineGraphPostProcessor.prototype.clipAllTails = function() {
      var clipped_face, index, input, j, len, output, ref, unclipped_face;
      input = this._face_vector;
      output = [];
      len = input(function() {
        return size();
      });
      for (index = j = 0, ref = len; 0 <= ref ? j < ref : j > ref; index = 0 <= ref ? ++j : --j) {
        unclipped_face = input[index];
        clipped_face = this._clipTails(unclipped_face);
        if (clipped_face.size() > 0) {
          output.push(clipped_face);
        }
      }
      return output;
    };

    PolylineGraphPostProcessor.prototype._clipTails = function(input) {
      var clipped_previous, i, j, len, non_empty_output, output, p_end, p_next, p_previous, p_start, prune_num, ref;
      output = new SCRIB.Face_Info();
      len = input(function() {
        return size();
      });
      if (len < 3 || !input.isClosed()) {
        return output;
      }
      p_start = (input(function() {
        return at(0);
      })).ID;
      p_end = (input(function() {
        return at(len - 1);
      })).ID;

      /*
      The main idea behind tail clipping is to transform regions of the form ABA --> A,
      in other words removing any consecutive pairs of half edges cooresponding to the same full edge.
      We therefore
       */
      clipped_previous = false;
      non_empty_output = false;
      for (i = j = 0, ref = len; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
        p_previous = 0/0;
        non_empty_output = output.size() > 0;
        if (non_empty_output) {
          p_previous = output.getLastPointInfo().ID;
        } else {
          p_previous = input.points[len - 1].ID;
        }
        p_next = input.points[(i + 1) % len].ID;
        if (p_previous !== p_next) {
          output.push(input.at(i % len));
          clipped_previous = false;
          continue;
        }
        clipped_previous = true;
        if (non_empty_output) {
          output.pop();
        } else {
          len -= 1;
        }

        /*
        Don't add the current point, because we prune it as well.
        If p_next ends up now being a non tail point, it will be successfully added during the next iteration.
        We don't add it now, because we want to give it the opportunity to pruned by its next neighbor.
         */
        continue;
      }
      prune_num = 0;
      while (clipped_previous) {
        len = output.size();
        if (len < 3) {
          return output;
        }
        p_previous = (output.at(len - 1)).ID;
        p_next = (output.at(prune_num + 1)).ID;
        if (p_previous !== p_next) {
          break;
        }
        prune_num += 1;
        output.pop();
        continue;
      }
      if (clipped_previous) {
        output.splice(0, prune_num);
      }
      return output;
    };


    /*
    Uses the currently loaded this->graph object as Input.
    Takes in a vector containing the integer IDs of the faces to be merged.
    Takes a dictionary containing integers and outputs a set of faces representing the merge.
    Outputs the result of unioning all of the faces.
    Set -> SCRIB.FaceInfo[]
     */

    PolylineGraphPostProcessor.prototype.mergeFaces = function(face_ID_set) {
      var current, face, face_info, faces_complemented, faces_uncomplemented, id, j, k, l, len1, len2, len3, len4, m, map, output, set, start, uncomplemented_face;
      faces_uncomplemented = [];
      faces_complemented = [];
      for (j = 0, len1 = face_ID_Set.length; j < len1; j++) {
        id = face_ID_Set[j];
        Face * (face = graph.getFace(id));
        Halfedge * (start = face.halfedge);
        Halfedge * (current = face.halfedge);
        while (true) {
          if (current.data.marked === false && this._halfedgeInUnion(face_ID_set, current)) {
            face_info = this._traceUnionFace(face_ID_set, current);
            if (!face_info.isComplemented()) {
              face.complemented = false;
              faces_uncomplemented.push(face);
            } else {
              face.complemented = true;
              faces_complemented.push(face);
            }
          }
          current = current.next;
          if (current === start) {
            break;
          }
        }
        continue;
      }
      graph.data.clearHalfedgeMarks();
      output = [];
      map = {};
      for (k = 0, len2 = faces_uncomplemented.length; k < len2; k++) {
        face_info = faces_uncomplemented[k];
        output.push_back(face_info);
        set = face_info.faces_ID_set;
        for (l = 0, len3 = set.length; l < len3; l++) {
          id = set[l];
          map[id] = face;
        }
      }
      for (m = 0, len4 = faces_complemented.length; m < len4; m++) {
        face_info = faces_complemented[m];
        id = face_info.faces_id_set.keys().next().value;
        uncomplemented_face = map[id];
        if (!uncomplemented_face) {
          output.push(face);
          continue;
        }
        uncomplemented_face.holes.push_back(face_info);
      }
      return output;
    };


    /*
    Returns true iff the given hafedge is included in the output of the union of the given faces.
    I.E. returns true iff the given half edge -> face is within the set of unioned faces and half_edge->twin -> face is not.
    Tail edges, where the halfedge and its twin are on the same face are not considered to be in a halfedgeUnion face.
    Set, SCRIB.Halfedge -> bool.
     */

    PolylineGraphPostProcessor.prototype._halfedgeInUnion = function(face_id_set, start) {
      var face, face_found, face_id, twin_ID, twin_face, twin_face_found;
      face = start.face;
      face_id = face.id;
      face_found = face_id_set.has(face_id);
      twin_face = start.twin.face;
      twin_ID = twin_face(function() {
        return ID;
      });
      twin_face_found = face_Id_set.has(twin_ID);
      return face_found && !twin_face_found;
    };


    /*
    // Given an In Union halfege, traces its face_info union face information.
    // Properly sets the output's: points and face_IDs fields.
    // Marks halfedges, therefore calling functions are responsible for unmarking halfedges.
    Set, SCRIB.Halfedge -> SCRIB.Face_Info
     */

    PolylineGraphPostProcessor.prototype._traceUnionFace = function(face_ID_set, start) {
      var current, current_face_ID, current_point_info, output, output_ID_set;
      output = new SCRIB.Face_Info();
      output_ID_set = output.faces_ID_set;
      current = start;
      while (true) {
        current.data.marked = true;
        current_point_info = this._halfedgeToPointInfo(current);
        output.push(current_point);
        current_face_ID = current.face.ID;
        output_ID_set.add(current_face_ID);
        current = this._nextUnionFace(face_ID_set, current);
        if (current === start) {
          break;
        }
      }
      return output;
    };

    PolylineGraphPostProcessor.prototype._nextUnionFace = function(face_ID_Set, current) {
      current = current.twin.prev.twin;
      while (!this._halfedgeInUnion(face_ID_Set, current)) {
        current = current.prev.twin;
      }
      return current;
    };

    PolylineGraphPostProcessor.prototype._halfedgeToPointInfo = function(halfedge) {
      var vertex, vertex_data;
      vertex = halfedge.vertex;
      vertex_data = vertex.data;
      return new SCRIB.Point_Info(vertex_data.point, vertex.ID, halfedge);
    };

    PolylineGraphPostProcessor.prototype.generateBVH = function() {
      var polylines;
      polylines = this.facesToPolylines(this._face_vector, true);
      this._face_bvh = new BDS.BVH2D(polylines);
    };

    PolylineGraphPostProcessor.prototype.getBVHBoxPolylines = function() {
      return this._face_bvh.toPolylines();
    };

    PolylineGraphPostProcessor.prototype.facesToPolylines = function(face_infos, allow_complemented_faces) {
      var allow_compleemented_faces, face_info, j, len1, output, polyline;
      if (allow_complemented_faces === void 0) {
        allow_compleemented_faces = false;
      }
      output = [];
      for (j = 0, len1 = face_infos.length; j < len1; j++) {
        face_info = face_infos[j];
        polyline = face_info.polyline;
        if ((!polyline.isComplemented()) || allow_complemented_faces) {
          output.push(polyline);
        }
        continue;
      }
      return output;
    };

    PolylineGraphPostProcessor.prototype.polylinesToAssociatedData = function(polylines) {
      var j, len1, line, output;
      output = [];
      for (j = 0, len1 = polylines.length; j < len1; j++) {
        line = polylines[j];
        output.push(line.getAssociatedData());
      }
      return output;
    };

    PolylineGraphPostProcessor.prototype.embedAnotherPolyline = function(polyline) {
      var box, edge, edge_candidates, edge_info, face1, face2, generator, halfedge, halfedge_candidates, i_vert, index, intersection_list, isect, j, k, l, len1, len2, line, line2, linker, m, modified, n, new_line, old_end_vert, old_line, ref, ref1, ref2, ref3, ref4, singletonPolylines, split_line_index, split_lines, split_lines_start_index, split_verts, twin, v0, v1, v2, vert, vert_index, vert_point, verts;
      singletonPolylines = polyline.toPolylineSegments();
      generator = new SCRIB.PolylineGraphGenerator(this._graph);
      linker = new SCRIB.TopologyLinker(generator, this._graph);
      verts = [];
      v0 = generator.newVertex();
      v0.data.point = singletonPolylines[0].getPoint(0);
      verts.push(v0);
      for (j = 0, len1 = singletonPolylines.length; j < len1; j++) {
        line = singletonPolylines[j];
        vert = generator.newVertex();
        vert.data.point = line.getPoint(1);
        verts.push(vert);
      }
      if (verts.length < 2) {
        return;
      }
      split_lines = [];
      split_verts = [];
      for (index = k = 0, ref = singletonPolylines.length; k < ref; index = k += 1) {
        split_lines_start_index = split_lines.length;
        line = singletonPolylines[index];
        split_lines.push(line);
        split_verts.push(verts[index]);
        split_verts.push(verts[index + 1]);
        box = line.ensureBoundingBox();
        halfedge_candidates = this.query_halfedges_in_box(box);
        edge_candidates = this.halfedgesToEdges(halfedge_candidates);
        for (l = 0, len2 = edge_candidates.length; l < len2; l++) {
          edge_info = edge_candidates[l];
          edge = edge_info.edge;
          halfedge = edge.halfedge;
          twin = halfedge.twin;
          v1 = halfedge.vertex;
          v2 = twin.vertex;
          line2 = new BDS.Polyline(false, [v1.data.point, v2.data.point]);
          modified = false;
          for (split_line_index = m = ref1 = split_lines_start_index, ref2 = split_lines.length; m < ref2; split_line_index = m += 1) {
            line = split_lines[split_line_index];
            if (line.detect_intersection_with_polyline(line2)) {
              modified = true;
              intersection_list = line.report_intersections_with_polyline(line2);
              isect = intersection_list[0];
              vert_point = isect.point;
              vert_index = isect.index;
              i_vert = generator.newVertex();
              i_vert.data.point = vert_point;
              linker.split_edge_with_vert(edge, i_vert);
              ref3 = line.splitPolyline(vert_point, vert_index), old_line = ref3[0], new_line = ref3[1];
              split_lines[split_line_index] = old_line;
              old_end_vert = split_verts[split_line_index * 2 + 1];
              split_verts[split_line_index * 2 + 1] = i_vert;
              split_lines.push(new_line);
              split_verts.push(i_vert);
              split_verts.push(old_end_vert);
              continue;
            }
          }
          if (modified) {
            face1 = halfedge.face;
            face2 = twin.face;
            face1.data.info.generateBVH();
            if (face1 !== face2) {
              face2.data.info.generateBVH();
            }
          }
        }
      }
      for (index = n = 0, ref4 = split_verts.length; n < ref4; index = n += 2) {
        v1 = split_verts[index];
        v2 = split_verts[index + 1];
        linker.link_verts(v1, v2);
      }
      this._face_vector = [];
      this.generate_faces_info();
      this.generateBVH();
    };

    PolylineGraphPostProcessor.prototype.embedHole = function(polyline) {
      var face, faces, j, len1;
      faces = this.query_faces_at_pt(polyline.getFirstPoint());
      for (j = 0, len1 = faces.length; j < len1; j++) {
        face = faces[j];
        if (face.complemented === false) {
          face.addHole(polyline);
          return;
        }
      }
    };


    /*
     * Graph wide Edge Queries.
     * Returns all elements in the graph within the given regions.
     * NOTE: If you already have faces found, it will be better to use the Face_Info query functions.
     * Note: Edge queries are implemented by first performing a face query
     * and then performing edge queries on those face's edge bvh's in the Face_Info objects.
     */

    PolylineGraphPostProcessor.prototype.query_edges_in_circle = function(circle, output) {
      return this.query_edges_in_geometry(circle, output);
    };

    PolylineGraphPostProcessor.prototype.query_edges_in_polyline = function(polyline, output) {
      return this.query_edges_in_geometry(polyline, output);
    };

    PolylineGraphPostProcessor.prototype.query_edges_in_geometry = function(geom, output) {
      var edges, halfedge, j, len1, polyline;
      edges = this.query_halfedges_in_box(geom.generateBoundingBox());
      for (j = 0, len1 = edges.length; j < len1; j++) {
        halfedge = edges[j];
        polyline = halfedge.polyline;
        if (geom.detect_intersection_with_polyline(polyline)) {
          output.push(geom);
        }
      }
      return output;
    };

    PolylineGraphPostProcessor.prototype.query_halfedges_in_box = function(box, output) {
      var face, faces, j, len1;
      faces = this.query_faces_in_box(box);
      if (output === void 0) {
        output = [];
      }
      for (j = 0, len1 = faces.length; j < len1; j++) {
        face = faces[j];
        face.query_halfedges_in_box(box, output);
      }
      return output;
    };


    /*
     * Face Queries.
     * Returns elements within the face bvh in the given area regions.
     */

    PolylineGraphPostProcessor.prototype.query_faces_in_circle = function(circle) {
      return this.query_faces_in_geometry(circle);
    };

    PolylineGraphPostProcessor.prototype.query_faces_in_polyline = function(polyline) {
      return this.query_faces_in_geometry(polyline);
    };

    PolylineGraphPostProcessor.prototype.query_faces_in_geometry = function(geom) {
      var box, face_info, hole, holes, isects_hole, j, k, len1, len2, output, polyline, polylines_in_box;
      box = geom.generateBoundingBox();
      polylines_in_box = this._face_bvh.query_box_all(box);
      output = [];
      for (j = 0, len1 = polylines_in_box.length; j < len1; j++) {
        polyline = polylines_in_box[j];
        if (geom.detect_intersection_with_polyline(polyline)) {
          face_info = polyline.getAssociatedData();
          holes = face_info.getHoles();
          isects_hole = false;
          for (k = 0, len2 = holes.length; k < len2; k++) {
            hole = holes[k];
            if (geom.detect_intersection_with_polyline(hole)) {
              isects_hole = true;
              break;
            }
          }
          if (!isects_hole) {
            output.push(face_info);
          }
        }
      }
      return output;
    };

    PolylineGraphPostProcessor.prototype.query_faces_in_box = function(box) {
      return this.polylinesToAssociatedData(this._face_bvh.query_box_all(box));
    };

    PolylineGraphPostProcessor.prototype.query_faces_at_pt = function(pt) {
      var faces;
      faces = this._face_bvh.query_point_all(pt);
      return this.polylinesToAssociatedData(faces);
    };

    PolylineGraphPostProcessor.prototype.query_face_at_pt = function(pt) {
      var face_in_bvh, face_infos;
      face_in_bvh = this._face_bvh.query_point(pt);
      if (face_in_bvh === null) {
        return null;
      }
      face_infos = this.polylinesToAssociatedData([face_in_bvh]);
      return face_infos[0];
    };

    PolylineGraphPostProcessor.prototype.halfedgesToEdges = function(halfedge_infos) {
      var edge, edge_info, halfedge, halfedge_info, id, j, len1, output, set;
      output = [];
      set = new Set();
      for (j = 0, len1 = halfedge_infos.length; j < len1; j++) {
        halfedge_info = halfedge_infos[j];
        halfedge = halfedge_info.halfedge;
        edge = halfedge.edge;
        id = edge.id;
        if (set.has(id)) {
          continue;
        }
        set.add(id);
        edge_info = new SCRIB.Edge_Info(edge);
        output.push(edge_info);
        continue;
      }
      return output;
    };


    /*
     * Element Deletion Methods.
     * These delete all Halfedge Mesh elements within a given region.
     * They then rebuild and preserve the invariants of the mesh.
     */

    PolylineGraphPostProcessor.prototype.eraseEdges = function(edge_infos, params) {
      var edge_info, j, len1;
      for (j = 0, len1 = edge_infos.length; j < len1; j++) {
        edge_info = edge_infos[j];
        this._eraseEdge(edge_info, params);
      }
      this.generate_faces_info();
    };

    PolylineGraphPostProcessor.prototype._eraseEdge = function(edge_info, params) {
      var degree1, degree2, edge, face, face1, face2, halfedge, halfedge1, halfedge2, halfedge_info, merge_faces, next, prev, split_faces, vert1, vert2;
      halfedge = edge_info.edge.halfedge;
      halfedge_info = halfedge.data.info;
      halfedge1 = halfedge_info.halfedge;
      halfedge2 = halfedge1.twin;
      edge = halfedge1.edge;
      vert1 = halfedge1.vertex;
      vert2 = halfedge2.vertex;
      degree1 = vert1.degree();
      degree2 = vert2.degree();
      face1 = halfedge1.face;
      face2 = halfedge2.face;
      merge_faces = face1 !== face2;
      face = null;
      if (merge_faces) {
        face = this._merge_faces(face1, face2);
      } else {
        face = face1;
      }
      if (degree1 === 1) {
        if (params.erase_lonely_vertices) {
          vert1.destroy();
        } else {
          vert1.make_lonely();
        }
      }
      if (degree2 === 1) {
        if (params.erase_lonely_vertices) {
          vert2.destroy();
        } else {
          vert2.make_lonely();
        }
      }
      if (degree1 === 1 && degree2 === 1) {
        face1.destroy();
        edge.destroy();
        halfedge1.destroy();
        halfedge2.destroy();
        return;
      }
      if (degree2 > 1) {
        next = halfedge1.next;
        prev = halfedge2.prev;
        next.prev = prev;
        prev.next = next;
        face.halfedge = next;
        vert2.halfedge = next;
      }
      if (degree1 > 1) {
        next = halfedge2.next;
        prev = halfedge1.prev;
        next.prev = prev;
        prev.next = next;
        face.halfedge = next;
        vert1.halfedge = next;
      }
      split_faces = !merge_faces && degree1 > 1 && degree2 > 1;
      if (split_faces) {
        this._split_face_at_edge(edge);
      }
      if (!split_faces && !merge_faces) {
        face.data.marked = true;
      }
      halfedge1.destroy();
      halfedge2.destroy();
      edge.destroy();
    };

    PolylineGraphPostProcessor.prototype._merge_faces = function(face1, face2) {
      var current, h0, halfedge1, halfedge2, new_face;
      new_face = SCRIB.PolylineGraphEmbedder.newFace(this._graph);
      halfedge1 = face1.halfedge;
      halfedge2 = face2.halfedge;
      h0 = halfedge1;
      current = h0;
      while (true) {
        current.face = new_face;
        current = current.next;
        if (current === h0) {
          break;
        }
      }
      h0 = halfedge2;
      current = h0;
      while (true) {
        current.face = new_face;
        current = current.next;
        if (current === h0) {
          break;
        }
      }
      new_face.halfedge = h0;
      face1.destroy();
      face2.destroy();
      return new_face;
    };

    PolylineGraphPostProcessor.prototype._split_face_at_edge = function(edge) {
      var current, face_new1, face_new2, face_old, halfedge1, halfedge2, next1, next2, start;
      halfedge1 = edge.halfedge;
      halfedge2 = halfedge1.twin;
      face_new1 = SCRIB.PolylineGraphEmbedder.newFace(this._graph);
      face_new2 = SCRIB.PolylineGraphEmbedder.newFace(this._graph);
      face_old = halfedge1.next.face;
      face_old.destroy();
      next1 = halfedge1.next;
      next2 = halfedge2.next;
      face_new1.halfedge = next1;
      face_new2.halfedge = next2;
      start = next1;
      current = start;
      while (true) {
        current.face = face_new1;
        current = current.next;
        if (current === start) {
          break;
        }
      }
      start = next2;
      current = start;
      while (true) {
        current.face = face_new2;
        current = current.next;
        if (current === start) {
          break;
        }
      }
      return [face_new1, face_new2];
    };

    return PolylineGraphPostProcessor;

  })();

}).call(this);

// Generated by CoffeeScript 1.11.1

/*

Face Graph.

Written by Bryce Summers on 2 - 12 - 2017.

Purpose: Represents face to face connectivity, such as that needed for coloring.
 */

(function() {
  SCRIB.FaceGraph = (function() {
    function FaceGraph(graph) {
      var edge, face, face1, face2, halfedge, iter;
      this.faces = {};
      iter = graph.facesBegin();
      while (iter.hasNext()) {
        face = iter.next();
        this.faces[face.id] = [];
      }
      iter = graph.edgesBegin();
      while (iter.hasNext()) {
        edge = iter.next();
        halfedge = edge.halfedge;
        face1 = halfedge.face;
        face2 = halfedge.twin.face;
        this.faces[face1.id].push(face2);
        this.faces[face2.id].push(face1);
      }
    }

    FaceGraph.prototype.autoColor = function() {
      var face_id_order, i, id_degree, id_degrees, key, len, ref, value;
      id_degrees = [];
      ref = this.faces;
      for (key in ref) {
        value = ref[key];
        id_degrees.push([parseInt(key), value.length]);
      }
      id_degrees.sort(function(a, b) {
        var degree1, degree2;
        degree1 = a[1];
        degree2 = b[1];
        return degree1 - degree2;
      });
      face_id_order = [];
      for (i = 0, len = id_degrees.length; i < len; i++) {
        id_degree = id_degrees[i];
        face_id_order.push(id_degree[0]);
      }
      return this.greedyColor(face_id_order);
    };

    FaceGraph.prototype.greedyColor = function(face_id_order) {
      var colored, coloring, face, face_id, i, index, j, len, len1, neighbors, taken;
      coloring = {};
      colored = new Set();
      for (i = 0, len = face_id_order.length; i < len; i++) {
        face_id = face_id_order[i];
        neighbors = this.faces[face_id];
        taken = new Set();
        for (j = 0, len1 = neighbors.length; j < len1; j++) {
          face = neighbors[j];
          if (!colored.has(face.id)) {
            continue;
          }
          taken.add(coloring[face.id]);
        }
        index = 0;
        while (taken.has(index)) {
          index++;
        }
        coloring[face_id] = index;
        colored.add(face_id);
      }
      return coloring;
    };

    return FaceGraph;

  })();

}).call(this);

// Generated by CoffeeScript 1.11.1

/*
Halfedge Graph / Mesh class.
Written by Bryce Summers on 1 - 2 - 2017.
 */


/*
* FIXME: Writeup my modified usage, now that we are in javasccript.
*
* Usage:
*
* The Application programmer / New Media Artist specifies the following:
* 1. The data format they have availible for graph construction (e.g. vectors of openframeworks points.)
* 2. The Algorithms they need.
* 3. The data format that they wish to receive the results in.
*
* They will do so by specifying which class definitions they want.
*
* The algorithm designer / computational geometer specifies the following:
* 1. Definitions for the associated data.
* 2. The interface for constructing Graphs from application data
* 3. The interface for running algorithms on the Graphs.
* 4. The interface for allowing the application programmer to retrieve the results.
*
* If done elegantly, the New Media Artist should never need to touch the halfedge mesh, go on pointer journeys, and
* they should be able to treat the internal implementation as a black box.
 */


/*
 * -- Associated Data Classes.

#Since Javascript is untyped, these will mostly be her for convenience, and the user can insert the data they wish into each of these structures.

Every graph element will have a reserved variable called 'data' for linking to application specific information.

class SCRIB.Graph_Data
class SCRIB.Vertex_Data
class SCRIB.Face_Data
class SCRIB.Halfedge_Data
class SCRIB.Edge_Data
 */


/*
// FIXME: Clean up this prose.

// -- Structural definition of classes.
// Every class is specified by its connectivity information and a pointer to associated user data.

// All elements may be marked and unmarked by algorithms and users to specific sets of elements that meet various criteria.

// The Graph class represents an entire graph embedding defined by points in space.
// For the purposes of the facefinder, the output graph will be planar.
// connected via edges that intersect only at vertices.
// The FaceFinder class may be used to derive a Graph from a set of potentially intersecting input polylines.
 */

(function() {
  SCRIB.Graph = (function() {

    /*
    // Graph classes are where all of the actual data will be stored, so it contains vectors of valued data,
    // rather than pointers.
    // All ID's contained within these vectors will reference tha index of the object within these vectors.
    
    // Ideally, vertices, edges, and halfedges will be ordered logically according to the order they were input into the facefinder,
    // but I will need to do some more thinking on how to formally specify these things.
     */
    function Graph(_allocate_index_arrays) {
      this._allocate_index_arrays = _allocate_index_arrays;
      this._faces = new BDS.DoubleLinkedList();
      this._vertices = new BDS.DoubleLinkedList();
      this._edges = new BDS.DoubleLinkedList();
      this._halfedges = new BDS.DoubleLinkedList();
      this._next_face_id = 0;
      this._next_vertice_id = 0;
      this._next_edge_id = 0;
      this._next_halfedge_id = 0;
      if (this._allocate_index_arrays) {
        this._face_array = [];
        this._vertex_array = [];
        this._edge_array = [];
        this._halfedge_array = [];
      }
      this._data = null;
    }

    Graph.prototype.newFace = function() {
      var id, iter, output;
      id = this._next_face_id++;
      output = new SCRIB.Face();
      this._faces.push_back(output);
      if (this._face_array) {
        this._face_array.push(output);
      }
      output.id = id;
      iter = this._faces.end();
      iter.prev()._iterator = iter;
      return output;
    };

    Graph.prototype.newVertex = function() {
      var id, iter, output;
      id = this._next_vertice_id++;
      output = new SCRIB.Vertex();
      this._vertices.push_back(output);
      if (this._vertex_array) {
        this._vertex_array.push(output);
      }
      output.id = id;
      iter = this._vertices.end();
      iter.prev()._iterator = iter;
      return output;
    };

    Graph.prototype.newEdge = function() {
      var id, iter, output;
      id = this._next_edge_id++;
      output = new SCRIB.Edge();
      this._edges.push_back(output);
      if (this._edge_array) {
        this._edge_array.push(output);
      }
      output.id = id;
      iter = this._edges.end();
      iter.prev()._iterator = iter;
      return output;
    };

    Graph.prototype.newHalfedge = function() {
      var id, iter, output;
      id = this._next_halfedge_id++;
      output = new SCRIB.Halfedge();
      this._halfedges.push_back(output);
      if (this._halfedge_array) {
        this._halfedge_array.push(output);
      }
      output.id = id;
      iter = this._halfedges.end();
      iter.prev()._iterator = iter;
      return output;
    };

    Graph.prototype.deleteElement = function(e) {
      return e._iterator.remove();
    };

    Graph.prototype.getData = function() {
      return this._data;
    };

    Graph.prototype.numFaces = function() {
      return this._faces.size();
    };

    Graph.prototype.numVertices = function() {
      return this._vertices.size();
    };

    Graph.prototype.numEdges = function() {
      return this._edges.size();
    };

    Graph.prototype.numHalfedges = function() {
      return this._halfedges.size();
    };

    Graph.prototype.getFace = function(id) {
      return this._face_array[id];
    };

    Graph.prototype.getVertex = function(id) {
      return this._vertex_array[id];
    };

    Graph.prototype.getEdge = function(id) {
      return this._edge_array[id];
    };

    Graph.prototype.getHalfedge = function(id) {
      return this._halfedge_array[id];
    };

    Graph.prototype.delete_index_arrays = function() {
      delete this._face_array;
      delete this._vertex_array;
      delete this._edge_array;
      return delete this._halfedge_array;
    };


    /*
     - Iteration functions.
     - These all return BDS.DoubleListIterator's
     */

    Graph.prototype.facesBegin = function() {
      return this._faces.begin();
    };

    Graph.prototype.facesEnd = function() {
      return this._faces.end();
    };

    Graph.prototype.verticesBegin = function() {
      return this._vertices.begin();
    };

    Graph.prototype.verticesEnd = function() {
      return this._vertices.end();
    };

    Graph.prototype.edgesBegin = function() {
      return this._edges.begin();
    };

    Graph.prototype.edgesEnd = function() {
      return this._edges.end();
    };

    Graph.prototype.halfedgesBegin = function() {
      return this._halfedges.begin();
    };

    Graph.prototype.halfedgesEnd = function() {
      return this._halfedges.end();
    };

    return Graph;

  })();

  SCRIB.Face = (function() {
    function Face() {
      this.halfedge = null;
      this.data = null;
      this.id = null;
      this._iterator = null;
    }

    Face.prototype.destroy = function() {
      return this._iterator.remove();
    };

    return Face;

  })();

  SCRIB.Vertex = (function() {
    function Vertex() {
      this.halfedge = null;
      this.data = null;
      this.id = null;
      this._iterator = null;
    }

    Vertex.prototype.destroy = function() {
      return this._iterator.remove();
    };

    Vertex.prototype.isAlone = function() {
      return this.halfedge === null || this.halfedge.next === this.halfedge;
    };

    Vertex.prototype.degree = function() {
      var count, current, start;
      start = this.halfedge;
      current = start.twin.next;
      count = 1;
      while (start !== current) {
        count++;
        current = current.twin.next;
        continue;
      }
      return count;
    };

    Vertex.prototype.make_lonely = function() {
      return this.halfedge = null;
    };

    Vertex.prototype.get_outgoing_halfedge_to = function(vert) {
      var current, start;
      start = this.halfedge.twin;
      current = start.next.twin;
      while (true) {
        if (current.vertex === vert) {
          return current.twin;
        }
        if (current === start) {
          return null;
        }
        current = current.next.twin;
      }
    };

    return Vertex;

  })();

  SCRIB.Edge = (function() {
    function Edge() {}

    Edge.halfedge = null;

    Edge.data = null;

    Edge.id = null;

    Edge._iterator = null;

    Edge.prototype.destroy = function() {
      return this._iterator.remove();
    };

    return Edge;

  })();

  SCRIB.Halfedge = (function() {
    function Halfedge() {
      this.twin = null;
      this.next = null;
      this.prev = null;
      this.face = null;
      this.edge = null;
      this.vertex = null;
      this.data = null;
      this.id = null;
      this._iterator = null;
    }

    Halfedge.prototype.destroy = function() {
      return this._iterator.remove();
    };

    return Halfedge;

  })();

}).call(this);

// Generated by CoffeeScript 1.11.1

/*

Topology Processor.

Written by Bryce Summers on 1 - 27 - 2017.

Provides general purpose topological modification functions for HalfedgeGraphs, and primarily those that are interpreted as Planar embeddings.

Some of the functions require that 

Takes freshly allocated, but unlinked topologies and correctly links or unlinks them.

This class only performs linking, any allocation of metadata should be handled elsewhere in classes that support topological element allocation.


Terminology:

    Island: A singleton vertex.
    Continent: A connected component surrounded by an external face.
    Tail: A region including edges that have the same face on both sides.

    unlinked: an element that contains only null pointers.
    linked: an element that contains relevant pointers to other elements, which is assumed to fullfill the topological invariants of a Halfedgemesh.
 */

(function() {
  SCRIB.TopologyLinker = (function() {
    function TopologyLinker(generator, graph) {
      this.generator = generator;
      this.graph = graph;
    }

    TopologyLinker.prototype.link_island_vertex = function(vertex) {
      vertex.halfedge = null;

      /*
      edge     = @generator.newEdge(@graph)
      halfedge = @generator.newHalfedge(@graph)
      twin     = @generator.newHalfedge(@graph)
      interior = @generator.newFace(@graph)
      exterior = @generator.newFace(@graph)
      
       * 1 point Sub Graph.
      
      vertex.halfedge = halfedge
      edge.halfedge   = halfedge
      
       * The interior is trivial and is defined by a trivial internal and external null area point boundary.
      
       * Self referential exterior loop.
      halfedge.edge   = edge
      halfedge.face   = exterior
      halfedge.next   = halfedge
      halfedge.prev   = halfedge
      halfedge.twin   = twin
      halfedge.vertex = vertex
      exterior.halfedge = halfedge
      
       * Self referential interior loop.
      twin.edge   = edge
      twin.face   = interior
      twin.next   = twin
      twin.prev   = twin
      twin.twin   = halfedge
      twin.vertex = vertex
      interior.halfedge = twin
       */
      return vertex;
    };

    TopologyLinker.prototype.unlink_island_vertex = function(vertex) {

      /*
      he1   = vertex.halfedge
      he2   = he1.twin
      edge  = he1.edge
      face1 = he1.face
      face2 = he2.face
      
      he1.destroy()
      he2.destroy()
      edge.destroy()
      face1.destroy()
      face2.destroy()
      
      vertex.halfedge = null
       */
    };

    TopologyLinker.prototype.link_verts = function(v1, v2) {
      var external_he, he1, he2, next1, next2, ref;
      if (v1.isAlone() && v2.isAlone()) {
        this.unlink_island_vertex(v1);
        this.unlink_island_vertex(v2);
        this.link_vert_line_continent([v1, v2]);
        return;
      }
      if (v1.isAlone()) {
        this.unlink_island_vertex(v1);
        external_he = this.find_halfedge_at_vert_containing_vert(v2, v1);
        this.link_vert_to_external_face(v1, external_he);
        return;
      }
      if (v2.isAlone()) {
        this.unlink_island_vertex(v2);
        external_he = this.find_halfedge_at_vert_containing_vert(v1, v2);
        this.link_vert_to_external_face(v2, external_he);
        return;
      }
      ref = this.find_cycle_containing_vert_segment(v1, v2), next1 = ref[0], next2 = ref[1];
      if (next1 !== null) {
        this.split_face_by_adding_edge(next1, next2);
        return;
      }
      he1 = this.find_halfedge_at_vert_containing_vert(v1, v2);
      he2 = this.find_halfedge_at_vert_containing_vert(v2, v1);
      this.union_faces_by_adding_edge(he1, he2);
    };

    TopologyLinker.prototype.find_halfedge_at_vert_containing_vert = function(star_vert, target_vert) {
      var current, next, start, vert_a, vert_b, vert_c;
      start = star_vert.halfedge;
      current = start;
      while (true) {
        next = current.twin.next;
        vert_a = next.twin.vertex;
        vert_b = star_vert;
        vert_c = current.twin.vertex;
        if (this.generator.vert_in_angle(vert_a, vert_b, vert_c, target_vert)) {
          return next;
        }
        current = current.twin.next;
        if (current === start) {
          debugger;
          throw new Error("Proper angle segment not found.");
        }
      }
    };

    TopologyLinker.prototype.find_outgoing_halfedge_on_cycle = function(halfedge_on_cycle, target_vertex) {
      var current, start;
      start = halfedge_on_cycle;
      current = start;
      while (true) {
        if (current.vertex === target_vertex) {
          return current;
        }
        current = current.next;
        if (current === start) {
          break;
        }
      }
      return null;
    };

    TopologyLinker.prototype.find_cycle_containing_both_verts = function(v1, v2) {
      var current, he_v2, start;
      start = v1.halfedge;
      current = start;
      while (true) {
        he_v2 = this.find_outgoing_halfedge_on_cycle(current, v2);
        if (he_v2 !== null) {
          return [current, he_v2];
        }
        current = current.twin.next;
        if (current === start) {
          break;
        }
      }
      return [null, null];
    };

    TopologyLinker.prototype.find_cycle_containing_vert_segment = function(v1, v2) {
      var a, b, ref;
      ref = this.find_cycle_containing_both_verts(v1, v2), a = ref[0], b = ref[1];
      if (a === null) {
        return [null, null];
      }
      a = this.find_halfedge_at_vert_containing_vert(v1, v2);
      b = this.find_halfedge_at_vert_containing_vert(v2, v1);
      if (a.face !== b.face) {
        debugger;
        throw new Error("This should not be possible.");
      }
      return [a, b];

      /*
      start   = v1.halfedge
      current = start
      
      start1 = null
      end1   = null
      start2 = null
      end2   = null
      
       * Find a first pair.
      loop
          he_v2 = @find_outgoing_halfedge_on_cycle(current, v2)
      
          if he_v2 != null
              start1 = current
              end1   = he_v2
              break
      
          current = current.twin.next
          break unless current != start
      
       * Find a second pair.
      current = current.twin.next
      loop
          he_v2 = @find_outgoing_halfedge_on_cycle(current, v2)
      
          if he_v2 != null
              start2 = current
              end2   = he_v2
              break
      
          current = current.twin.next
          break unless current != start
      
       * Case 1: Didn't find anything.
      if start1 == null
          return [null, null]
      
       * Case 2: At least one of the vertices has more than 1 outgoing halfedge on the same face.
      start1 = @away_from_star_point(start1, end1)
      start2 = @away_from_star_point(end1, start1)
      
       * If this halfedge goes left towards the vert, then it must be the right one.
       * FIXME: This may fail with internal stars.
      if @left_test(start1, v2)
          return [start1, @towards_star_point(start2, start1)]
      if @left_test(start2, v1)
          return [start2, @towards_star_point(start1, start2)]
      
       * Case: 3: This is a loop topology, and we can safely use the alternate unique cycle.
       * FIXME: This ignores internal stars.
      return [start2, end2]
       */
    };

    TopologyLinker.prototype.away_from_star_point = function(candidate_halfedge, target_halfedge) {
      var current, start, vertex;
      vertex = candidate_halfedge.vertex;
      start = candidate_halfedge;
      current = start;
      while (true) {
        current = current.next;
        if (current === target_halfedge) {
          return candidate_halfedge;
        }
        if (current.vertex === vertex) {
          candidate_halfedge = current;
        }
        if (current === start) {
          return candidate_halfedge;
        }
      }
      throw new Error("Never get here.");
    };

    TopologyLinker.prototype.towards_star_point = function(candidate_halfedge, target_halfedge) {
      var current, start, vertex;
      vertex = candidate_halfedge.vertex;
      start = candidate_halfedge;
      current = start;
      while (true) {
        current = current.prev;
        if (current === target_halfedge) {
          return candidate_halfedge;
        }
        if (current.vertex === vertex) {
          candidate_halfedge = current;
        }
        if (current === start) {
          return candidate_halfedge;
        }
      }
      throw new Error("Never get here.");
    };

    TopologyLinker.prototype.left_test = function(halfedge, target_vert) {
      var vert1, vert2, vert_c;
      vert1 = halfedge.vertex;
      vert2 = halfedge.next.vertex;
      vert_c = target_vert;
      return this.generator.line_side_test(vert1, vert2, vert_c) < 0;
    };

    TopologyLinker.prototype.find_complemented_cycle_at_vert = function(vert) {
      var current, start;
      start = vert.halfedge;
      current = start;
      while (true) {
        if (this.is_cycle_complemented(current)) {
          return current;
        }
        current === current.twin.next;
        if (current === start) {
          break;
        }
      }
    };

    TopologyLinker.prototype.is_cycle_complemented = function(halfedge) {
      var addVert, polyline;
      polyline = new BDS.Polyline(true);
      addVert = function(vert) {
        return this.polyline.addPoint(vert.data.point);
      };
      addVert.polyline = polyline;
      this.map_cycle_vertices(halfedge, addVert);
      return polyline.isComplemented();
    };

    TopologyLinker.prototype.map_cycle_vertices = function(halfedge, f_of_v) {
      var current, start;
      start = halfedge;
      current = start;
      while (true) {
        f_of_v(current.vertex);
        current = current.next;
        if (current === start) {
          break;
        }
      }
    };

    TopologyLinker.prototype.find_outgoing_halfedge_on_face = function(vertex, face) {
      var current, start;
      start = vertex.halfedge;
      current = start;
      while (true) {
        if (current.face === face) {
          return current;
        }
        current = current.twin.next;
        if (current !== start) {
          break;
        }
      }
      return null;
    };

    TopologyLinker.prototype.split_face_by_adding_edge = function(he1, he2) {
      return this._link_edge_to_cycle_locations(he1, he2);
    };

    TopologyLinker.prototype.union_faces_by_adding_edge = function(he1, he2) {
      var face1, face2;
      face1 = he1.face;
      face2 = he2.face;
      this._link_edge_to_cycle_locations(he1, he2);
      face1.destroy();
      return face2.destroy();
    };

    TopologyLinker.prototype._link_edge_to_cycle_locations = function(he1, he2) {
      var new_edge, new_face, new_he1, new_he2, next1, next2, old_face, prev1, prev2, vert1, vert2;
      next1 = he1;
      next2 = he2;
      prev1 = next1.prev;
      prev2 = next2.prev;
      vert1 = next1.vertex;
      vert2 = next2.vertex;
      old_face = next1.face;
      new_edge = this.generator.newEdge();
      new_he1 = this.generator.newHalfedge();
      new_he2 = this.generator.newHalfedge();
      new_face = this.generator.newFace();
      new_edge.halfedge = new_he1;
      new_he1.next = next2;
      new_he1.prev = prev1;
      new_he1.vertex = vert1;
      new_he1.twin = new_he2;
      new_he1.face = old_face;
      new_he1.edge = new_edge;
      next2.prev = new_he1;
      prev1.next = new_he1;
      new_he2.next = next1;
      new_he2.prev = prev2;
      new_he2.vertex = vert2;
      new_he2.twin = new_he1;
      new_he2.face = old_face;
      new_he2.edge = new_edge;
      next1.prev = new_he2;
      prev2.next = new_he2;
      this.link_cycle_to_face(new_he1, new_face);
      new_face.halfedge = new_he1;
      old_face.halfedge = new_he2;
    };

    TopologyLinker.prototype.link_cycle_to_face = function(halfedge, face_target) {
      var current, start;
      start = halfedge;
      current = start;
      while (true) {
        current.face = face_target;
        current = current.next;
        if (current === start) {
          break;
        }
      }
    };

    TopologyLinker.prototype.link_vert_to_external_face = function(vert, external_halfedge) {
      var edge, external_face, he1, he2, prev_external;
      he1 = this.generator.newHalfedge();
      he2 = this.generator.newHalfedge();
      edge = this.generator.newEdge();
      vert.halfedge = he1;
      he1.vertex = vert;
      he2.vertex = external_halfedge.vertex;
      he1.twin = he2;
      he2.twin = he1;
      he1.edge = edge;
      he2.edge = edge;
      edge.halfedge = he1;
      prev_external = external_halfedge.prev;
      he1.next = external_halfedge;
      he1.prev = he2;
      he2.prev = prev_external;
      he2.next = he1;
      prev_external.next = he2;
      external_halfedge.prev = he1;
      external_face = external_halfedge.face;
      he1.face = external_face;
      he2.face = external_face;
    };

    TopologyLinker.prototype.unlink_edge = function(edge, params) {
      var degree1, degree2, face, face1, face2, halfedge1, halfedge2, merge_faces, next, prev, split_faces, vert1, vert2;
      if (edge === null) {
        debugger;
      }
      halfedge1 = edge.halfedge;
      halfedge2 = halfedge1.twin;
      vert1 = halfedge1.vertex;
      vert2 = halfedge2.vertex;
      degree1 = vert1.degree();
      degree2 = vert2.degree();
      face1 = halfedge1.face;
      face2 = halfedge2.face;
      merge_faces = face1 !== face2;
      face = null;
      if (merge_faces) {
        face = this._merge_faces(face1, face2);
      } else {
        face = face1;
      }
      if (degree1 === 1) {
        if (params.erase_lonely_vertices) {
          vert1.destroy();
        } else {
          this.link_island_vertex(vert1);
        }
      }
      if (degree2 === 1) {
        if (params.erase_lonely_vertices) {
          vert2.destroy();
        } else {
          this.link_island_vertex(vert2);
        }
      }
      if (degree1 === 1 && degree2 === 1) {
        face1.destroy();
        edge.destroy();
        halfedge1.destroy();
        halfedge2.destroy();
        return;
      }
      if (degree2 > 1) {
        next = halfedge1.next;
        prev = halfedge2.prev;
        next.prev = prev;
        prev.next = next;
        face.halfedge = next;
        vert2.halfedge = next;
      }
      if (degree1 > 1) {
        next = halfedge2.next;
        prev = halfedge1.prev;
        next.prev = prev;
        prev.next = next;
        face.halfedge = next;
        vert1.halfedge = next;
      }
      split_faces = !merge_faces && degree1 > 1 && degree2 > 1;
      if (split_faces) {
        this._split_face_by_removing_edge(edge);
      }
      if (!split_faces && !merge_faces) {
        face.data.marked = true;
      }
      halfedge1.destroy();
      halfedge2.destroy();
      edge.destroy();
    };

    TopologyLinker.prototype._merge_faces = function(face1, face2) {
      var current, h0, halfedge1, halfedge2, new_face;
      halfedge1 = face1.halfedge;
      halfedge2 = face2.halfedge;
      new_face = face1;

      /*
      h0 = halfedge1
      current = h0
      
      loop # DO
          current.face = new_face
          current = current.next
      
           * WHILE
          break unless current != h0
       */
      h0 = halfedge2;
      current = h0;
      while (true) {
        current.face = new_face;
        current = current.next;
        if (current === h0) {
          break;
        }
      }
      new_face.halfedge = h0;
      face2.destroy();
      return face1;
    };

    TopologyLinker.prototype._split_face_by_removing_edge = function(edge) {
      var current, face_new, face_new1, face_new2, face_old, halfedge1, halfedge2, next1, next2, start;
      halfedge1 = edge.halfedge;
      halfedge2 = halfedge1.twin;
      face_old = halfedge1.next.face;
      face_new = this.generator.newFace();
      face_new1 = face_new;
      face_new2 = face_old;
      next1 = halfedge1.next;
      next2 = halfedge2.next;
      face_new1.halfedge = next1;
      face_new2.halfedge = next2;
      start = next1;
      current = start;
      while (true) {
        current.face = face_new1;
        current = current.next;
        if (current === start) {
          break;
        }
      }
      start = next2;
      current = start;
      while (true) {
        current.face = face_new2;
        current = current.next;
        if (current === start) {
          break;
        }
      }
      return [face_new1, face_new2];
    };

    TopologyLinker.prototype.link_vert_line_continent = function(verts) {
      var back0, back1, back2, backwards_edges, complemented_face, edge, edges, first_index, forward_edges, halfedge1, halfedge2, he0, he1, he2, i, j, k, last_halfedge, last_index, ref, ref1, ref2, ref3;
      if (verts.length < 1) {
        return;
      }
      if (verts.length === 1) {
        this.link_island_vertex(verts[0]);
        return;
      }
      edges = [];
      forward_edges = [];
      backwards_edges = [];
      complemented_face = this.generator.newFace();
      first_index = 0;
      last_index = verts.length - 2;
      for (i = j = ref = first_index, ref1 = last_index; j <= ref1; i = j += 1) {
        edge = this.generator.newEdge();
        halfedge1 = this.generator.newHalfedge();
        halfedge2 = this.generator.newHalfedge();
        edge.halfedge = halfedge1;
        halfedge1.edge = edge;
        halfedge2.edge = edge;
        halfedge1.twin = halfedge2;
        halfedge2.twin = halfedge1;
        halfedge1.vertex = verts[i];
        halfedge2.vertex = verts[i + 1];
        halfedge1.face = complemented_face;
        halfedge2.face = complemented_face;
        verts[i].halfedge = halfedge1;
        edges.push(edge);
        forward_edges.push(halfedge1);
        backwards_edges.push(halfedge2);
      }
      last_halfedge = backwards_edges[last_index];
      verts[verts.length - 1].halfedge = last_halfedge;
      complemented_face.halfedge = last_halfedge;
      for (i = k = ref2 = first_index + 1, ref3 = last_index - 1; k <= ref3; i = k += 1) {
        he0 = forward_edges[i - 1];
        he1 = forward_edges[i];
        he2 = forward_edges[i + 1];
        back0 = backwards_edges[i + 1];
        back1 = backwards_edges[i];
        back2 = backwards_edges[i - 1];
        he1.prev = he0;
        he1.next = he2;
        back1.prev = back0;
        back1.next = back2;
      }
      forward_edges[first_index].prev = backwards_edges[first_index];
      backwards_edges[first_index].next = forward_edges[first_index];
      forward_edges[last_index].next = backwards_edges[last_index];
      backwards_edges[last_index].prev = forward_edges[last_index];
      if (first_index < last_index) {
        forward_edges[first_index].next = forward_edges[first_index + 1];
        backwards_edges[first_index].prev = backwards_edges[first_index + 1];
        forward_edges[last_index].prev = forward_edges[last_index - 1];
        backwards_edges[last_index].next = backwards_edges[last_index - 1];
      }
    };

    TopologyLinker.prototype.split_edge_with_vert = function(edge, vert) {
      var backwards1, backwards2, edge2, forwards1, forwards2;
      forwards1 = edge.halfedge;
      backwards1 = forwards1.twin;
      forwards2 = this.generator.newHalfedge();
      backwards2 = this.generator.newHalfedge();
      forwards2.vertex = vert;
      backwards2.vertex = vert;
      vert.halfedge = forwards2;
      edge2 = this.generator.newEdge();
      edge.halfedge = forwards1;
      edge2.halfedge = forwards2;
      forwards1.edge = edge;
      forwards2.edge = edge2;
      backwards1.edge = edge2;
      backwards2.edge = edge;
      forwards1.twin = backwards2;
      backwards2.twin = forwards1;
      forwards2.twin = backwards1;
      backwards1.twin = forwards2;
      forwards2.prev = forwards1;
      forwards2.next = forwards1.next;
      forwards2.next.prev = forwards2;
      forwards1.next = forwards2;
      backwards2.prev = backwards1;
      backwards2.next = backwards1.next;
      backwards2.next.prev = backwards2;
      backwards1.next = backwards2;
      forwards2.face = forwards1.face;
      backwards2.face = backwards1.face;

      /*
      if forwards1.prev == backwards1
          forwards1.prev = backwards2
      if backwards1.prev == forwards1
          backwards1.prev = forwards2
       */
    };

    return TopologyLinker;

  })();

}).call(this);
