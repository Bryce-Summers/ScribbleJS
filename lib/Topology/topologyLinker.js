// Generated by CoffeeScript 1.11.1

/*

Topology Processor.

Written by Bryce Summers on 1 - 27 - 2017.

Provides general purpose topological modification functions for HalfedgeGraphs, and primarily those that are interpreted as Planar embeddings.

Some of the functions require that 

Takes freshly allocated, but unlinked topologies and correctly links or unlinks them.

This class only performs linking, any allocation of metadata should be handled elsewhere in classes that support topological element allocation.


Terminology:

    Island: A singleton vertex.
    Continent: A connected component surrounded by an external face.
    Tail: A region including edges that have the same face on both sides.

    unlinked: an element that contains only null pointers.
    linked: an element that contains relevant pointers to other elements, which is assumed to fullfill the topological invariants of a Halfedgemesh.
 */

(function() {
  SCRIB.TopologyLinker = (function() {
    function TopologyLinker(generator, graph) {
      this.generator = generator;
      this.graph = graph;
    }

    TopologyLinker.prototype.link_island_vertex = function(vertex) {
      vertex.halfedge = null;

      /*
      edge     = @generator.newEdge(@graph)
      halfedge = @generator.newHalfedge(@graph)
      twin     = @generator.newHalfedge(@graph)
      interior = @generator.newFace(@graph)
      exterior = @generator.newFace(@graph)
      
       * 1 point Sub Graph.
      
      vertex.halfedge = halfedge
      edge.halfedge   = halfedge
      
       * The interior is trivial and is defined by a trivial internal and external null area point boundary.
      
       * Self referential exterior loop.
      halfedge.edge   = edge
      halfedge.face   = exterior
      halfedge.next   = halfedge
      halfedge.prev   = halfedge
      halfedge.twin   = twin
      halfedge.vertex = vertex
      exterior.halfedge = halfedge
      
       * Self referential interior loop.
      twin.edge   = edge
      twin.face   = interior
      twin.next   = twin
      twin.prev   = twin
      twin.twin   = halfedge
      twin.vertex = vertex
      interior.halfedge = twin
       */
      return vertex;
    };

    TopologyLinker.prototype.unlink_island_vertex = function(vertex) {

      /*
      he1   = vertex.halfedge
      he2   = he1.twin
      edge  = he1.edge
      face1 = he1.face
      face2 = he2.face
      
      he1.destroy()
      he2.destroy()
      edge.destroy()
      face1.destroy()
      face2.destroy()
      
      vertex.halfedge = null
       */
    };

    TopologyLinker.prototype.link_verts = function(v1, v2) {
      var external_he, he1, he2, next1, next2, ref;
      if (v1.isAlone() && v2.isAlone()) {
        this.unlink_island_vertex(v1);
        this.unlink_island_vertex(v2);
        this.link_vert_line_continent([v1, v2]);
        return;
      }
      if (v1.isAlone()) {
        this.unlink_island_vertex(v1);
        external_he = this.find_halfedge_at_vert_containing_vert(v2, v1);
        this.link_vert_to_external_face(v1, external_he);
        return;
      }
      if (v2.isAlone()) {
        this.unlink_island_vertex(v2);
        external_he = this.find_halfedge_at_vert_containing_vert(v1, v2);
        this.link_vert_to_external_face(v2, external_he);
        return;
      }
      ref = this.find_cycle_containing_vert_segment(v1, v2), next1 = ref[0], next2 = ref[1];
      if (next1 !== null) {
        this.split_face_by_adding_edge(next1, next2);
        return;
      }
      he1 = this.find_halfedge_at_vert_containing_vert(v1, v2);
      he2 = this.find_halfedge_at_vert_containing_vert(v2, v1);
      this.union_faces_by_adding_edge(he1, he2);
    };

    TopologyLinker.prototype.find_halfedge_at_vert_containing_vert = function(star_vert, target_vert) {
      var current, next, start, vert_a, vert_b, vert_c;
      start = star_vert.halfedge;
      current = start;
      while (true) {
        next = current.twin.next;
        vert_a = next.twin.vertex;
        vert_b = star_vert;
        vert_c = current.twin.vertex;
        if (this.generator.vert_in_angle(vert_a, vert_b, vert_c, target_vert)) {
          return next;
        }
        current = current.twin.next;
        if (current === start) {
          debugger;
          throw new Error("Proper angle segment not found.");
        }
      }
    };

    TopologyLinker.prototype.find_outgoing_halfedge_on_cycle = function(halfedge_on_cycle, target_vertex) {
      var current, start;
      start = halfedge_on_cycle;
      current = start;
      while (true) {
        if (current.vertex === target_vertex) {
          return current;
        }
        current = current.next;
        if (current === start) {
          break;
        }
      }
      return null;
    };

    TopologyLinker.prototype.find_cycle_containing_both_verts = function(v1, v2) {
      var current, he_v2, start;
      start = v1.halfedge;
      current = start;
      while (true) {
        he_v2 = this.find_outgoing_halfedge_on_cycle(current, v2);
        if (he_v2 !== null) {
          return [current, he_v2];
        }
        current = current.twin.next;
        if (current === start) {
          break;
        }
      }
      return [null, null];
    };

    TopologyLinker.prototype.find_cycle_containing_vert_segment = function(v1, v2) {
      var a, b, ref;
      ref = this.find_cycle_containing_both_verts(v1, v2), a = ref[0], b = ref[1];
      if (a === null) {
        return [null, null];
      }
      a = this.find_halfedge_at_vert_containing_vert(v1, v2);
      b = this.find_halfedge_at_vert_containing_vert(v2, v1);
      if (a.face !== b.face) {
        debugger;
        throw new Error("This should not be possible.");
      }
      return [a, b];

      /*
      start   = v1.halfedge
      current = start
      
      start1 = null
      end1   = null
      start2 = null
      end2   = null
      
       * Find a first pair.
      loop
          he_v2 = @find_outgoing_halfedge_on_cycle(current, v2)
      
          if he_v2 != null
              start1 = current
              end1   = he_v2
              break
      
          current = current.twin.next
          break unless current != start
      
       * Find a second pair.
      current = current.twin.next
      loop
          he_v2 = @find_outgoing_halfedge_on_cycle(current, v2)
      
          if he_v2 != null
              start2 = current
              end2   = he_v2
              break
      
          current = current.twin.next
          break unless current != start
      
       * Case 1: Didn't find anything.
      if start1 == null
          return [null, null]
      
       * Case 2: At least one of the vertices has more than 1 outgoing halfedge on the same face.
      start1 = @away_from_star_point(start1, end1)
      start2 = @away_from_star_point(end1, start1)
      
       * If this halfedge goes left towards the vert, then it must be the right one.
       * FIXME: This may fail with internal stars.
      if @left_test(start1, v2)
          return [start1, @towards_star_point(start2, start1)]
      if @left_test(start2, v1)
          return [start2, @towards_star_point(start1, start2)]
      
       * Case: 3: This is a loop topology, and we can safely use the alternate unique cycle.
       * FIXME: This ignores internal stars.
      return [start2, end2]
       */
    };

    TopologyLinker.prototype.away_from_star_point = function(candidate_halfedge, target_halfedge) {
      var current, start, vertex;
      vertex = candidate_halfedge.vertex;
      start = candidate_halfedge;
      current = start;
      while (true) {
        current = current.next;
        if (current === target_halfedge) {
          return candidate_halfedge;
        }
        if (current.vertex === vertex) {
          candidate_halfedge = current;
        }
        if (current === start) {
          return candidate_halfedge;
        }
      }
      throw new Error("Never get here.");
    };

    TopologyLinker.prototype.towards_star_point = function(candidate_halfedge, target_halfedge) {
      var current, start, vertex;
      vertex = candidate_halfedge.vertex;
      start = candidate_halfedge;
      current = start;
      while (true) {
        current = current.prev;
        if (current === target_halfedge) {
          return candidate_halfedge;
        }
        if (current.vertex === vertex) {
          candidate_halfedge = current;
        }
        if (current === start) {
          return candidate_halfedge;
        }
      }
      throw new Error("Never get here.");
    };

    TopologyLinker.prototype.left_test = function(halfedge, target_vert) {
      var vert1, vert2, vert_c;
      vert1 = halfedge.vertex;
      vert2 = halfedge.next.vertex;
      vert_c = target_vert;
      return this.generator.line_side_test(vert1, vert2, vert_c) < 0;
    };

    TopologyLinker.prototype.find_complemented_cycle_at_vert = function(vert) {
      var current, start;
      start = vert.halfedge;
      current = start;
      while (true) {
        if (this.is_cycle_complemented(current)) {
          return current;
        }
        current === current.twin.next;
        if (current === start) {
          break;
        }
      }
    };

    TopologyLinker.prototype.is_cycle_complemented = function(halfedge) {
      var addVert, polyline;
      polyline = new BDS.Polyline(true);
      addVert = function(vert) {
        return this.polyline.addPoint(vert.data.point);
      };
      addVert.polyline = polyline;
      this.map_cycle_vertices(halfedge, addVert);
      return polyline.isComplemented();
    };

    TopologyLinker.prototype.map_cycle_vertices = function(halfedge, f_of_v) {
      var current, start;
      start = halfedge;
      current = start;
      while (true) {
        f_of_v(current.vertex);
        current = current.next;
        if (current === start) {
          break;
        }
      }
    };

    TopologyLinker.prototype.find_outgoing_halfedge_on_face = function(vertex, face) {
      var current, start;
      start = vertex.halfedge;
      current = start;
      while (true) {
        if (current.face === face) {
          return current;
        }
        current = current.twin.next;
        if (current !== start) {
          break;
        }
      }
      return null;
    };

    TopologyLinker.prototype.split_face_by_adding_edge = function(he1, he2) {
      return this._link_edge_to_cycle_locations(he1, he2);
    };

    TopologyLinker.prototype.union_faces_by_adding_edge = function(he1, he2) {
      var face1, face2;
      face1 = he1.face;
      face2 = he2.face;
      this._link_edge_to_cycle_locations(he1, he2);
      face1.destroy();
      return face2.destroy();
    };

    TopologyLinker.prototype._link_edge_to_cycle_locations = function(he1, he2) {
      var new_edge, new_face, new_he1, new_he2, next1, next2, old_face, prev1, prev2, vert1, vert2;
      next1 = he1;
      next2 = he2;
      prev1 = next1.prev;
      prev2 = next2.prev;
      vert1 = next1.vertex;
      vert2 = next2.vertex;
      old_face = next1.face;
      new_edge = this.generator.newEdge();
      new_he1 = this.generator.newHalfedge();
      new_he2 = this.generator.newHalfedge();
      new_face = this.generator.newFace();
      new_edge.halfedge = new_he1;
      new_he1.next = next2;
      new_he1.prev = prev1;
      new_he1.vertex = vert1;
      new_he1.twin = new_he2;
      new_he1.face = old_face;
      new_he1.edge = new_edge;
      next2.prev = new_he1;
      prev1.next = new_he1;
      new_he2.next = next1;
      new_he2.prev = prev2;
      new_he2.vertex = vert2;
      new_he2.twin = new_he1;
      new_he2.face = old_face;
      new_he2.edge = new_edge;
      next1.prev = new_he2;
      prev2.next = new_he2;
      this.link_cycle_to_face(new_he1, new_face);
      new_face.halfedge = new_he1;
      old_face.halfedge = new_he2;
    };

    TopologyLinker.prototype.link_cycle_to_face = function(halfedge, face_target) {
      var current, start;
      start = halfedge;
      current = start;
      while (true) {
        current.face = face_target;
        current = current.next;
        if (current === start) {
          break;
        }
      }
    };

    TopologyLinker.prototype.link_vert_to_external_face = function(vert, external_halfedge) {
      var edge, external_face, he1, he2, prev_external;
      he1 = this.generator.newHalfedge();
      he2 = this.generator.newHalfedge();
      edge = this.generator.newEdge();
      vert.halfedge = he1;
      he1.vertex = vert;
      he2.vertex = external_halfedge.vertex;
      he1.twin = he2;
      he2.twin = he1;
      he1.edge = edge;
      he2.edge = edge;
      edge.halfedge = he1;
      prev_external = external_halfedge.prev;
      he1.next = external_halfedge;
      he1.prev = he2;
      he2.prev = prev_external;
      he2.next = he1;
      prev_external.next = he2;
      external_halfedge.prev = he1;
      external_face = external_halfedge.face;
      he1.face = external_face;
      he2.face = external_face;
    };

    TopologyLinker.prototype.unlink_edge = function(edge, params) {
      var degree1, degree2, face, face1, face2, halfedge1, halfedge2, merge_faces, next, prev, split_faces, vert1, vert2;
      if (edge === null) {
        debugger;
      }
      halfedge1 = edge.halfedge;
      halfedge2 = halfedge1.twin;
      vert1 = halfedge1.vertex;
      vert2 = halfedge2.vertex;
      degree1 = vert1.degree();
      degree2 = vert2.degree();
      face1 = halfedge1.face;
      face2 = halfedge2.face;
      merge_faces = face1 !== face2;
      face = null;
      if (merge_faces) {
        face = this._merge_faces(face1, face2);
      } else {
        face = face1;
      }
      if (degree1 === 1) {
        if (params.erase_lonely_vertices) {
          vert1.destroy();
        } else {
          this.link_island_vertex(vert1);
        }
      }
      if (degree2 === 1) {
        if (params.erase_lonely_vertices) {
          vert2.destroy();
        } else {
          this.link_island_vertex(vert2);
        }
      }
      if (degree1 === 1 && degree2 === 1) {
        face1.destroy();
        edge.destroy();
        halfedge1.destroy();
        halfedge2.destroy();
        return;
      }
      if (degree2 > 1) {
        next = halfedge1.next;
        prev = halfedge2.prev;
        next.prev = prev;
        prev.next = next;
        face.halfedge = next;
        vert2.halfedge = next;
      }
      if (degree1 > 1) {
        next = halfedge2.next;
        prev = halfedge1.prev;
        next.prev = prev;
        prev.next = next;
        face.halfedge = next;
        vert1.halfedge = next;
      }
      split_faces = !merge_faces && degree1 > 1 && degree2 > 1;
      if (split_faces) {
        this._split_face_by_removing_edge(edge);
      }
      if (!split_faces && !merge_faces) {
        face.data.marked = true;
      }
      halfedge1.destroy();
      halfedge2.destroy();
      edge.destroy();
    };

    TopologyLinker.prototype._merge_faces = function(face1, face2) {
      var current, h0, halfedge1, halfedge2, new_face;
      halfedge1 = face1.halfedge;
      halfedge2 = face2.halfedge;
      new_face = face1;

      /*
      h0 = halfedge1
      current = h0
      
      loop # DO
          current.face = new_face
          current = current.next
      
           * WHILE
          break unless current != h0
       */
      h0 = halfedge2;
      current = h0;
      while (true) {
        current.face = new_face;
        current = current.next;
        if (current === h0) {
          break;
        }
      }
      new_face.halfedge = h0;
      face2.destroy();
      return face1;
    };

    TopologyLinker.prototype._split_face_by_removing_edge = function(edge) {
      var current, face_new, face_new1, face_new2, face_old, halfedge1, halfedge2, next1, next2, start;
      halfedge1 = edge.halfedge;
      halfedge2 = halfedge1.twin;
      face_old = halfedge1.next.face;
      face_new = this.generator.newFace();
      face_new1 = face_new;
      face_new2 = face_old;
      next1 = halfedge1.next;
      next2 = halfedge2.next;
      face_new1.halfedge = next1;
      face_new2.halfedge = next2;
      start = next1;
      current = start;
      while (true) {
        current.face = face_new1;
        current = current.next;
        if (current === start) {
          break;
        }
      }
      start = next2;
      current = start;
      while (true) {
        current.face = face_new2;
        current = current.next;
        if (current === start) {
          break;
        }
      }
      return [face_new1, face_new2];
    };

    TopologyLinker.prototype.link_vert_line_continent = function(verts) {
      var back0, back1, back2, backwards_edges, complemented_face, edge, edges, first_index, forward_edges, halfedge1, halfedge2, he0, he1, he2, i, j, k, last_halfedge, last_index, ref, ref1, ref2, ref3;
      if (verts.length < 1) {
        return;
      }
      if (verts.length === 1) {
        this.link_island_vertex(verts[0]);
        return;
      }
      edges = [];
      forward_edges = [];
      backwards_edges = [];
      complemented_face = this.generator.newFace();
      first_index = 0;
      last_index = verts.length - 2;
      for (i = j = ref = first_index, ref1 = last_index; j <= ref1; i = j += 1) {
        edge = this.generator.newEdge();
        halfedge1 = this.generator.newHalfedge();
        halfedge2 = this.generator.newHalfedge();
        edge.halfedge = halfedge1;
        halfedge1.edge = edge;
        halfedge2.edge = edge;
        halfedge1.twin = halfedge2;
        halfedge2.twin = halfedge1;
        halfedge1.vertex = verts[i];
        halfedge2.vertex = verts[i + 1];
        halfedge1.face = complemented_face;
        halfedge2.face = complemented_face;
        verts[i].halfedge = halfedge1;
        edges.push(edge);
        forward_edges.push(halfedge1);
        backwards_edges.push(halfedge2);
      }
      last_halfedge = backwards_edges[last_index];
      verts[verts.length - 1].halfedge = last_halfedge;
      complemented_face.halfedge = last_halfedge;
      for (i = k = ref2 = first_index + 1, ref3 = last_index - 1; k <= ref3; i = k += 1) {
        he0 = forward_edges[i - 1];
        he1 = forward_edges[i];
        he2 = forward_edges[i + 1];
        back0 = backwards_edges[i + 1];
        back1 = backwards_edges[i];
        back2 = backwards_edges[i - 1];
        he1.prev = he0;
        he1.next = he2;
        back1.prev = back0;
        back1.next = back2;
      }
      forward_edges[first_index].prev = backwards_edges[first_index];
      backwards_edges[first_index].next = forward_edges[first_index];
      forward_edges[last_index].next = backwards_edges[last_index];
      backwards_edges[last_index].prev = forward_edges[last_index];
      if (first_index < last_index) {
        forward_edges[first_index].next = forward_edges[first_index + 1];
        backwards_edges[first_index].prev = backwards_edges[first_index + 1];
        forward_edges[last_index].prev = forward_edges[last_index - 1];
        backwards_edges[last_index].next = backwards_edges[last_index - 1];
      }
    };

    TopologyLinker.prototype.split_edge_with_vert = function(edge, vert) {
      var backwards1, backwards2, edge2, forwards1, forwards2;
      forwards1 = edge.halfedge;
      backwards1 = forwards1.twin;
      forwards2 = this.generator.newHalfedge();
      backwards2 = this.generator.newHalfedge();
      forwards2.vertex = vert;
      backwards2.vertex = vert;
      vert.halfedge = forwards2;
      edge2 = this.generator.newEdge();
      edge.halfedge = forwards1;
      edge2.halfedge = forwards2;
      forwards1.edge = edge;
      forwards2.edge = edge2;
      backwards1.edge = edge2;
      backwards2.edge = edge;
      forwards1.twin = backwards2;
      backwards2.twin = forwards1;
      forwards2.twin = backwards1;
      backwards1.twin = forwards2;
      forwards2.prev = forwards1;
      forwards2.next = forwards1.next;
      forwards2.next.prev = forwards2;
      forwards1.next = forwards2;
      backwards2.prev = backwards1;
      backwards2.next = backwards1.next;
      backwards2.next.prev = backwards2;
      backwards1.next = backwards2;
      forwards2.face = forwards1.face;
      backwards2.face = backwards1.face;

      /*
      if forwards1.prev == backwards1
          forwards1.prev = backwards2
      if backwards1.prev == forwards1
          backwards1.prev = forwards2
       */
    };

    return TopologyLinker;

  })();

}).call(this);
