// Generated by CoffeeScript 1.11.1
(function() {
  SCRIB.Testing = (function() {
    function Testing() {
      this.test_points();
      this.test_lines();
      this.test_intersector();
      console.log("All tests have passed!");
      document.getElementById("text").innerHTML = "All Tests Have Passed!";
    }

    Testing.prototype.ASSERT = function(b) {
      var err;
      if (!b) {
        err = new Error();
        console.log(err.stack);
        throw new Error("Assertion Failed!");
      }
    };

    Testing.prototype.test_points = function() {
      var mag, p0, p1, p2;
      p0 = new SCRIB.Point(1, 1, 1);
      p1 = new SCRIB.Point(2, 3, 4);
      p2 = p0.add(p1);
      this.ASSERT(p2.x === 3);
      this.ASSERT(p2.y === 4);
      this.ASSERT(p2.z === 5);
      p2 = p0.sub(p1);
      this.ASSERT(p2.x === -1);
      this.ASSERT(p2.y === -2);
      this.ASSERT(p2.z === -3);
      p2 = p1.sub(p0);
      this.ASSERT(p2.x === 1);
      this.ASSERT(p2.y === 2);
      this.ASSERT(p2.z === 3);
      p2 = p0.multScalar(5);
      this.ASSERT(p2.x === 5);
      this.ASSERT(p2.y === 5);
      this.ASSERT(p2.z === 5);
      p2 = new SCRIB.Point(5, 0);
      mag = p2.norm2();
      this.ASSERT(24.99 < mag && mag < 25.01);
      mag = p2.norm();
      return this.ASSERT(4.99 < mag && mag < 5.01);
    };

    Testing.prototype.test_lines = function() {
      var l0, l1, points, pt;
      points = [new SCRIB.Point(0, 0), new SCRIB.Point(2, 0), new SCRIB.Point(1, 1), new SCRIB.Point(1, -1)];
      l0 = new SCRIB.Line(0, 1, points);
      l1 = new SCRIB.Line(2, 3, points);
      this.ASSERT(points[0] === l0.p1);
      this.ASSERT(points[1] === l0.p2);
      this.ASSERT(points[2] === l1.p1);
      this.ASSERT(points[3] === l1.p2);
      this.ASSERT(l0.line_side_test(points[2]) * l0.line_side_test(points[3]) < 0);
      this.ASSERT(l0.detect_intersection(l1));
      this.ASSERT(l1.detect_intersection(l0));
      this.ASSERT(points.length === 4);
      this.ASSERT(l0.intersect(l1));
      pt = l0.getLatestIntersectionPoint();
      this.ASSERT(pt.y < .0001 && pt.y > -.0001);
      this.ASSERT(points.length === 5);
    };

    Testing.prototype.test_intersector = function() {
      var i, i1, i2, intersector, j, k, l, len, lines, m, n, o, p, points, q, r, ref, ref1, ref2, ref3, ref4, ref5, ref6, ref7, ref8, split_lines;
      len = 100;
      points = [new SCRIB.Point(0, 0), new SCRIB.Point(100, 0)];
      for (i = j = 0, ref = len; j < ref; i = j += 1) {
        points.push(new SCRIB.Point(i + .1, -1));
        points.push(new SCRIB.Point(i + .1, 1));
      }
      lines = [];
      lines.push(new SCRIB.Line(0, 1, points));
      for (i = k = 0, ref1 = len; k < ref1; i = k += 1) {
        i1 = 2 + i * 2;
        i2 = 2 + i * 2 + 1;
        lines.push(new SCRIB.Line(i1, i2, points));
      }
      intersector = new SCRIB.Intersector();

      /*
      Test Brute Force intersection.
       */
      intersector.intersect_brute_force(lines);
      split_lines = [];
      len = lines.length;
      for (i = l = 0, ref2 = len; l < ref2; i = l += 1) {
        lines[i].getSplitLines(split_lines);
      }
      this.ASSERT(split_lines.length === 101 + 100 + 100);
      for (i = m = 1, ref3 = len; m < ref3; i = m += 1) {
        this.ASSERT(Math.floor(split_lines[i].p1.x) === i - 1);
        this.ASSERT(Math.floor(split_lines[i].p2.x) === i);
      }
      for (i = n = 0, ref4 = len; 0 <= ref4 ? n < ref4 : n > ref4; i = 0 <= ref4 ? ++n : --n) {
        lines[i].clearIntersections();
      }

      /*
      Test Optimized Intersection.
       */
      len = 100;
      points = [new SCRIB.Point(0, 0), new SCRIB.Point(100, 0)];
      for (i = o = 0, ref5 = len; o < ref5; i = o += 1) {
        points.push(new SCRIB.Point(i + .1, -1));
        points.push(new SCRIB.Point(i + .1, 1));
      }
      lines = [];
      lines.push(new SCRIB.Line(0, 1, points));
      for (i = p = 0, ref6 = len; p < ref6; i = p += 1) {
        i1 = 2 + i * 2;
        i2 = 2 + i * 2 + 1;
        lines.push(new SCRIB.Line(i1, i2, points));
      }
      intersector.intersect(lines);
      split_lines = [];
      len = lines.length;
      for (i = q = 0, ref7 = len; q < ref7; i = q += 1) {
        lines[i].getSplitLines(split_lines);
      }
      this.ASSERT(split_lines.length === 101 + 100 + 100);
      for (i = r = 1, ref8 = len; r < ref8; i = r += 1) {
        this.ASSERT(Math.floor(split_lines[i].p1.x) === i - 1);
        this.ASSERT(Math.floor(split_lines[i].p2.x) === i);
      }
    };

    Testing.prototype.test_halfedge = function() {};

    return Testing;

  })();

  new SCRIB.Testing();

}).call(this);
