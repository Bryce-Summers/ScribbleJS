// Generated by CoffeeScript 1.11.1

/*
The PolylineGraphPostProcessor class.
*
* Written and adapted from FaceFinder on 8/18/2016.
* Ported to Coffeescript on 1 - 4 - 2017.
*
* Purpose:
*
* Allows users to convert Planar Polyline Embedded Graphs into mainstream C++ data structures.
* This class then provides some useful processing algorithms on these output structures.
*
* I may also put information extraction algorithms here.
*
* The key idea is that the post processor doesn't mutate the Graph object in any way.
* FIXME: Use the Graph Mutator Proccessor instead (Currenly non existant.) if you wish to modify the graph.
*
* Maybe I will make a modification mode.
 */


/*

Tested Features:
    convert_to_face_infos()

Untested Features:
    clipTails()
    mergeFaces()
    BDS.BVH2D = generateBVH() [requires HalfedgeMesh]

     * Splits the current embedding by the given polyline.
    embedAnotherPolyline(polyLine)
    eraseEdgesInCircle()
 */

(function() {
  SCRIB.Edge_Info = (function() {
    function Edge_Info(edge1, halfedge_info1) {
      this.edge = edge1;
      this.halfedge_info = halfedge_info1;
      this.id = this.edge.id;
    }

    return Edge_Info;

  })();

  SCRIB.Halfedge_Info = (function() {

    /*
     * Represents and points to a halfedge. Its pointers may not be valid after algorithms such as tail clipping.
    // Faces and twin pointers should still be valid though...
     * @halfedge is only defined for HalfedgeGraph based souce embeddings.
     * Also contains a pointer to its face_info object.
     */
    function Halfedge_Info(halfedge3, face_info1) {
      var next_data, next_point, next_vert, vert, vert_data;
      this.halfedge = halfedge3;
      this.face_info = face_info1;
      vert = this.halfedge.vertex;
      vert_data = vert.data;
      this.point = vert_data.point;
      this.id = this.halfedge.id;
      this.polyline = new BDS.Polyline(false);
      this.polyline.addPoint(this.point);
      this.polyline.setAssociatedData(this);
      next_vert = this.halfedge.next.vertex;
      next_data = next_vert.data;
      next_point = next_data.point;
      this.polyline.addPoint(next_point);
    }

    return Halfedge_Info;

  })();

  SCRIB.Face_Info = (function() {
    function Face_Info(face3) {
      this.face = face3;
      this.holes = [];
      this.halfedges = [];
      this._halfedge_bvh = null;
      this.polyline = new BDS.Polyline(true);
      this.polyline.setAssociatedData(this);
      this.faces_id_set = new Set();
      this.complemented = false;
    }

    Face_Info.prototype.size = function() {
      return this.points.length;
    };

    Face_Info.prototype.isClosed = function() {
      return polyline.isClosed();
    };

    Face_Info.prototype.getLastPointInfo = function() {
      return this.points[this.points.length - 1];
    };

    Face_Info.prototype.push = function(halfedge_info) {
      this.points.push(halfedge_info);
      return this.polyline.addPoint(halfedge_info.point);
    };

    Face_Info.prototype.pop = function() {
      this.polyline.removeLastPoint();
      return this.points.pop();
    };

    Face_Info.prototype.at = function(index) {
      return this.points[index];
    };

    Face_Info.prototype.isComplemented = function() {
      return this.polyline.isComplemented();
    };

    Face_Info.prototype.generateBVH = function() {
      var halfedge, i, j, len, line, ref, segments;
      segments = this.polyline.toPolylineSegments();
      len = segments.length;
      for (i = j = 0, ref = len; j < ref; i = j += 1) {
        line = segments[i];
        halfedge = this.halfedges[i];
        line.setAssociatedData(halfedge);
      }
      this._halfedge_bvh = new BDS.BVH2D(segments);
      return this._halfedge_bvh;
    };


    /*
    Edge Intersection functions.
    Returns all edges within this face that are also within the given geometries.
     */

    Face_Info.prototype.query_halfedges_in_circle = function(circle, output) {
      return this.query_halfedges_in_geometry(circle, output);
    };

    Face_Info.prototype.query_halfedges_in_polyline = function(polyline, output) {
      return this.query_halfedges_in_geometry(polyline, output);
    };

    Face_Info.prototype.query_halfedges_in_geometry = function(geom, output) {
      var all_halfedges, halfedge, j, len1, polyline;
      all_halfedges = this.query_halfedges_in_box(geom.generateBoundingBox());
      for (j = 0, len1 = all_halfedges.length; j < len1; j++) {
        halfedge = all_halfedges[j];
        polyline = halfedge.polyline;
        if (geom.detect_intersection_with_polyline(polyline)) {
          output.push(halfedge);
        }
      }
      return output;
    };

    Face_Info.prototype.query_halfedges_in_box = function(box, output_list) {
      var j, len1, line, polylines;
      if (this._halfedge_bvh === null) {
        this.generateBVH();
      }
      if (output_list === void 0) {
        output_list = [];
      }
      polylines = this._halfedge_bvh.query_box_all(box);
      for (j = 0, len1 = polylines.length; j < len1; j++) {
        line = polylines[j];
        output_list.push(line.getAssociatedData());
      }
      return output_list;
    };

    return Face_Info;

  })();

  SCRIB.PolylineGraphPostProcessor = (function() {
    function PolylineGraphPostProcessor() {
      this._graph = null;
      this._face_vector = null;
      this._face_bvh = null;
    }

    PolylineGraphPostProcessor.prototype.generate_faces_info = function() {
      var current, face, face_output, halfedge_info, iter, output, starting_half_edge;
      output = [];
      iter = this._graph.facesBegin();
      while (iter.hasNext()) {
        face = iter.next();
        face_output = new SCRIB.Face_Info(face);
        face_output.faces_id_set.add(face.id);
        starting_half_edge = face.halfedge;
        current = starting_half_edge;
        while (true) {
          halfedge_info = new SCRIB.Halfedge_Info(current, face_output);
          face_output.halfedges.push(halfedge_info);
          face_output.polyline.addPoint(halfedge_info.point);
          current = current.next;
          if (starting_half_edge === current) {
            break;
          }
        }
        output.push(face_output);
        continue;
      }
      this._face_vector = output;
      return output;
    };

    PolylineGraphPostProcessor.prototype.get_current_faces_info = function() {
      return this._face_vector;
    };

    PolylineGraphPostProcessor.prototype.load_graph = function(_graph) {
      this._graph = _graph;
      return this._face_vector = null;
    };

    PolylineGraphPostProcessor.prototype.free_face_vector = function() {
      return this._face_vector = null;
    };

    PolylineGraphPostProcessor.prototype.free_graph = function() {
      return this._graph = null;
    };


    /*
    Appends the indices of any external faces amongst the input list of faces to the output vector.
    NOTE : The input type is equivelant to the output type of the face finding functions,
    so using this function may be a natural extension of using the original functions.
     * int[] -> () [appends complemented faces to input]
     */

    PolylineGraphPostProcessor.prototype.determineComplementedFaces = function(output) {
      var area, face_info, index, j, len, ref;
      len = this._face_vector.length;
      for (index = j = 0, ref = len; 0 <= ref ? j < ref : j > ref; index = 0 <= ref ? ++j : --j) {
        face_info = this._face_vector[index];
        area = face_info.polyline.computeAreaOfPolygon();
        if (area > 0) {
          output.push(index);
        }
      }
    };

    PolylineGraphPostProcessor.prototype.determineNonTrivialAreaFaces = function(output, min_area) {
      var area, face_info, index, j, len, ref;
      len = this._face_vector.length;
      for (index = j = 0, ref = len; 0 <= ref ? j < ref : j > ref; index = 0 <= ref ? ++j : --j) {
        face_info = this._face_vector[index];
        area = face_info.polyline.computeAreaOfPolygon();
        area = area >= 0 ? area : -area;
        if (area >= min_area) {
          output.push(index);
        }
      }
    };

    PolylineGraphPostProcessor.prototype.determineTrivialAreaFaces = function(output, min_area) {
      var area, face_info, index, j, len, ref;
      len = this._face_vector.length;
      for (index = j = 0, ref = len; 0 <= ref ? j < ref : j > ref; index = 0 <= ref ? ++j : --j) {
        face_info = this._face_vector[index];
        area = face_info.polyline.computeAreaOfPolygon();
        area = area >= 0 ? area : -area;
        if (area < min_area) {
          output.push(index);
        }
      }
    };


    /*
    Input: a set of faces, Output: a new set of faces that have no trivial contiguous subfaces.
    clips all of the polylines currently loaded in this post processor.
    ENSURES: Polygons will be output either open or closed in the manner that they are passed in.
    ENSURES: Omits faces consisting of only a single long tail.
    The user is still responsible to deallocating the original vector.
     * () -> face_info[] (with no tails)
     */

    PolylineGraphPostProcessor.prototype.clipAllTails = function() {
      var clipped_face, index, input, j, len, output, ref, unclipped_face;
      input = this._face_vector;
      output = [];
      len = input(function() {
        return size();
      });
      for (index = j = 0, ref = len; 0 <= ref ? j < ref : j > ref; index = 0 <= ref ? ++j : --j) {
        unclipped_face = input[index];
        clipped_face = this._clipTails(unclipped_face);
        if (clipped_face.size() > 0) {
          output.push(clipped_face);
        }
      }
      return output;
    };

    PolylineGraphPostProcessor.prototype._clipTails = function(input) {
      var clipped_previous, i, j, len, non_empty_output, output, p_end, p_next, p_previous, p_start, prune_num, ref;
      output = new SCRIB.Face_Info();
      len = input(function() {
        return size();
      });
      if (len < 3 || !input.isClosed()) {
        return output;
      }
      p_start = (input(function() {
        return at(0);
      })).ID;
      p_end = (input(function() {
        return at(len - 1);
      })).ID;

      /*
      The main idea behind tail clipping is to transform regions of the form ABA --> A,
      in other words removing any consecutive pairs of half edges cooresponding to the same full edge.
      We therefore
       */
      clipped_previous = false;
      non_empty_output = false;
      for (i = j = 0, ref = len; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
        p_previous = 0/0;
        non_empty_output = output.size() > 0;
        if (non_empty_output) {
          p_previous = output.getLastPointInfo().ID;
        } else {
          p_previous = input.points[len - 1].ID;
        }
        p_next = input.points[(i + 1) % len].ID;
        if (p_previous !== p_next) {
          output.push(input.at(i % len));
          clipped_previous = false;
          continue;
        }
        clipped_previous = true;
        if (non_empty_output) {
          output.pop();
        } else {
          len -= 1;
        }

        /*
        Don't add the current point, because we prune it as well.
        If p_next ends up now being a non tail point, it will be successfully added during the next iteration.
        We don't add it now, because we want to give it the opportunity to pruned by its next neighbor.
         */
        continue;
      }
      prune_num = 0;
      while (clipped_previous) {
        len = output.size();
        if (len < 3) {
          return output;
        }
        p_previous = (output.at(len - 1)).ID;
        p_next = (output.at(prune_num + 1)).ID;
        if (p_previous !== p_next) {
          break;
        }
        prune_num += 1;
        output.pop();
        continue;
      }
      if (clipped_previous) {
        output.splice(0, prune_num);
      }
      return output;
    };


    /*
    Uses the currently loaded this->graph object as Input.
    Takes in a vector containing the integer IDs of the faces to be merged.
    Takes a dictionary containing integers and outputs a set of faces representing the merge.
    Outputs the result of unioning all of the faces.
    Set -> SCRIB.FaceInfo[]
     */

    PolylineGraphPostProcessor.prototype.mergeFaces = function(face_ID_set) {
      var current, face, face_info, faces_complemented, faces_uncomplemented, id, j, k, l, len1, len2, len3, len4, m, map, output, set, start, uncomplemented_face;
      faces_uncomplemented = [];
      faces_complemented = [];
      for (j = 0, len1 = face_ID_Set.length; j < len1; j++) {
        id = face_ID_Set[j];
        Face * (face = graph.getFace(id));
        Halfedge * (start = face.halfedge);
        Halfedge * (current = face.halfedge);
        while (true) {
          if (current.data.marked === false && this._halfedgeInUnion(face_ID_set, current)) {
            face_info = this._traceUnionFace(face_ID_set, current);
            if (!face_info.isComplemented()) {
              face.complemented = false;
              faces_uncomplemented.push(face);
            } else {
              face.complemented = true;
              faces_complemented.push(face);
            }
          }
          current = current.next;
          if (current === start) {
            break;
          }
        }
        continue;
      }
      graph.data.clearHalfedgeMarks();
      output = [];
      map = {};
      for (k = 0, len2 = faces_uncomplemented.length; k < len2; k++) {
        face_info = faces_uncomplemented[k];
        output.push_back(face_info);
        set = face_info.faces_ID_set;
        for (l = 0, len3 = set.length; l < len3; l++) {
          id = set[l];
          map[id] = face;
        }
      }
      for (m = 0, len4 = faces_complemented.length; m < len4; m++) {
        face_info = faces_complemented[m];
        id = face_info.faces_id_set.keys().next().value;
        uncomplemented_face = map[id];
        if (!uncomplemented_face) {
          output.push(face);
          continue;
        }
        uncomplemented_face.holes.push_back(face_info);
      }
      return output;
    };


    /*
    Returns true iff the given hafedge is included in the output of the union of the given faces.
    I.E. returns true iff the given half edge -> face is within the set of unioned faces and half_edge->twin -> face is not.
    Tail edges, where the halfedge and its twin are on the same face are not considered to be in a halfedgeUnion face.
    Set, SCRIB.Halfedge -> bool.
     */

    PolylineGraphPostProcessor.prototype._halfedgeInUnion = function(face_id_set, start) {
      var face, face_found, face_id, twin_ID, twin_face, twin_face_found;
      face = start.face;
      face_id = face.id;
      face_found = face_id_set.has(face_id);
      twin_face = start.twin.face;
      twin_ID = twin_face(function() {
        return ID;
      });
      twin_face_found = face_Id_set.has(twin_ID);
      return face_found && !twin_face_found;
    };


    /*
    // Given an In Union halfege, traces its face_info union face information.
    // Properly sets the output's: points and face_IDs fields.
    // Marks halfedges, therefore calling functions are responsible for unmarking halfedges.
    Set, SCRIB.Halfedge -> SCRIB.Face_Info
     */

    PolylineGraphPostProcessor.prototype._traceUnionFace = function(face_ID_set, start) {
      var current, current_face_ID, current_point_info, output, output_ID_set;
      output = new SCRIB.Face_Info();
      output_ID_set = output.faces_ID_set;
      current = start;
      while (true) {
        current.data.marked = true;
        current_point_info = this._halfedgeToPointInfo(current);
        output.push(current_point);
        current_face_ID = current.face.ID;
        output_ID_set.add(current_face_ID);
        current = this._nextUnionFace(face_ID_set, current);
        if (current === start) {
          break;
        }
      }
      return output;
    };

    PolylineGraphPostProcessor.prototype._nextUnionFace = function(face_ID_Set, current) {
      current = current.twin.prev.twin;
      while (!this._halfedgeInUnion(face_ID_Set, current)) {
        current = current.prev.twin;
      }
      return current;
    };

    PolylineGraphPostProcessor.prototype._halfedgeToPointInfo = function(halfedge) {
      var vertex, vertex_data;
      vertex = halfedge.vertex;
      vertex_data = vertex.data;
      return new SCRIB.Point_Info(vertex_data.point, vertex.ID, halfedge);
    };

    PolylineGraphPostProcessor.prototype.generateBVH = function() {
      var polylines;
      polylines = this.facesToPolylines(this._face_vector, true);
      return this._face_bvh = new BDS.BVH2D(polylines);
    };

    PolylineGraphPostProcessor.prototype.facesToPolylines = function(face_infos, allow_complemented_faces) {
      var allow_compleemented_faces, face_info, j, len1, output, polyline;
      if (allow_complemented_faces === void 0) {
        allow_compleemented_faces = false;
      }
      output = [];
      for (j = 0, len1 = face_infos.length; j < len1; j++) {
        face_info = face_infos[j];
        polyline = face_info.polyline;
        if ((!polyline.isComplemented()) || allow_complemented_faces) {
          output.push(polyline);
        }
        continue;
      }
      return output;
    };

    PolylineGraphPostProcessor.prototype.polylinesToAssociatedData = function(polylines) {
      var j, len1, line, output;
      output = [];
      for (j = 0, len1 = polylines.length; j < len1; j++) {
        line = polylines[j];
        output.push(line.getAssociatedData());
      }
      return output;
    };

    PolylineGraphPostProcessor.prototype.embedAnotherPolyline = function(polyLine) {
      throw new Error("IMPLEMENT ME PLEASE!");
    };


    /*
     * Graph wide Edge Queries.
     * Returns all elements in the graph within the given regions.
     * NOTE: If you already have faces found, it will be better to use the Face_Info query functions.
     * Note: Edge queries are implemented by first performing a face query
     * and then perfomring edge queries on those face's edge bvh's in the Face_Info objects.
     */

    PolylineGraphPostProcessor.prototype.query_edges_in_circle = function(circle, output) {
      return this.query_edges_in_geometry(circle, output);
    };

    PolylineGraphPostProcessor.prototype.query_edges_in_polyline = function(polyline, output) {
      return this.query_edges_in_geometry(polyline, output);
    };

    PolylineGraphPostProcessor.prototype.query_edges_in_geometry = function(geom, output) {
      var edges, halfedge, j, len1, polyline;
      edges = this.query_halfedges_in_box(geom.generateBoundingBox());
      for (j = 0, len1 = edges.length; j < len1; j++) {
        halfedge = edges[j];
        polyline = halfedge.polyline;
        if (geom.detect_intersection_with_polyline(polyline)) {
          output.push(geom);
        }
      }
      return output;
    };

    PolylineGraphPostProcessor.prototype.query_halfedges_in_box = function(box, output) {
      var face, faces, j, len1;
      faces = this.query_faces_in_box(box);
      if (output === void 0) {
        output = [];
      }
      for (j = 0, len1 = faces.length; j < len1; j++) {
        face = faces[j];
        face.query_halfedges_in_box(box, output);
      }
      return output;
    };


    /*
     * Face Queries.
     * Returns elements within the face bvh in the given area regions.
     */

    PolylineGraphPostProcessor.prototype.query_faces_in_circle = function(circle) {
      return this.query_faces_in_geometry(circle);
    };

    PolylineGraphPostProcessor.prototype.query_faces_in_polyline = function(polyline) {
      return this.query_faces_in_geometry(polyline);
    };

    PolylineGraphPostProcessor.prototype.query_faces_in_geometry = function(geom) {
      var box, j, len1, output, polyline, polylines_in_box;
      box = geom.generateBoundingBox();
      polylines_in_box = this._face_bvh.query_box_all(box);
      output = [];
      for (j = 0, len1 = polylines_in_box.length; j < len1; j++) {
        polyline = polylines_in_box[j];
        if (geom.detect_intersection_with_polyline(polyline)) {
          output.push(polyline.getAssociatedData());
        }
      }
      return output;
    };

    PolylineGraphPostProcessor.prototype.query_faces_in_box = function(box) {
      return this.polylinesToAssociatedData(this._face_bvh.query_box_all(box));
    };

    PolylineGraphPostProcessor.prototype.halfedgesToEdges = function(halfedge_infos) {
      var edge, edge_info, halfedge, halfedge_info, id, j, len1, output, set;
      output = [];
      set = new Set();
      for (j = 0, len1 = halfedge_infos.length; j < len1; j++) {
        halfedge_info = halfedge_infos[j];
        halfedge = halfedge_info.halfedge;
        edge = halfedge.edge;
        id = edge.id;
        if (set.has(id)) {
          continue;
        }
        set.add(id);
        edge_info = new SCRIB.Edge_Info(edge, halfedge_info);
        output.push(edge_info);
        continue;
      }
      return output;
    };


    /*
     * Element Deletion Methods.
     * These delete all Halfedge Mesh elements within a given region.
     * They then rebuild and preserve the invariants of the mesh.
     */

    PolylineGraphPostProcessor.prototype.eraseEdges = function(edge_infos, params) {
      var edge_info, j, len1;
      for (j = 0, len1 = edge_infos.length; j < len1; j++) {
        edge_info = edge_infos[j];
        this._eraseEdge(edge_info, params);
      }
      return this.generateBVH();
    };

    PolylineGraphPostProcessor.prototype._eraseEdge = function(edge_info, params) {
      var current, degree1, degree2, edge, face1, face2, face_info, h0, halfedge1, halfedge2, merge_faces, next, prev, vert1, vert2;
      edge = edge_info.edge;
      halfedge1 = edge.halfedge;
      halfedge2 = halfedge1.twin;
      vert1 = halfedge1.vertex;
      vert2 = halfedge2.vertex;
      degree1 = vert1.degree();
      degree2 = vert2.degree();
      face1 = halfedge1.face;
      face2 = halfedge2.face;
      merge_faces = face1 !== face2;
      if (merge_faces) {
        h0 = halfedge2.next;
        current = h0;
        while (true) {
          current.face = face1;
          current = current.next;
          if (current === h0) {
            break;
          }
        }
        face2.destroy();
      }
      if (degree1 === 1) {
        if (params.erase_lonely_vertices) {
          vert1.destroy();
        } else {
          vert1.make_lonely();
        }
      }
      if (degree2 === 1) {
        if (params.erase_lonely_vertices) {
          vert2.destroy();
        } else {
          vert2.make_lonely();
        }
      }
      if (degree1 === 1 && degree2 === 1) {
        face1.destroy();
        edge.destroy();
        halfedge1.destroy();
        halfedge2.destroy();
        return;
      }
      if (degree2 > 1) {
        next = halfedge1.next;
        prev = halfedge2.prev;
        next.prev = prev;
        prev.next = next;
        face1.halfedge = next;
        vert2.halfedge = next;
      }
      if (degree1 > 1) {
        next = halfedge2.next;
        prev = halfedge1.prev;
        next.prev = prev;
        prev.next = next;
        face1.halfedge = next;
        vert1.halfedge = next;
      }
      halfedge1.destroy();
      halfedge2.destroy();
      edge.destroy();
      face_info = edge_info.halfedge_info.face_info;
      face_info.generateBVH();
    };

    return PolylineGraphPostProcessor;

  })();

}).call(this);
