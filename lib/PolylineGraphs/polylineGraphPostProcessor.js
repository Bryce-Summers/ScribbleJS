// Generated by CoffeeScript 1.11.1

/*
The PolylineGraphPostProcessor class.
*
* Written and adapted from FaceFinder on 8/18/2016.
* Ported to Coffeescript on 1 - 4 - 2017.
*
* Purpose:
*
* Allows users to convert Planar Polyline Embedded Graphs into mainstream C++ data structures.
* This class then provides some useful processing algorithms on these output structures.
*
* I may also put information extraction algorithms here.
*
* The key idea is that the post processor doesn't mutate the Graph object in any way.
* FIXME: Use the Graph Mutator Proccessor instead (Currenly non existant.) if you wish to modify the graph.
*
* Maybe I will make a modification mode.
 */


/*
 * Convinent naming convention, more so for our benifit than the machine's since javscript is dynamically typed.

typedef SCRIB.Polyline[]  <-> Face_Vector_Format
typedef int[]             <-> Int_Vector_Format
typedef {}                <-> ID_Set
 */


/*

Tested Features:
    convert_to_face_infos()

Untested Features:
    clipTails()
    mergeFaces()
    BDS.BVH2D = generateBVH() [requires HalfedgeMesh]
 */

(function() {
  SCRIB.Point_Info = (function() {

    /*
    // The halfedge that this point represents when this point is collected in a Point_Vector to represent a face.
    // This may be used to easily extract local connectivity information and attributes for this point and its neighbors.
    // WARNING: This always points to the original embedding's connectivity information,
    // which means that things like next pointers may no longer be valid after tails are clipped or other algorithms.
    // Faces and twin pointers should still be valid though...
     * @halfedge is only defined for HalfedgeGraph based souce embeddings.
     */
    function Point_Info(point1, id1, halfedge1) {
      this.point = point1;
      this.id = id1;
      this.halfedge = halfedge1;
    }

    return Point_Info;

  })();

  SCRIB.Face_Info = (function() {
    function Face_Info() {
      this.holes = [];
      this.points = [];
      this.polyline = new BDS.Polyline(true);
      this.faces_id_set = new Set();
      this.complemented = false;
    }

    Face_Info.prototype.size = function() {
      return this.points.length;
    };

    Face_Info.prototype.isClosed = function() {
      return polyline.isClosed();
    };

    Face_Info.prototype.getLastPointInfo = function() {
      return this.points[this.points.length - 1];
    };

    Face_Info.prototype.push = function(point_info) {
      this.points.push(point_info);
      return this.polyline.addPoint(point_info.point);
    };

    Face_Info.prototype.pop = function() {
      this.polyline.removeLastPoint();
      return this.points.pop();
    };

    Face_Info.prototype.at = function(index) {
      return this.points[index];
    };

    Face_Info.prototype.isComplemented = function() {
      return this.polyline.isComplemented();
    };

    return Face_Info;

  })();

  SCRIB.PolylineGraphPostProcessor = (function() {
    function PolylineGraphPostProcessor() {
      this._graph = null;
      this._face_vector = null;
    }

    PolylineGraphPostProcessor.prototype.convert_to_face_infos = function() {
      var current, face, face_output, id, iter, output, point, point_info, starting_half_edge, vert, vert_data;
      output = [];
      iter = this._graph.facesBegin();
      while (iter.hasNext()) {
        face = iter.next();
        face_output = new SCRIB.Face_Info(true);
        face_output.faces_id_set.add(face.id);
        starting_half_edge = face.halfedge;
        current = starting_half_edge;
        while (true) {
          vert = current.vertex;
          vert_data = vert.data;
          point = vert_data.point;
          id = vert.id;
          point_info = new SCRIB.Point_Info(point, id, current);
          face_output.points.push(point_info);
          face_output.polyline.addPoint(point);
          current = current.next;
          if (starting_half_edge === current) {
            break;
          }
        }
        output.push(face_output);
      }
      return output;
    };


    /*
    This class performs operations on face vectors, but it only uses the current face vector as an input.
    The class never changes the loaded face vector internally.
    It is up to the user to load the proper face vector when they need a change.
     */

    PolylineGraphPostProcessor.prototype.load_face_vector = function(_face_vector) {
      this._face_vector = _face_vector;
    };

    PolylineGraphPostProcessor.prototype.load_graph = function(_graph) {
      this._graph = _graph;
    };

    PolylineGraphPostProcessor.prototype.free_face_vector = function() {
      return this._face_vector = null;
    };

    PolylineGraphPostProcessor.prototype.free_graph = function() {
      return this._graph = null;
    };


    /*
    Appends the indices of any external faces amongst the input list of faces to the output vector.
    NOTE : The input type is equivelant to the output type of the face finding functions,
    so using this function may be a natural extension of using the original functions.
     * int[] -> () [appends complemented faces to input]
     */

    PolylineGraphPostProcessor.prototype.determineComplementedFaces = function(output) {
      var area, face_info, index, j, len, ref;
      len = this._face_vector.length;
      for (index = j = 0, ref = len; 0 <= ref ? j < ref : j > ref; index = 0 <= ref ? ++j : --j) {
        face_info = this._face_vector[index];
        area = face_info.polyline.computeAreaOfPolygon();
        if (area > 0) {
          output.push(index);
        }
      }
    };

    PolylineGraphPostProcessor.prototype.determineNonTrivialAreaFaces = function(output, min_area) {
      var area, face_info, index, j, len, ref;
      len = this._face_vector.length;
      for (index = j = 0, ref = len; 0 <= ref ? j < ref : j > ref; index = 0 <= ref ? ++j : --j) {
        face_info = this._face_vector[index];
        area = face_info.polyline.computeAreaOfPolygon();
        area = area >= 0 ? area : -area;
        if (area >= min_area) {
          output.push(index);
        }
      }
    };

    PolylineGraphPostProcessor.prototype.determineTrivialAreaFaces = function(output, min_area) {
      var area, face_info, index, j, len, ref;
      len = this._face_vector.length;
      for (index = j = 0, ref = len; 0 <= ref ? j < ref : j > ref; index = 0 <= ref ? ++j : --j) {
        face_info = this._face_vector[index];
        area = face_info.polyline.computeAreaOfPolygon();
        area = area >= 0 ? area : -area;
        if (area < min_area) {
          output.push(index);
        }
      }
    };


    /*
    Input: a set of faces, Output: a new set of faces that have no trivial contiguous subfaces.
    clips all of the polylines currently loaded in this post processor.
    ENSURES: Polygons will be output either open or closed in the manner that they are passed in.
    ENSURES: Omits faces consisting of only a single long tail.
    The user is still responsible to deallocating the original vector.
     * () -> face_info[] (with no tails)
     */

    PolylineGraphPostProcessor.prototype.clipAllTails = function() {
      var clipped_face, index, input, j, len, output, ref, unclipped_face;
      input = this._face_vector;
      output = [];
      len = input(function() {
        return size();
      });
      for (index = j = 0, ref = len; 0 <= ref ? j < ref : j > ref; index = 0 <= ref ? ++j : --j) {
        unclipped_face = input[index];
        clipped_face = this._clipTails(unclipped_face);
        if (clipped_face.size() > 0) {
          output.push(clipped_face);
        }
      }
      return output;
    };

    PolylineGraphPostProcessor.prototype._clipTails = function(input) {
      var clipped_previous, i, j, len, non_empty_output, output, p_end, p_next, p_previous, p_start, prune_num, ref;
      output = new SCRIB.Face_Info();
      len = input(function() {
        return size();
      });
      if (len < 3 || !input.isClosed()) {
        return output;
      }
      p_start = (input(function() {
        return at(0);
      })).ID;
      p_end = (input(function() {
        return at(len - 1);
      })).ID;

      /*
      The main idea behind tail clipping is to transform regions of the form ABA --> A,
      in other words removing any consecutive pairs of half edges cooresponding to the same full edge.
      We therefore
       */
      clipped_previous = false;
      non_empty_output = false;
      for (i = j = 0, ref = len; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
        p_previous = 0/0;
        non_empty_output = output.size() > 0;
        if (non_empty_output) {
          p_previous = output.getLastPointInfo().ID;
        } else {
          p_previous = input.points[len - 1].ID;
        }
        p_next = input.points[(i + 1) % len].ID;
        if (p_previous !== p_next) {
          output.push(input.at(i % len));
          clipped_previous = false;
          continue;
        }
        clipped_previous = true;
        if (non_empty_output) {
          output.pop();
        } else {
          len -= 1;
        }

        /*
        Don't add the current point, because we prune it as well.
        If p_next ends up now being a non tail point, it will be successfully added during the next iteration.
        We don't add it now, because we want to give it the opportunity to pruned by its next neighbor.
         */
        continue;
      }
      prune_num = 0;
      while (clipped_previous) {
        len = output.size();
        if (len < 3) {
          return output;
        }
        p_previous = (output.at(len - 1)).ID;
        p_next = (output.at(prune_num + 1)).ID;
        if (p_previous !== p_next) {
          break;
        }
        prune_num += 1;
        output.pop();
        continue;
      }
      if (clipped_previous) {
        output.splice(0, prune_num);
      }
      return output;
    };


    /*
    Uses the currently loaded this->graph object as Input.
    Takes in a vector containing the integer IDs of the faces to be merged.
    Takes a dictionary containing integers and outputs a set of faces representing the merge.
    Outputs the result of unioning all of the faces.
    Set -> SCRIB.FaceInfo[]
     */

    PolylineGraphPostProcessor.prototype.mergeFaces = function(face_ID_set) {
      var current, face, face_info, faces_complemented, faces_uncomplemented, id, j, k, l, len1, len2, len3, len4, m, map, output, set, start, uncomplemented_face;
      faces_uncomplemented = [];
      faces_complemented = [];
      for (j = 0, len1 = face_ID_Set.length; j < len1; j++) {
        id = face_ID_Set[j];
        Face * (face = graph.getFace(id));
        Halfedge * (start = face.halfedge);
        Halfedge * (current = face.halfedge);
        while (true) {
          if (current.data.marked === false && this._halfedgeInUnion(face_ID_set, current)) {
            face_info = this._traceUnionFace(face_ID_set, current);
            if (!face_info.isComplemented()) {
              face.complemented = false;
              faces_uncomplemented.push(face);
            } else {
              face.complemented = true;
              faces_complemented.push(face);
            }
          }
          current = current.next;
          if (current === start) {
            break;
          }
        }
        continue;
      }
      graph.data.clearHalfedgeMarks();
      output = [];
      map = {};
      for (k = 0, len2 = faces_uncomplemented.length; k < len2; k++) {
        face_info = faces_uncomplemented[k];
        output.push_back(face_info);
        set = face_info.faces_ID_set;
        for (l = 0, len3 = set.length; l < len3; l++) {
          id = set[l];
          map[id] = face;
        }
      }
      for (m = 0, len4 = faces_complemented.length; m < len4; m++) {
        face_info = faces_complemented[m];
        id = face_info.faces_id_set.keys().next().value;
        uncomplemented_face = map[id];
        if (!uncomplemented_face) {
          output.push(face);
          continue;
        }
        uncomplemented_face.holes.push_back(face_info);
      }
      return output;
    };


    /*
    Returns true iff the given hafedge is included in the output of the union of the given faces.
    I.E. returns true iff the given half edge -> face is within the set of unioned faces and half_edge->twin -> face is not.
    Tail edges, where the halfedge and its twin are on the same face are not considered to be in a halfedgeUnion face.
    Set, SCRIB.Halfedge -> bool.
     */

    PolylineGraphPostProcessor.prototype._halfedgeInUnion = function(face_id_set, start) {
      var face, face_found, face_id, twin_ID, twin_face, twin_face_found;
      face = start.face;
      face_id = face.id;
      face_found = face_id_set.has(face_id);
      twin_face = start.twin.face;
      twin_ID = twin_face(function() {
        return ID;
      });
      twin_face_found = face_Id_set.has(twin_ID);
      return face_found && !twin_face_found;
    };


    /*
    // Given an In Union halfege, traces its face_info union face information.
    // Properly sets the output's: points and face_IDs fields.
    // Marks halfedges, therefore calling functions are responsible for unmarking halfedges.
    Set, SCRIB.Halfedge -> SCRIB.Face_Info
     */

    PolylineGraphPostProcessor.prototype._traceUnionFace = function(face_ID_set, start) {
      var current, current_face_ID, current_point_info, output, output_ID_set;
      output = new SCRIB.Face_Info();
      output_ID_set = output.faces_ID_set;
      current = start;
      while (true) {
        current.data.marked = true;
        current_point_info = this._halfedgeToPointInfo(current);
        output.push(current_point);
        current_face_ID = current.face.ID;
        output_ID_set.add(current_face_ID);
        current = this._nextUnionFace(face_ID_set, current);
        if (current === start) {
          break;
        }
      }
      return output;
    };

    PolylineGraphPostProcessor.prototype._nextUnionFace = function(face_ID_Set, current) {
      current = current.twin.prev.twin;
      while (!this._halfedgeInUnion(face_ID_Set, current)) {
        current = current.prev.twin;
      }
      return current;
    };

    PolylineGraphPostProcessor.prototype._halfedgeToPointInfo = function(halfedge) {
      var vertex, vertex_data;
      vertex = halfedge.vertex;
      vertex_data = vertex.data;
      return new SCRIB.Point_Info(vertex_data.point, vertex.ID, halfedge);
    };

    PolylineGraphPostProcessor.prototype.generateBVH = function() {
      return this._graph;
    };

    return PolylineGraphPostProcessor;

  })();

}).call(this);
