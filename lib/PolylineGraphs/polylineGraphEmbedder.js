// Generated by CoffeeScript 1.11.1

/*
* Transforms a set of input polylines into a planar graph embedding.
*
* Written by Bryce Summers.
*
* 8/16/2016: Written as a more fully advanced version of FaceFinder.h,
*            which outputs sophisticated graph structures oozing with useful connectivity information.
* 1/4/2017:  Ported to Coffeescript.
*
* Original C++ code written for the STUDIO for Creative Inquiry at Carnegie Mellon University.
 */


/*
* These algorithms include:
* Preprocessing:
* [EMPTY]
*
* Main Algorithm:
* 1. The main algorithm for embedding a set of polylines in space and determining the set of non chordal cycles in the
*    associated embedded planar graph.
*
* - A polygon is closed if it has identical starting and ending points and open otherwise.
*   The algorithm may be configured to output either open or closed polygons based on the closed_loop mode state.
*
* FIXME: If a user draws a second line completely around an original line, then their will be faces defined by both an external
*        face on the original polyline embedding and an internal face on the new enclosing embedding.
*        This may invalidate some users' assumptions of a global planar graph embedding without any holes.
*
* Post Processing:
* 1. Determine internal and external faces. (Initial Release)
* 2. Determine trivial and non trivial area faces according to a constant area threshold value. (8/11/2016)
*    (If you can't think of any good constant values, you might want to look at the field of
*     Topological Data Analysis and their 'barcode' concept: https://en.wikipedia.org/wiki/Topological_data_analysis.
* 3. Clipping off tails, i.e. portions of faces that enclose 0 area. (8/11/2016)
*    This could potentially be put into the getCycle function, but I think that it is best to make this a dedicated post processing step instead
*    in order to preserve the simplicity of the main algorithm.
*    This algorithm properly handles faces with either duplicated or non-duplicated starting and ending points.
*    i.e. Those produced in open and closed mode.
 */


/*
// FIXME: Write a list of all of the relevant interesting properties of the my planar embedding implementation.
// Edges always point to the forward facing halfedge.
// forward facing half edges are consecutively ordered in the first half.
// backwards facing half edges are consecutively ordered in the reverse order of the first half.
 */

(function() {
  SCRIB.PolylineGraphEmbedder = (function() {

    /*
    A User can explicitly pass false to force the intersection points to be found using a brute force algorithm that
    may potentially be more robust and reliable than the optimized intersection algorithm,
    but it kills the performance.
     */
    function PolylineGraphEmbedder(_useFastAlgo) {
      this._useFastAlgo = _useFastAlgo;
      if (this._useFastAlgo === void 0) {
        this._useFastAlgo = true;
      }
      this._points = [];
      this._lines_initial = [];
      this._lines_split = [];

      /*
      // The graph that is being built.
      // Once it is returned, the responsibility for this memory transfers to the user and the pointer is forgotten from this class.
       * FIXME: Should this graph embedded remember this guy?
       */
      this._graph = null;
    }


    /*
    Derives a planar graph embedding from the given input polyline.
    Assumes all points are distinct.
     */

    PolylineGraphEmbedder.prototype.embedPolyline = function(input) {
      if (input.size() <= 1) {
        return this._trivial(input);
      }
      this._loadPolyline(input);
      return this._do_the_rest();
    };


    /*
     * Derive faces from a set list of vertex disjoint polyline inputs.
     * Note: Each individual polyline specifies properties such as being closed or not.
     * Polyline[] (An array of polylines) -> SCRIB.Graph
     */

    PolylineGraphEmbedder.prototype.embedPolylineArray = function(inputs) {
      var e, j, len, len1;
      len = inputs.length;
      for (j = 0, len1 = inputs.length; j < len1; j++) {
        e = inputs[j];
        this._loadPolyline(e);
      }
      return this._do_the_rest();
    };

    PolylineGraphEmbedder.prototype._trivial = function(polyline) {
      var graph, linker, vertex, vertex_data;
      graph = this._newGraph();
      if (polyline.size() < 1) {
        return graph;
      }
      linker = new SCRIB.TopologyLinker(SCRIB.PolylineGraphEmbedder, graph);
      vertex = linker.link_island_vertex();
      vertex_data = vertex.data;
      vertex_data.point = polyline.getPoint(0);
      return graph;
    };

    PolylineGraphEmbedder.prototype._do_the_rest = function() {
      var output;
      this._splitIntersectionPoints();
      this._allocate_graph_from_input();
      this._sort_outgoing_edges_by_angle();
      this._associate_halfedge_cycles();
      output = this._deriveFaces();
      output.delete_index_arrays();
      this._cleanup();
      return output;
    };


    /*
    The embedding is broken down into seperate phases. Here I have listed each operation,
    followed by the data structures that they have built.
    
    Appends the given input points to the collated single input point array.
    Performs point fudging to avoid degenerate behavior.
    Starts up the indexed collection of points.
    SCRIB.Polyline -> ()
     */


    /*
    New Constructed data Fields:
    //The canonical collection of points at their proper indices.
    BDS.Point[] @_points
    // The original input lines.
    SCRIB.Line[] @_lines_initial
     */

    PolylineGraphEmbedder.prototype._loadPolyline = function(polyline) {
      var i, input_point, j, k, len, offset, ref, ref1;
      len = polyline.size();
      offset = this._points.length;
      for (i = j = 0, ref = len; j < ref; i = j += 1) {
        input_point = polyline.getPoint(i);
        if ((offset > 0 || i > 0) && this._points[offset + i - 1].x === input_point.x) {
          input_point.x += .001;
        }
        if (isNaN(input_point.x)) {
          debugger;
        }
        this._points.push(input_point);
      }
      for (i = k = 0, ref1 = len - 1; k < ref1; i = k += 1) {
        this._lines_initial.push(new BDS.Line(i + offset, i + offset + 1, this._points));
      }

      /*
      Add a line connecting the first and last points on the original set of input points if
      the polyline is closed.
      In other words put a duplicate copy of the initial point.
       */
      if (polyline.isClosed()) {
        this._lines_initial.push(new BDS.Line(len - 1 + offset, 0 + offset, this._points));
      }
    };


    /*
    Intersects the input lines, then splits them and connects them appropiatly.
    Populates the list of edge disjoint lines that only intersect at vertices.
    puts the edge in consecutive order following the input polylines.
    results put into this.lines_split
    () -> ()
     */


    /*
    New Constructed data Field:
    Split version of original input lines, where lines only intersect at vertices.
    SCRIB.Line[] @_lines_split
     */

    PolylineGraphEmbedder.prototype._splitIntersectionPoints = function() {
      var i, intersector, j, line, numLines, ref;
      intersector = new BDS.Intersector();
      if (this._useFastAlgo) {
        intersector.intersectLineSegments(this._lines_initial);
      } else {
        intersector.intersect_brute_force(this._lines_initial);
      }
      numLines = this._lines_initial.length;
      for (i = j = 0, ref = numLines; j < ref; i = j += 1) {
        line = this._lines_initial[i];
        line.getSplitLines(this._lines_split);
      }
    };


    /*
    #-- Step 3. Proccess the embedded input and initialize the Planar Graph vertices, edges, and halfedges.
    Allocates the output graph object and allocates vertices, edges, and halfedges for the input data.
    Vertices are Indexed as follows [original points 1 for input polyline 1, then 2, ...,
    new intersection points for polyline 1, then 2, etc, ...]
    Halfedges are indexed in polyline input order, then in backwards input order.
    () -> ()
     */


    /*
    New Constructed data Field:
    The graph that is being built and will eventually be returned to the user.
    SCRIB.Graph @_graph
     */

    PolylineGraphEmbedder.prototype._allocate_graph_from_input = function() {
      var e, edge, edge_ID, halfedge, halfedge_ID, i, j, k, l, last_backwards_halfedge, last_forwards_halfedge, last_index, len, len1, len2, line, point, ref, ref1, ref2, twin, twin_ID, vert, vert_data, vert_twin, vert_twin_data, vertex_ID, vertex_twin_ID;
      this._graph = this._newGraph();
      ref = this._points;
      for (j = 0, len1 = ref.length; j < len1; j++) {
        point = ref[j];
        vert = this._newVertex();
        vert_data = vert.data;
        vert.halfedge = null;
        vert_data.point = point;
      }
      ref1 = this._lines_split;
      for (k = 0, len2 = ref1.length; k < len2; k++) {
        e = ref1[k];
        this._newHalfedge();
        this._newHalfedge();
        this._newEdge();
      }

      /*
      Associate edges <-> halfedges.
            halfedges <-> twin halfedges.
            halfedges <-> vertices.
       */
      last_forwards_halfedge = null;
      last_backwards_halfedge = null;
      len = this._lines_split.length;
      last_index = len * 2 - 1;
      for (i = l = 0, ref2 = len; l < ref2; i = l += 1) {
        line = this._lines_split[i];
        vertex_ID = line.p1_index;
        vertex_twin_ID = line.p2_index;
        edge_ID = i;
        halfedge_ID = i;
        twin_ID = last_index - i;
        edge = this._graph.getEdge(edge_ID);
        halfedge = this._graph.getHalfedge(halfedge_ID);
        twin = this._graph.getHalfedge(twin_ID);
        vert = this._graph.getVertex(vertex_ID);
        vert_twin = this._graph.getVertex(vertex_twin_ID);
        vert_data = vert.data;
        vert_twin_data = vert_twin.data;
        edge.halfedge = halfedge;
        halfedge.edge = edge;
        twin.edge = edge;
        halfedge.twin = twin;
        twin.twin = halfedge;
        halfedge.vertex = vert;
        twin.vertex = vert_twin;
        if (vert.halfedge === null) {
          vert.halfedge = halfedge;
        }
        if (vert_twin.halfedge === null) {
          vert_twin.halfedge = twin;
        }
        if (halfedge === void 0 || twin === void 0) {
          debugger;
        }
        vert_data.outgoing_edges.push(halfedge);
        vert_twin_data.outgoing_edges.push(twin);
      }
    };

    PolylineGraphEmbedder.prototype._sort_outgoing_edges_by_angle = function() {
      var iter, outgoing_edges, vert_data;
      iter = this._graph.verticesBegin();
      while (iter.hasNext()) {
        vert_data = iter.next().data;
        outgoing_edges = vert_data.outgoing_edges;
        this._sort_outgoing_edges(outgoing_edges);
      }
    };

    PolylineGraphEmbedder.prototype._sort_outgoing_edges = function(outgoing_edges) {
      var angle, angles, center_data, center_point, center_vert, edge, hedge_in, hedge_out, i, i1, i2, j, k, l, len, len1, outer_data, outer_point, outer_vert, outgoing_halfedge_representative, ref, ref1, temp_f, temp_he;
      len = outgoing_edges.length;
      if (len <= 2) {
        return;
      }
      angles = [];
      outgoing_halfedge_representative = outgoing_edges[0];
      center_vert = outgoing_halfedge_representative.vertex;
      center_data = center_vert.data;
      center_point = center_data.point;
      for (j = 0, len1 = outgoing_edges.length; j < len1; j++) {
        edge = outgoing_edges[j];
        hedge_out = edge;
        hedge_in = hedge_out.twin;
        outer_vert = hedge_in.vertex;
        outer_data = outer_vert.data;
        outer_point = outer_data.point;
        angle = Math.atan2(outer_point.y - center_point.y, outer_point.x - center_point.x);
        angles.push(angle);
      }
      for (i = k = 0, ref = len; k < ref; i = k += 1) {
        for (i2 = l = ref1 = i - 1; l >= 0; i2 = l += -1) {
          i1 = i2 + 1;
          if (angles[i2] <= angles[i1]) {
            break;
          }
          temp_f = angles[i2];
          angles[i2] = angles[i1];
          angles[i1] = temp_f;
          temp_he = outgoing_edges[i2];
          outgoing_edges[i2] = outgoing_edges[i1];
          outgoing_edges[i1] = temp_he;
          if (outgoing_edges[i1] === void 0 || outgoing_edges[i2] === void 0) {
            debugger;
          }
        }
      }
    };


    /*
     * -- Step 5.
    Determines the next and previous pointers for the halfedges in the Graph.
    This is done almost entirely using the sets of outgoing edges for each vertex.
    vertices of degree 2 associate their 2 pairs of neighbors.
    vertices of degree are on a tail and associate their one pair of neighbors.
    vertices of degree >2 are intersection points and they first sort their neighbors, then associate their star.
    This function sets the Vertex_Data objects classification data.
     * () -> ()
     */

    PolylineGraphEmbedder.prototype._associate_halfedge_cycles = function() {
      var degree, hedge_in, hedge_out, i, iter, j, linker, outgoing_edges, ref, vert, vert_data;
      iter = this._graph.verticesBegin();
      while (iter.hasNext()) {
        vert = iter.next();
        vert_data = vert.data;
        outgoing_edges = vert_data.outgoing_edges;
        degree = outgoing_edges.length;
        if (degree === 0) {
          linker = new SCRIB.TopologyLinker(SCRIB.PolylineGraphEmbedder, this._graph);
          linker.link_island_vertex(vert);
          vert_data.singleton_point = true;
          continue;
        }
        if (degree === 1) {
          vert_data.tail_point = true;
          hedge_out = vert.halfedge;
          hedge_in = hedge_out.twin;
          hedge_out.prev = hedge_in;
          hedge_in.next = hedge_out;
          continue;
        }
        if (degree > 2) {
          vert_data.intersection_point = true;
        }
        for (i = j = 0, ref = degree; j < ref; i = j += 1) {
          hedge_out = outgoing_edges[i];
          if (hedge_out === void 0 || hedge_out.twin === void 0) {
            debugger;
          }
          hedge_in = hedge_out.twin;
          hedge_in.next = outgoing_edges[(i + 1) % degree];
          hedge_out.prev = outgoing_edges[(i + degree - 1) % degree].twin;
        }
        continue;
      }
    };


    /*
     * Step 6.
     * Uses the vertex and edge complete halfedge mesh to add face data.
     * Also produces simpler cycle structures along that serve as an alternate representation of the faces.
     * () -> SCRIB.Graph
     */

    PolylineGraphEmbedder.prototype._deriveFaces = function() {
      var face, halfedge, halfedge_data, iter;
      iter = this._graph.halfedgesBegin();
      while (iter.hasNext()) {
        halfedge = iter.next();
        halfedge_data = halfedge.data;
        if (halfedge_data.marked) {
          continue;
        }
        face = this._newFace();
        face.halfedge = halfedge;
        this._trace_face(face);
      }
      this._graph.data.clearHalfedgeMarks();
      return this._graph;
    };


    /*
    REQUIRES: 1. face -> halfedge well defined already.
              2. halfedge next pointer well defined already.
    ENSURES:  links every halfedge in the loop starting and ending at face -> halfedge
              with the face.
     * SCRIB.Face -> ()
     */

    PolylineGraphEmbedder.prototype._trace_face = function(face) {
      var current, start;
      start = face.halfedge;
      current = start;
      while (true) {
        current.face = face;
        current.data.marked = true;
        current = current.next;
        if (current === start) {
          break;
        }
      }
    };


    /*
    Free all of the intermediary data structures.
    Clear input structures.
    Unmark the output.
     */

    PolylineGraphEmbedder.prototype._cleanup = function() {
      this._points = [];
      this._lines_initial = [];
      return this._lines_split = [];
    };

    PolylineGraphEmbedder.prototype._newGraph = function() {
      return SCRIB.PolylineGraphEmbedder.newGraph();
    };

    PolylineGraphEmbedder.prototype._newFace = function() {
      return SCRIB.PolylineGraphEmbedder.newFace(this._graph);
    };

    PolylineGraphEmbedder.prototype._newEdge = function() {
      return SCRIB.PolylineGraphEmbedder.newEdge(this._graph);
    };

    PolylineGraphEmbedder.prototype._newHalfedge = function() {
      return SCRIB.PolylineGraphEmbedder.newHalfedge(this._graph);
    };

    PolylineGraphEmbedder.prototype._newVertex = function() {
      return SCRIB.PolylineGraphEmbedder.newVertex(this._graph);
    };

    PolylineGraphEmbedder.newGraph = function() {
      var output;
      output = new SCRIB.Graph(true);
      output.data = new SCRIB.Graph_Data(output);
      return output;
    };

    PolylineGraphEmbedder.newFace = function(graph) {
      var output;
      output = graph.newFace();
      output.data = new SCRIB.Face_Data(output);
      return output;
    };

    PolylineGraphEmbedder.newEdge = function(graph) {
      var output;
      output = graph.newEdge();
      output.data = new SCRIB.Edge_Data(output);
      return output;
    };

    PolylineGraphEmbedder.newHalfedge = function(graph) {
      var output;
      output = graph.newHalfedge();
      output.data = new SCRIB.Halfedge_Data(output);
      return output;
    };

    PolylineGraphEmbedder.newVertex = function(graph) {
      var output;
      output = graph.newVertex();
      output.data = new SCRIB.Vertex_Data(output);
      return output;
    };

    return PolylineGraphEmbedder;

  })();

  SCRIB.PolylineGraphGenerator = (function() {
    function PolylineGraphGenerator(_graph) {
      this._graph = _graph;
    }

    PolylineGraphGenerator.prototype.newGraph = function() {
      return SCRIB.PolylineGraphEmbedder.newGraph();
    };

    PolylineGraphGenerator.prototype.newFace = function(graph) {
      if (!graph) {
        graph = this._graph;
      }
      return SCRIB.PolylineGraphEmbedder.newFace(graph);
    };

    PolylineGraphGenerator.prototype.newEdge = function(graph) {
      if (!graph) {
        graph = this._graph;
      }
      return SCRIB.PolylineGraphEmbedder.newEdge(graph);
    };

    PolylineGraphGenerator.prototype.newHalfedge = function(graph) {
      if (!graph) {
        graph = this._graph;
      }
      return SCRIB.PolylineGraphEmbedder.newHalfedge(graph);
    };

    PolylineGraphGenerator.prototype.newVertex = function(graph) {
      if (!graph) {
        graph = this._graph;
      }
      return SCRIB.PolylineGraphEmbedder.newVertex(graph);
    };

    PolylineGraphGenerator.prototype.line_side_test = function(vert1, vert2, vert3) {
      var pt_c, ray;
      pt_c = vert3.data.point;
      ray = this._ray(vert1, vert2);
      return ray.line_side_test(pt_c);
    };

    PolylineGraphGenerator.prototype.vert_in_angle = function(vert_a, vert_b, vert_c, vert_pt) {
      var angle1, angle2, angle_pt, ray1, ray2, ray_pt;
      ray1 = this._ray(vert_b, vert_c);
      ray2 = this._ray(vert_b, vert_a);
      ray_pt = this._ray(vert_b, vert_pt);
      angle1 = ray1.getAngle();
      angle2 = ray2.getAngle();
      angle_pt = ray_pt.getAngle();
      if (angle2 <= angle1) {
        angle2 += Math.PI * 2;
      }
      if (angle_pt < angle1) {
        angle_pt += Math.PI * 2;
      }
      return angle1 <= angle_pt && angle_pt <= angle2;
    };

    PolylineGraphGenerator.prototype._ray = function(v1, v2) {
      var a, b, dir, ray;
      a = v1.data.point;
      b = v2.data.point;
      dir = b.sub(a);
      ray = new BDS.Ray(a, dir, 1);
      return ray;
    };

    return PolylineGraphGenerator;

  })();

}).call(this);
