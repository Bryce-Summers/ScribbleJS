// Generated by CoffeeScript 1.11.1

/*
Halfedge Graph / Mesh class.
Written by Bryce Summers on 1 - 2 - 2017.
 */


/*
* FIXME: Writeup my modified usage, now that we are in javasccript.
*
* Usage:
*
* The Application programmer / New Media Artist specifies the following:
* 1. The data format they have availible for graph construction (e.g. vectors of openframeworks points.)
* 2. The Algorithms they need.
* 3. The data format that they wish to receive the results in.
*
* They will do so by specifying which class definitions they want.
*
* The algorithm designer / computational geometer specifies the following:
* 1. Definitions for the associated data.
* 2. The interface for constructing Graphs from application data
* 3. The interface for running algorithms on the Graphs.
* 4. The interface for allowing the application programmer to retrieve the results.
*
* If done elegantly, the New Media Artist should never need to touch the halfedge mesh, go on pointer journeys, and
* they should be able to treat the internal implementation as a black box.
 */


/*
 * -- Associated Data Classes.

#Since Javascript is untyped, these will mostly be her for convenience, and the user can insert the data they wish into each of these structures.

Every graph element will have a reserved variable called 'data' for linking to application specific information.

class SCRIB.Graph_Data
class SCRIB.Vertex_Data
class SCRIB.Face_Data
class SCRIB.Halfedge_Data
class SCRIB.Edge_Data
 */


/*
// FIXME: Clean up this prose.

// -- Structural definition of classes.
// Every class is specified by its connectivity information and a pointer to associated user data.

// All elements may be marked and unmarked by algorithms and users to specific sets of elements that meet various criteria.

// The Graph class represents an entire graph embedding defined by points in space.
// For the purposes of the facefinder, the output graph will be planar.
// connected via edges that intersect only at vertices.
// The FaceFinder class may be used to derive a Graph from a set of potentially intersecting input polylines.
 */

(function() {
  SCRIB.Graph = (function() {

    /*
    // Graph classes are where all of the actual data will be stored, so it contains vectors of valued data,
    // rather than pointers.
    // All ID's contained within these vectors will reference tha index of the object within these vectors.
    
    // Ideally, vertices, edges, and halfedges will be ordered logically according to the order they were input into the facefinder,
    // but I will need to do some more thinking on how to formally specify these things.
     */
    function Graph(_allocate_index_arrays) {
      this._allocate_index_arrays = _allocate_index_arrays;
      this._faces = new BDS.DoubleLinkedList();
      this._vertices = new BDS.DoubleLinkedList();
      this._edges = new BDS.DoubleLinkedList();
      this._halfedges = new BDS.DoubleLinkedList();
      if (this._allocate_index_arrays) {
        this._face_array = [];
        this._vertex_array = [];
        this._edge_array = [];
        this._halfedge_array = [];
      }
      this._data = null;
    }

    Graph.prototype.newFace = function() {
      var id, iter, output;
      id = this._faces.size();
      output = new SCRIB.Face();
      this._faces.push_back(output);
      if (this._face_array) {
        this._face_array.push(output);
      }
      output.id = id;
      iter = this._faces.end();
      iter.prev()._iterator = iter;
      return output;
    };

    Graph.prototype.newVertex = function() {
      var id, iter, output;
      id = this._vertices.size();
      output = new SCRIB.Vertex();
      this._vertices.push_back(output);
      if (this._vertex_array) {
        this._vertex_array.push(output);
      }
      output.id = id;
      iter = this._vertices.end();
      iter.prev()._iterator = iter;
      return output;
    };

    Graph.prototype.newEdge = function() {
      var id, iter, output;
      id = this._edges.size();
      output = new SCRIB.Edge();
      this._edges.push_back(output);
      if (this._edge_array) {
        this._edge_array.push(output);
      }
      output.id = id;
      iter = this._edges.end();
      iter.prev()._iterator = iter;
      return output;
    };

    Graph.prototype.newHalfedge = function() {
      var id, iter, output;
      id = this._halfedges.size();
      output = new SCRIB.Halfedge();
      this._halfedges.push_back(output);
      if (this._halfedge_array) {
        this._halfedge_array.push(output);
      }
      output.id = id;
      iter = this._halfedges.end();
      iter.prev()._iterator = iter;
      return output;
    };

    Graph.prototype.deleteElement = function(e) {
      return e._iterator.remove();
    };

    Graph.prototype.getData = function() {
      return this._data;
    };

    Graph.prototype.numFaces = function() {
      return this._faces.size();
    };

    Graph.prototype.numVertices = function() {
      return this._vertices.size();
    };

    Graph.prototype.numEdges = function() {
      return this._edges.size();
    };

    Graph.prototype.numHalfedges = function() {
      return this._halfedges.size();
    };

    Graph.prototype.getFace = function(id) {
      return this._face_array[id];
    };

    Graph.prototype.getVertex = function(id) {
      return this._vertex_array[id];
    };

    Graph.prototype.getEdge = function(id) {
      return this._edge_array[id];
    };

    Graph.prototype.getHalfedge = function(id) {
      return this._halfedge_array[id];
    };

    Graph.prototype.delete_index_arrays = function() {
      delete this._face_array;
      delete this._vertex_array;
      delete this._edge_array;
      return delete this._halfedge_array;
    };


    /*
     - Iteration functions.
     - These all return BDS.DoubleListIterator's
     */

    Graph.prototype.facesBegin = function() {
      return this._faces.begin();
    };

    Graph.prototype.facesEnd = function() {
      return this._faces.end();
    };

    Graph.prototype.verticesBegin = function() {
      return this._vertices.begin();
    };

    Graph.prototype.verticesEnd = function() {
      return this._vertices.end();
    };

    Graph.prototype.edgesBegin = function() {
      return this._edges.begin();
    };

    Graph.prototype.edgesEnd = function() {
      return this._edges.end();
    };

    Graph.prototype.halfedgesBegin = function() {
      return this._halfedges.begin();
    };

    Graph.prototype.halfedgesEnd = function() {
      return this._halfedges.end();
    };

    return Graph;

  })();

  SCRIB.Face = (function() {
    function Face() {
      this.halfedge = null;
      this.data = new SCRIB.Face_Data();
      this.id = null;
      this._iterator = null;
    }

    return Face;

  })();

  SCRIB.Vertex = (function() {
    function Vertex() {
      this.halfedge = null;
      this.data = null;
      this.id = null;
      this._iterator = null;
    }

    return Vertex;

  })();

  SCRIB.Edge = (function() {
    function Edge() {}

    Edge.halfedge = null;

    Edge.data = null;

    Edge.id = null;

    Edge._iterator = null;

    return Edge;

  })();

  SCRIB.Halfedge = (function() {
    function Halfedge() {
      this.twin = null;
      this.next = null;
      this.prev = null;
      this.face = null;
      this.edge = null;
      this.vertex = null;
      this.data = null;
      this.id = null;
      this._iterator = null;
    }

    return Halfedge;

  })();

}).call(this);
