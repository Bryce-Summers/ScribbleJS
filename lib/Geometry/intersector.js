// Generated by CoffeeScript 1.11.1

/*

Intersector

Written by Bryce Summers on 1 - 2 - 2017.

Adapted from: https://github.com/Bryce-Summers/ofxScribbleSegmenter

Canonical scrib::Line objects are represented by LineTuple objects in a bst.
Events along the sweep line are managed by a priority queue.

This implementation should properly handle lines originating from the same end points.

Note : Sets regard types as being equal when their cooresponding ordering operator returns true reflexively.
BDS structure use <= comparator predicate functions.
 */

(function() {
  SCRIB.Intersector = (function() {
    function Intersector() {}


    /*
    Calls the Line::intersect method on all intersecting lines.
    Does not treat lines that intersect at common points as intersecting.
     * takes arrays of Scrib.Line objects.
    SCRIB.Line[] -> () [intersection sideeffects]
     */

    Intersector.prototype.intersect = function(lines) {
      var event, event_queue, i, j, len, ref, results, tupleSet;
      event_queue = new SCRIB.EventPQ(lines);
      tupleSet = new SCRIB.LineTupleSet();
      len = event_queue.size();
      results = [];
      for (i = j = 0, ref = len; j < ref; i = j += 1) {
        event = event_queue.delMin();
        switch (event.type) {
          case SCRIB.Event.ENTER:
            tupleSet.addTuple(event.tuple2, i);
            continue;
          case SCRIB.Event.EXIT:
            tupleSet.removeTuple(event.tuple2);
            continue;
          default:
            results.push(void 0);
        }
      }
      return results;
    };


    /*
    Slower, but more robust version of intersect.
    Naive N^2 Intersection Algorithm.
     */

    Intersector.prototype.intersect_brute_force = function(lines) {
      var a, b, j, numLines, ref, results;
      numLines = lines.length;
      results = [];
      for (a = j = 0, ref = numLines; 0 <= ref ? j < ref : j > ref; a = 0 <= ref ? ++j : --j) {
        results.push((function() {
          var k, ref1, ref2, results1;
          results1 = [];
          for (b = k = ref1 = a + 1, ref2 = numLines; ref1 <= ref2 ? k < ref2 : k > ref2; b = ref1 <= ref2 ? ++k : --k) {
            results1.push(lines[a].intersect(lines[b]));
          }
          return results1;
        })());
      }
      return results;
    };

    return Intersector;

  })();


  /*
  Event Priority Queue methods.
   */

  SCRIB.EventPQ = (function() {
    function EventPQ(lines) {
      var enter, events, exit, i, j, len, line, p1, p2, ref;
      events = [];
      len = lines.length;
      for (i = j = 0, ref = len; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
        line = lines[i];
        enter = new SCRIB.Event();
        exit = new SCRIB.Event();
        p1 = line.p1;
        p2 = line.p2;
        if (p1.x < p2.x || (p1.x === p2.x && p1.y < p2.y)) {
          this._populateEvent(enter, exit, p1, p2, line, i);
        } else {
          this._populateEvent(enter, exit, p2, p1, line, i);
        }
        events.push(enter);
        events.push(exit);
      }
      this.PQ = new BDS.Heap(events, SCRIB.Event_Comparator);
    }

    EventPQ.prototype._populateEvent = function(enter, exit, p1, p2, line, id) {
      var line_tuple, line_tuple2;
      enter.type = SCRIB.Event.ENTER;
      exit.type = SCRIB.Event.EXIT;
      enter.x = p1.x;
      enter.y = p1.y;
      exit.x = p2.x;
      exit.y = p2.y;
      line_tuple = new SCRIB.LineTuple();
      line_tuple.x = p1.x;
      line_tuple.y = p1.y;
      line_tuple.line = line;
      line_tuple.id = id;
      line_tuple2 = new SCRIB.LineTuple();
      line_tuple2.x = p2.x;
      line_tuple2.y = p2.y;
      line_tuple2.line = line;
      line_tuple2.id = id;
      enter.tuple1 = line_tuple;
      enter.tuple2 = line_tuple2;
      exit.tuple1 = line_tuple;
      return exit.tuple2 = line_tuple2;
    };

    EventPQ.prototype.delMin = function() {
      return this.PQ.dequeue();
    };

    EventPQ.prototype.isEmpty = function() {
      return this.PQ.isEmpty();
    };

    EventPQ.prototype.size = function() {
      return this.PQ.size();
    };

    return EventPQ;

  })();

  SCRIB.Event_Comparator = function(e1, e2) {
    if (e1.tuple1 === e2.tuple1 && e1.type === e2.type) {
      return true;
    }
    if (e1.tuple1 === e2.tuple1) {
      return e1.type === SCRIB.Event.ENTER;
    }
    if (e1.x < e2.x) {
      return true;
    }
    if (e2.x < e1.x) {
      return false;
    }
    if (e1.y < e2.y) {
      return true;
    }
    if (e2.y > e1.y) {
      return false;
    }
    if ((e1.type === SCRIB.Event.EXIT) && (e2.type === SCRIB.Event.ENTER)) {
      return true;
    }
    if ((e1.type === SCRIB.Event.ENTER) && (e2.type === SCRIB.Event.EXIT)) {
      return false;
    }
    if (e1.tuple1.id <= e2.tuple1.id) {
      return true;
    }
    return false;
  };

  SCRIB.LineTuple_Comparator = function(e1, e2) {
    if (e1 === e2) {
      return true;
    }
    if (e1.x < e2.x) {
      return true;
    }
    if (e1.x > e2.x) {
      return false;
    }
    if (e1.y < e2.y) {
      return true;
    }
    if (e1.y > e2.y) {
      return false;
    }
    return e1.id <= e2.id;
  };


  /*
  Line Tuples are stored in a binary search tree to
  represent the lines currently crossing the sweep line.
   */

  SCRIB.LineTuple = (function() {
    function LineTuple() {
      this.line = null;
      this.x = null;
      this.y = null;
      this.id = null;
    }

    return LineTuple;

  })();

  SCRIB.LineTupleSet = (function() {
    function LineTupleSet() {
      this.heap = new BDS.Heap([], SCRIB.LineTuple_Comparator);
    }

    LineTupleSet.prototype.addTuple = function(line_tuple, id) {
      var i, input_line, j, len, line_crossing_sweep, ref, tuple;
      line_tuple.id = id;
      input_line = line_tuple.line;
      len = this.heap.size();
      for (i = j = 0, ref = len; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
        tuple = this.heap.getElem(i);
        line_crossing_sweep = tuple.line;
        input_line.intersect(line_crossing_sweep);
      }
      return this.heap.add(line_tuple);
    };

    LineTupleSet.prototype.removeTuple = function(line_tuple) {
      var tuple;
      tuple = this.heap.dequeue();
      if (tuple !== line_tuple) {
        throw new Error("ERROR: line_tuple exit ordering is messed up!");
      }
      return tuple;
    };

    return LineTupleSet;

  })();

  SCRIB.Event = (function() {
    Event.ENTER = 0;

    Event.EXIT = 1;

    function Event() {
      this.tuple1 = null;
      this.tuple2 = null;
      this.type = null;
      this.x = null;
      this.y = null;
    }

    return Event;

  })();

}).call(this);
