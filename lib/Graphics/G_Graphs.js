// Generated by CoffeeScript 1.11.1

/*

A Useful Graphics class for drawing Scribble.js objects,
such as Polyline Graph embeddings, HalfedgeGraphs, etc
onto a canvas element.

Takes in a BDS.G_ object and creates these calls using that object.
Because of this, A canvas target drawing class may be swapped out for a three.js, serial writing, 
or alternative drawing class that comes along.


It also has some visual design and aethetics functions, such as colorGraph(), which 6 colors a list of face_infos.
 */

(function() {
  SCRIB.G_Graphs = (function() {
    function G_Graphs(_G) {
      this._G = _G;
    }

    G_Graphs.prototype.setLowerG = function(g) {
      return this._G = g;
    };

    G_Graphs.prototype.getLowerG = function() {
      return this._G;
    };

    G_Graphs.prototype.drawVerts = function(graph) {
      var circle, iter, point, results, vert;
      iter = graph.verticesBegin();
      results = [];
      while (iter.hasNext()) {
        vert = iter.next();
        point = vert.data.point;
        circle = new BDS.Circle(point, 5, true);
        this._G.strokeColor(0xffffff);
        this._G.fillColor(0x222222);
        this._G.drawCircle(circle);
        this._G.fillColor(0xffffff);
        results.push(this._G.drawText(vert.id, point.x + 16, point.y + 16));
      }
      return results;
    };

    G_Graphs.prototype.drawFaceInfoArray = function(face_info_array) {
      var color, comp_faces, face, i, j, len, ref, results;
      comp_faces = [];
      len = face_info_array.length;
      for (i = j = 0, ref = len; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
        face = face_info_array[i];
        if (face.color === void 0) {
          face.color = this._G.randomColor();
        }
        color = face.color;
        if (!face.isExterior()) {
          this._G.fillColor(color);
          this._G.strokeColor(0x000000);
          this._G.drawPolygon(face.polyline);
          this._G.drawPolyline(face.polyline);
        } else {
          comp_faces.push(face);
        }
      }
      results = [];
      while (comp_faces.length > 0) {
        face = comp_faces.pop();
        this._G.strokeColor(0xffffff);
        results.push(this._G.drawPolyline(face.polyline));
      }
      return results;
    };

    G_Graphs.prototype.drawEdgeInfoArray = function(edge_info_array) {
      var edge_info, i, j, len, ref, results;
      this._G.strokeColor(0xff0000);
      len = edge_info_array.length;
      results = [];
      for (i = j = 0, ref = len; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
        edge_info = edge_info_array[i];
        results.push(this._G.drawPolyline(edge_info.polyline));
      }
      return results;
    };

    G_Graphs.prototype.drawPolyLine_Array = function(polylines) {
      var i, j, len, ref, results;
      this._G.strokeColor(0xff0000);
      len = polylines.length;
      results = [];
      for (i = j = 0, ref = len; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
        results.push(this._G.drawPolyline(polylines[i]));
      }
      return results;
    };

    G_Graphs.prototype.colorGraph = function(graph, face_infos) {
      var color_id, coloring, colors, faceGraph, face_info, i, j, ref, results;
      faceGraph = new SCRIB.FaceGraph(graph);
      coloring = faceGraph.autoColor();
      colors = [0xbae3ff, 0xffbae3, 0xe3ffba, 0xffd6ba, 0xbac1ff, 0xbafff9];
      results = [];
      for (i = j = 0, ref = face_infos.length; j < ref; i = j += 1) {
        face_info = face_infos[i];
        color_id = parseInt(coloring[face_info.id]);
        if (color_id >= colors.length) {
          results.push(face_info.color = this._G.newColor(100, 100, 100));
        } else {
          results.push(face_info.color = colors[color_id]);
        }
      }
      return results;
    };

    return G_Graphs;

  })();

}).call(this);

//# sourceMappingURL=G_Graphs.js.map
